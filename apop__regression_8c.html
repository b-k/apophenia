<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html> <head>
     <title>Apophenia: a library for scientific computing</title>

<!-- Google is watching. -->
<script src="http://www.google-analytics.com/urchin.js" type="text/javascript">
</script>
<script type="text/javascript">
_uacct = "UA-134313-2";
urchinTracker();
</script>


     <link rel="stylesheet" href="typical.css" type="text/css" >
     <script  type="text/javascript" language="JavaScript" src="tree.js"></script>
</head><body>
     <center><table cellpadding=10pt>
     <tr> <td><img width=140px src=flake.gif alt="Patterns in static"></td> 
    <td><table>
     	<tr> <td><center><h2><a href="http://apophenia.info">Apophenia</a></h2></center></td></tr>
<tr><td><div class="qindex"><a class="qindex" href="index.html">&nbsp;Intro</a> | <a class="qindex" href="outline.html">Outline</a> | <a class="qindex" href="globals.html">Index</a> <!--| <a class="qindex" href="files.html">File&nbsp;List&nbsp;</a> -->  </div></td></tr></table>
	</td></tr></table></center>

<!-- Generated by Doxygen 1.7.4 -->
</div>
<div class="header">
  <div class="summary">
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">apop_regression.c File Reference</div>  </div>
</div>
<div class="contents">
<h2><a name="typedef-members"></a>
Typedefs</h2>
<ul>
<li><a class="anchor" id="aac6edf471b08cd528b8daafd8cd6b397"></a><!-- doxytag: member="apop_regression.c::ccp" ref="aac6edf471b08cd528b8daafd8cd6b397" args="" -->
typedef const char * <b>ccp</b>
</ul>
<h2><a name="func-members"></a>
Functions</h2>
<ul>
<li>void <a class="el" href="apop__regression_8c.html#ae165633525c5272ab83794b60076eddc">apop_estimate_parameter_tests</a> (<a class="el" href="struct__apop__model.html">apop_model</a> *est)
<li>gsl_vector * <a class="el" href="apop__regression_8c.html#a6d68bacc086420a382366f9118cf5bc7">apop_vector_unique_elements</a> (const gsl_vector *v)
<li><a class="el" href="struct__apop__data.html">apop_data</a> * <a class="el" href="apop__regression_8c.html#a77c937ea4764d3da2ed9968273fa4544">apop_text_unique_elements</a> (const <a class="el" href="struct__apop__data.html">apop_data</a> *d, size_t col)
<li><a class="el" href="struct__apop__data.html">apop_data</a> * <a class="el" href="apop__regression_8c.html#ae0c28224e10f8aacdaa2d130f96f6ba2">apop_data_to_dummies</a> (<a class="el" href="struct__apop__data.html">apop_data</a> *d, int col, char type, int keep_first, char append, char remove)
<li><a class="el" href="struct__apop__data.html">apop_data</a> * <a class="el" href="apop__regression_8c.html#a27405bd5fdf48d93c8918ca4c07ee260">apop_data_to_factors</a> (<a class="el" href="struct__apop__data.html">apop_data</a> *data, char intype, int incol, int outcol)
<li><a class="el" href="struct__apop__data.html">apop_data</a> * <a class="el" href="apop__regression_8c.html#adec9170cf1382f6cd549a5819472eb51">apop_data_get_factor_names</a> (<a class="el" href="struct__apop__data.html">apop_data</a> *data, int col, char type)
<li><a class="el" href="struct__apop__data.html">apop_data</a> * <a class="el" href="apop__regression_8c.html#a3771d1cda273eade98c4fa6ddb7d8c3d">apop_text_to_factors</a> (<a class="el" href="struct__apop__data.html">apop_data</a> *d, size_t textcol, int datacol)
<li><a class="el" href="struct__apop__data.html">apop_data</a> * <a class="el" href="group__regression.html#gaceead3e4aaba543b7fc1d194fcbc40f8">apop_estimate_coefficient_of_determination</a> (<a class="el" href="struct__apop__model.html">apop_model</a> *m)
</ul>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Generally, if it assumes something is Normally distributed, it's here. </p>
</div><hr/><h2>Function Documentation</h2>
<a class="anchor" id="adec9170cf1382f6cd549a5819472eb51"></a><!-- doxytag: member="apop_regression.c::apop_data_get_factor_names" ref="adec9170cf1382f6cd549a5819472eb51" args="(apop_data *data, int col, char type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct__apop__data.html">apop_data</a>* apop_data_get_factor_names </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__apop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Factor names are stored in an auxiliary table with a name like <code>"&lt;categories for your_var&gt;"</code>. Producing this name is annoying (and prevents us from eventually making it human-language independent), so use this function to get the list of factor names.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The data set. (No default, must not be <code>NULL</code>) </td></tr>
    <tr><td class="paramname">col</td><td>The column whose name I'll use to check for the factor name list. Vector==-1. (default=0) </td></tr>
    <tr><td class="paramname">type</td><td>If you are referring to a text column, use 't'. (default='d')</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A pointer to the page in the data set with the given factor names.</dd></dl>
<ul>
<li>This function uses the <a class="el" href="designated.html">Designated initializers</a> syntax for inputs. </li>
</ul>

</div>
</div>
<a class="anchor" id="ae0c28224e10f8aacdaa2d130f96f6ba2"></a><!-- doxytag: member="apop_regression.c::apop_data_to_dummies" ref="ae0c28224e10f8aacdaa2d130f96f6ba2" args="(apop_data *d, int col, char type, int keep_first, char append, char remove)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct__apop__data.html">apop_data</a>* apop_data_to_dummies </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__apop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>keep_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>append</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>remove</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>A utility to make a matrix of dummy variables. You give me a single vector that lists the category number for each item, and I'll produce a matrix with a single one in each row in the column specified.</p>
<p>After that, you have to decide what to do with the new matrix and the original data column.</p>
<ul>
<li>You can manually join the dummy data set with your main data, e.g.: <div class="fragment"><pre class="fragment"><a class="code" href="struct__apop__data.html">apop_data</a> *dummies  = <a class="code" href="apop__regression_8c.html#ae0c28224e10f8aacdaa2d130f96f6ba2">apop_data_to_dummies</a>(main_regression_vars, .col=8, .type=<span class="charliteral">&#39;t&#39;</span>);
<a class="code" href="apop__data_8c.html#a0f2ffb5c5ba2bb240e930be08fc4fd56">apop_data_stack</a>(main_regression_vars, dummies, <span class="charliteral">&#39;c&#39;</span>, .inplace=<span class="charliteral">&#39;y&#39;</span>);
</pre></div></li>
</ul>
<ul>
<li>The <code>.remove='y'</code> option specifies that I should use <a class="el" href="types_8h.html#a1312f6568cfe832f1e35f7f44482ffb4">apop_data_rm_columns</a> to remove the column used to generate the dummies. Implemented only for <code>type=='d'</code>.</li>
</ul>
<ul>
<li>By specifying <code>.append='y'</code> or <code>.append='e'</code> I will run the above two lines for you. Your <a class="el" href="gentle.html#apop_data">apop_data</a> pointer will not change, but its <code>matrix</code> element will be reallocated (via <a class="el" href="types_8h.html#a0f2ffb5c5ba2bb240e930be08fc4fd56">apop_data_stack</a>).</li>
</ul>
<ul>
<li>By specifying <code>.append='i'</code>, I will place the matrix of dummies in place, immediately after the data column you had specified. You will probably use this with <code>.remove='y'</code> to replace the single column with the new set of dummy columns. Bear in mind that if there are two or more dummy columns (which there probably are if you are bothering to use this function), subsequent column numbers will change.</li>
</ul>
<ul>
<li>If <code>.append='i'</code> and you asked for a text column, I will append to the end of the table, which is equivalent to <code>append='e'</code>.</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>The data set with the column to be dummified (No default.) </td></tr>
    <tr><td class="paramname">col</td><td>The column number to be transformed; -1==vector (default = 0) </td></tr>
    <tr><td class="paramname">type</td><td>'d'==data column, 't'==text column. (default = 't') </td></tr>
    <tr><td class="paramname">keep_first</td><td>if zero, return a matrix where each row has a one in the (column specified MINUS ONE). That is, the zeroth category is dropped, the first category has an entry in column zero, et cetera. If you don't know why this is useful, then this is what you need. If you know what you're doing and need something special, set this to one and the first category won't be dropped. (default = 0) </td></tr>
    <tr><td class="paramname">append</td><td>If <code>'e'</code> or <code>'y'</code>, append the dummy grid to the end of the original data matrix. If <code>'i'</code>, insert in place, immediately after the original data column. (default = <code>'n'</code>) </td></tr>
    <tr><td class="paramname">remove</td><td>If <code>'y'</code>, remove the original data or text column. (default = <code>'n'</code>)</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>An <a class="el" href="gentle.html#apop_data">apop_data</a> set whose <code>matrix</code> element is the one-zero matrix of dummies. If you used <code>.append</code>, then this is the main matrix. Also, I add a page named <code>"\&lt;categories for your_var\&gt;"</code> giving a reference table of names and column numbers (where <code>your_var</code> is the appropriate column heading).</dd></dl>
<ul>
<li>This function uses the <a class="el" href="designated.html">Designated initializers</a> syntax for inputs. </li>
</ul>

</div>
</div>
<a class="anchor" id="a27405bd5fdf48d93c8918ca4c07ee260"></a><!-- doxytag: member="apop_regression.c::apop_data_to_factors" ref="a27405bd5fdf48d93c8918ca4c07ee260" args="(apop_data *data, char intype, int incol, int outcol)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct__apop__data.html">apop_data</a>* apop_data_to_factors </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__apop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>intype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>incol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>outcol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Convert a column of text or numbers into a column of numeric factors, which you can use for a multinomial probit/logit, for example.</p>
<p>If you don't run this on your data first, <a class="el" href="group__models.html#ga319b8e3d5025a6fc94829a978273eb8b">apop_probit</a> and <a class="el" href="group__models.html#gaa88a402cf7d02c25c4613a74ace1b0c1">apop_logit</a> default to running it on the vector or (if no vector) zeroth column of the matrix of the input <a class="el" href="gentle.html#apop_data">apop_data</a> set, because those models need a list of the unique values of the dependent variable.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The data set to be modified in place. (No default. If <code>NULL</code>, returns <code>NULL</code> and a warning) </td></tr>
    <tr><td class="paramname">intype</td><td>If <code>'t'</code>, then <code>incol</code> refers to text, otherwise (<code>'d'</code> is a good choice) refers to the vector or matrix. Default = <code>'t'</code>. </td></tr>
    <tr><td class="paramname">incol</td><td>The column in the text that will be converted. -1 is the vector. Default = 0. </td></tr>
    <tr><td class="paramname">outcol</td><td>The column in the data set where the numeric factors will be written (-1 means the vector, which I will allocate for you if it is <code>NULL</code>). Default = 0.</td></tr>
  </table>
  </dd>
</dl>
<p>For example: </p>
<div class="fragment"><pre class="fragment"><a class="code" href="struct__apop__data.html">apop_data</a> *d  = <a class="code" href="group__queries.html#ga1f06db34e05b5afb63112f83ad2317b8">apop_query_to_mixed_data</a>(<span class="stringliteral">&quot;mmt&quot;</span>, <span class="stringliteral">&quot;select 1, year, color from data&quot;</span>);
<a class="code" href="apop__regression_8c.html#a27405bd5fdf48d93c8918ca4c07ee260">apop_data_to_factors</a>(d);
</pre></div><p> Notice that the query pulled a column of ones for the sake of saving room for the factors. It reads column zero of the text, and writes it to column zero of the matrix.</p>
<p>Another example: </p>
<div class="fragment"><pre class="fragment"><a class="code" href="struct__apop__data.html">apop_data</a> *d  = <a class="code" href="group__queries.html#gade862993166c6482f53562fb77721db9">apop_query_to_data</a>(<span class="stringliteral">&quot;mmt&quot;</span>, <span class="stringliteral">&quot;select type, year from data&quot;</span>);
<a class="code" href="apop__regression_8c.html#a27405bd5fdf48d93c8918ca4c07ee260">apop_data_to_factors</a>(d, .intype=<span class="charliteral">&#39;d&#39;</span>, .incol=0, .outcol=0);
</pre></div><p> Here, the <code>type</code> column is converted to sequential integer factors and those factors overwrite the original data. Since a reference table is added as a second page of the <a class="el" href="gentle.html#apop_data">apop_data</a> set, you can recover the original values as needed.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A table of the factors used in the code. This is an <code>apop_data</code> set with only one column of text. Also, I add a page named <code>"&lt;categories for your_var&gt;"</code> giving a reference table of names and column numbers (where <code>your_var</code> is the appropriate column heading).</dd></dl>
<ul>
<li>This function uses the <a class="el" href="designated.html">Designated initializers</a> syntax for inputs. </li>
</ul>

</div>
</div>
<a class="anchor" id="ae165633525c5272ab83794b60076eddc"></a><!-- doxytag: member="apop_regression.c::apop_estimate_parameter_tests" ref="ae165633525c5272ab83794b60076eddc" args="(apop_model *est)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void apop_estimate_parameter_tests </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__apop__model.html">apop_model</a> *&#160;</td>
          <td class="paramname"><em>est</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>For many, it is a knee-jerk reaction to a parameter estimation to test whether each individual parameter differs from zero. This function does that.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">est</td><td>The <a class="el" href="group__models.html#ga0a3be4075a89f7119be95a4718e01ade">apop_estimate</a>, which includes pre-calculated parameter estimates, var-covar matrix, and the original data set.</td></tr>
  </table>
  </dd>
</dl>
<p>Returns nothing. At the end of the routine, <code>est-&gt;info-&gt;more</code> includes a set of t-test values: p value, confidence (=1-pval), t statistic, standard deviation, one-tailed Pval, one-tailed confidence. </p>

</div>
</div>
<a class="anchor" id="a3771d1cda273eade98c4fa6ddb7d8c3d"></a><!-- doxytag: member="apop_regression.c::apop_text_to_factors" ref="a3771d1cda273eade98c4fa6ddb7d8c3d" args="(apop_data *d, size_t textcol, int datacol)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct__apop__data.html">apop_data</a>* apop_text_to_factors </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__apop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>textcol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>datacol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Deprecated. Use <a class="el" href="stats_8h.html#a27405bd5fdf48d93c8918ca4c07ee260">apop_data_to_factors</a>.</p>
<p>Convert a column of text in the text portion of an <code>apop_data</code> set into a column of numeric elements, which you can use for a multinomial probit, for example.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>The data set to be modified in place. </td></tr>
    <tr><td class="paramname">datacol</td><td>The column in the data set where the numeric factors will be written (-1 means the vector, which I will allocate for you if it is <code>NULL</code>) </td></tr>
    <tr><td class="paramname">textcol</td><td>The column in the text that will be converted.</td></tr>
  </table>
  </dd>
</dl>
<p>For example: </p>
<div class="fragment"><pre class="fragment"><a class="code" href="struct__apop__data.html">apop_data</a> *d  = <a class="code" href="group__queries.html#ga1f06db34e05b5afb63112f83ad2317b8">apop_query_to_mixed_data</a>(<span class="stringliteral">&quot;mmt&quot;</span>, <span class="stringliteral">&quot;select 1, year, color from data&quot;</span>);
<a class="code" href="apop__regression_8c.html#a3771d1cda273eade98c4fa6ddb7d8c3d">apop_text_to_factors</a>(d, 0, 0);
</pre></div><p> Notice that the query pulled a column of ones for the sake of saving room for the factors.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A table of the factors used in the code. This is an <code>apop_data</code> set with only one column of text. Also, the <code>more</code> element is a reference table of names and column numbers. </dd></dl>

</div>
</div>
<a class="anchor" id="a77c937ea4764d3da2ed9968273fa4544"></a><!-- doxytag: member="apop_regression.c::apop_text_unique_elements" ref="a77c937ea4764d3da2ed9968273fa4544" args="(const apop_data *d, size_t col)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct__apop__data.html">apop_data</a>* apop_text_unique_elements </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct__apop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>col</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Give me a column of text, and I'll give you a sorted list of the unique elements. This is basically running "select distinct * from datacolumn", but without the aid of the database.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>An <a class="el" href="gentle.html#apop_data">apop_data</a> set with a text component </td></tr>
    <tr><td class="paramname">col</td><td>The text column you want me to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>An <a class="el" href="gentle.html#apop_data">apop_data</a> set with a single sorted column of text, where each unique text input appears once. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>{<a class="el" href="stats_8h.html#a6d68bacc086420a382366f9118cf5bc7">apop_vector_unique_elements</a>} </dd></dl>

</div>
</div>
<a class="anchor" id="a6d68bacc086420a382366f9118cf5bc7"></a><!-- doxytag: member="apop_regression.c::apop_vector_unique_elements" ref="a6d68bacc086420a382366f9118cf5bc7" args="(const gsl_vector *v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gsl_vector* apop_vector_unique_elements </td>
          <td>(</td>
          <td class="paramtype">const gsl_vector *&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Give me a vector of numbers, and I'll give you a sorted list of the unique elements. This is basically running "select distinct * from datacolumn", but without the aid of the database.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>a vector of items</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a sorted vector of the distinct elements that appear in the input. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>{<a class="el" href="stats_8h.html#a77c937ea4764d3da2ed9968273fa4544">apop_text_unique_elements</a>} </dd></dl>

</div>
</div>
</div>
<p><p>
<div class="tiny">Autogenerated by doxygen on Tue Mar 13 2012.</div></body></html>
