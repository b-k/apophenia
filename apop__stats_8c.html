<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html> <head>
     <title>Apophenia: a library for scientific computing</title>

<!-- Google is watching. -->
<script src="http://www.google-analytics.com/urchin.js" type="text/javascript">
</script>
<script type="text/javascript">
_uacct = "UA-134313-2";
urchinTracker();
</script>


     <link rel="stylesheet" href="typical.css" type="text/css" >
     <script  type="text/javascript" language="JavaScript" src="tree.js"></script>
</head><body>
     <center><table cellpadding=10pt>
     <tr> <td><img width=140px src=flake.gif alt="Patterns in static"></td> 
    <td><table>
     	<tr> <td><center><h2><a href="http://apophenia.info">Apophenia</a></h2></center></td></tr>
<tr><td><div class="qindex"><a class="qindex" href="index.html">&nbsp;Intro</a> | <a class="qindex" href="outline.html">Outline</a> | <a class="qindex" href="globals.html">Index</a> <!--| <a class="qindex" href="files.html">File&nbsp;List&nbsp;</a> -->  </div></td></tr></table>
	</td></tr></table></center>

    <div> <!--Doxygen generates an extra </div>.-->
<!-- Generated by Doxygen 1.7.6.1 -->
</div>
<div class="header">
  <div class="summary">
<a href="#define-members">Defines</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">apop_stats.c File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="define-members"></a>
Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><b>Check_vw</b></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">long double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__convenience__fns.html#gaf6182181dd424bc4de98b4bfbd349b4e">apop_vector_sum</a> (const gsl_vector *in)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vector__moments.html#gac9d269f1dc62b038c0da72085cac1c28">apop_vector_skew</a> (const gsl_vector *in)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vector__moments.html#gaf5740c698174b1a265d182f4af1c0252">apop_vector_kurtosis</a> (const gsl_vector *in)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vector__moments.html#gafb284d668d567de4810620962043f827">apop_vector_skew_pop</a> (gsl_vector const *v, gsl_vector const *weights)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vector__moments.html#gaabe3183e8a6a496f3fd6ab316687381e">apop_vector_kurtosis_pop</a> (gsl_vector const *v, gsl_vector const *weights)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vector__moments.html#ga2446385225c68c62ade26402c63600a4">apop_vector_var_m</a> (const gsl_vector *in, const double mean)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vector__moments.html#gae1154897fec0c56bc0161ed24c48759c">apop_vector_correlation</a> (const gsl_vector *ina, const gsl_vector *inb)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__convenience__fns.html#ga44a77f5e6867c627fd313f3f6e252ff8">apop_vector_distance</a> (const gsl_vector *ina, const gsl_vector *inb, const char metric, const double norm)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="apop__stats_8c.html#a194ad92b1bc632ba1d13d9958c7b5b4d">apop_vector_normalize</a> (gsl_vector *in, gsl_vector **out, const char normalization_type)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="apop__stats_8c.html#af6290c453c3012c1d0a6987688ebe795">apop_matrix_normalize</a> (gsl_matrix *data, const char row_or_col, const char normalization)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">long double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__convenience__fns.html#ga369c774aac917e56d8e32f9c66d9c2a0">apop_matrix_sum</a> (const gsl_matrix *m)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__convenience__fns.html#ga040b9e9fea1abe105de86081bf396d40">apop_matrix_mean</a> (const gsl_matrix *data)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__convenience__fns.html#gaf794cc2491ef147e0c67eb05feed7a87">apop_matrix_mean_and_var</a> (const gsl_matrix *data, double *mean, double *var)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__output.html#gaca60728fc3b691acfcadebf3a8535532">apop_data_summarize</a> (<a class="el" href="structapop__data.html">apop_data</a> *indata)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="apop__stats_8c.html#ab20e5ad95df0f24a1ea06294695031a8">apop_vector_mean</a> (gsl_vector const *v, gsl_vector const *weights)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="apop__stats_8c.html#adcc397ab90933d79b3062206301a0aa0">apop_vector_var</a> (gsl_vector const *v, gsl_vector const *weights)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="apop__stats_8c.html#aeb71737b8996eb15f7698246676a78dd">apop_vector_cov</a> (const gsl_vector *v1, const gsl_vector *v2, const gsl_vector *weights)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="apop__stats_8c.html#aeae37a5bf11cddee59e272b083a4efc7">apop_data_covariance</a> (const <a class="el" href="structapop__data.html">apop_data</a> *in)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="apop__stats_8c.html#afa3ab967f57f8ad3cfb99a4a82cfae02">apop_data_correlation</a> (const <a class="el" href="structapop__data.html">apop_data</a> *in)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">long double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="apop__stats_8c.html#abd5c77978dc6972e4ba52f77fb8dfef0">apop_vector_entropy</a> (gsl_vector *in)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a072c03ad76c517df50956da2d84e20b6"></a><!-- doxytag: member="apop_stats.c::get_ll" ref="a072c03ad76c517df50956da2d84e20b6" args="(apop_data *d, void *m)" -->
double&#160;</td><td class="memItemRight" valign="bottom"><b>get_ll</b> (<a class="el" href="structapop__data.html">apop_data</a> *d, void *m)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">long double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="apop__stats_8c.html#a4d8310d52c11bcb7a8d32656a21c44cd">apop_model_entropy</a> (<a class="el" href="structapop__model.html">apop_model</a> *in, int draws)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac7db2868648bb2adc5df747c0947f0af"></a><!-- doxytag: member="apop_stats.c::a_div" ref="ac7db2868648bb2adc5df747c0947f0af" args="(gsl_vector *in)" -->
double&#160;</td><td class="memItemRight" valign="bottom"><b>a_div</b> (gsl_vector *in)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="apop__stats_8c.html#a97dac563372dff4430c21378a8fcee07">apop_kl_divergence</a> (<a class="el" href="structapop__model.html">apop_model</a> *from, <a class="el" href="structapop__model.html">apop_model</a> *to, int draw_ct, gsl_rng *rng)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">long double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="apop__stats_8c.html#a2c76ad8792959b6605402a1d71a1b6c9">apop_multivariate_gamma</a> (double a, int p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">long double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="apop__stats_8c.html#a180b231acc3c64d07664ed2b1a8ad0e1">apop_multivariate_lngamma</a> (double a, int p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="apop__stats_8c.html#afc7707d44884aa63c298510a0662956a">apop_matrix_is_positive_semidefinite</a> (gsl_matrix *m, char semi)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afc6ff60871ebd99031ac8355e427ab60"></a><!-- doxytag: member="apop_stats.c::vfabs" ref="afc6ff60871ebd99031ac8355e427ab60" args="(double *x)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><b>vfabs</b> (double *x)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="apop__stats_8c.html#af1fc93322ffcb4e20cfc0b9af9e2aea0">apop_matrix_to_positive_semidefinite</a> (gsl_matrix *m)</td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Basic moments and some distributions. </p>
</div><hr/><h2>Define Documentation</h2>
<a class="anchor" id="a1b5ecd37c08b805f35f7129109b16e11"></a><!-- doxytag: member="apop_stats.c::Check_vw" ref="a1b5ecd37c08b805f35f7129109b16e11" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Check_vw</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment"><a class="code" href="apop_8h.html#abd17601e642688d033f62d346f3dace6">Apop_stopif</a>(!v, <span class="keywordflow">return</span> GSL_NAN, 0, <span class="stringliteral">&quot;data vector is NULL. Returning NaN.\n&quot;</span>);            \
    Apop_stopif(!v-&gt;size, <span class="keywordflow">return</span> GSL_NAN, 0, <span class="stringliteral">&quot;data vector has size 0. Returning NaN.\n&quot;</span>);   \
    Apop_stopif(weights &amp;&amp; weights-&gt;size != v-&gt;size, <span class="keywordflow">return</span> GSL_NAN, 0, <span class="stringliteral">&quot;data vector has size %zu; weighting vector has size %zu. Returning NaN.\n&quot;</span>, v-&gt;size, weights-&gt;size);
</pre></div>
</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="afa3ab967f57f8ad3cfb99a4a82cfae02"></a><!-- doxytag: member="apop_stats.c::apop_data_correlation" ref="afa3ab967f57f8ad3cfb99a4a82cfae02" args="(const apop_data *in)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__data.html">apop_data</a>* <a class="el" href="apop__stats_8c.html#afa3ab967f57f8ad3cfb99a4a82cfae02">apop_data_correlation</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the matrix of correlation coefficients <img class="formulaInl" alt="$(\sigma^2_{xy}/(\sigma_x\sigma_y))$" src="form_76.png"/> relating each column with each other.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>A data matrix: rows are observations, columns are variables. If you give me a weights vector, I'll use it.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns the variance/covariance matrix relating each column with each other. This function allocates the matrix for you. </dd></dl>
<dl class="exception"><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">out-&gt;error='a'</td><td>Allocation error. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aeae37a5bf11cddee59e272b083a4efc7"></a><!-- doxytag: member="apop_stats.c::apop_data_covariance" ref="aeae37a5bf11cddee59e272b083a4efc7" args="(const apop_data *in)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__data.html">apop_data</a>* <a class="el" href="apop__stats_8c.html#aeae37a5bf11cddee59e272b083a4efc7">apop_data_covariance</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the sample variance/covariance matrix relating each column of the matrix to each other column.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>An <a class="el" href="gentle.html#apop_data">apop_data</a> set. If the weights vector is set, I'll take it into account.</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>This is the sample covariance---dividing by <img class="formulaInl" alt="$n-1$" src="form_57.png"/>, not <img class="formulaInl" alt="$n$" src="form_10.png"/>.</li>
</ul>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns a <a class="el" href="gentle.html#apop_data">apop_data</a> set the variance/covariance matrix relating each column with each other. </dd></dl>
<dl class="exception"><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">out-&gt;error='a'</td><td>Allocation error. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a97dac563372dff4430c21378a8fcee07"></a><!-- doxytag: member="apop_stats.c::apop_kl_divergence" ref="a97dac563372dff4430c21378a8fcee07" args="(apop_model *from, apop_model *to, int draw_ct, gsl_rng *rng)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="apop__stats_8c.html#a97dac563372dff4430c21378a8fcee07">apop_kl_divergence</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__model.html">apop_model</a> *&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structapop__model.html">apop_model</a> *&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>draw_ct</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsl_rng *&#160;</td>
          <td class="paramname"><em>rng</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Kullback-Leibler divergence.</p>
<p>This measure of the divergence of one distribution from another has the form <img class="formulaInl" alt="$ D(p,q) = \sum_i \ln(p_i/q_i) p_i $" src="form_81.png"/>. Notice that it is not a distance, because there is an asymmetry between <img class="formulaInl" alt="$p$" src="form_19.png"/> and <img class="formulaInl" alt="$q$" src="form_82.png"/>, so one can expect that <img class="formulaInl" alt="$D(p, q) \neq D(q, p)$" src="form_83.png"/>.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>the <img class="formulaInl" alt="$p$" src="form_19.png"/> in the above formula. (No default; must not be <code>NULL</code>) </td></tr>
    <tr><td class="paramname">to</td><td>the <img class="formulaInl" alt="$q$" src="form_82.png"/> in the above formula. (No default; must not be <code>NULL</code>) </td></tr>
    <tr><td class="paramname">draw_ct</td><td>If I do the calculation via random draws, how many? (Default = 1e5) </td></tr>
    <tr><td class="paramname">rng</td><td>A <code>gsl_rng</code>. If <code>NULL</code> or number of threads is greater than 1, I'll take care of the RNG; see <a class="el" href="apop_8h.html#a1e829ce2396bf05ab10460bcc37aeeab">apop_rng_get_thread</a>. (Default = <code>NULL</code>)</td></tr>
  </table>
  </dd>
</dl>
<p>This function can take empirical histogram-type models (<a class="el" href="group__models.html#gaca8f3323c57e0223a9f3c0f991c9760e">apop_pmf</a>) or continuous models like <a class="el" href="group__models.html#gaf7d01cc4076c9319036a0cce882dac62">apop_loess</a> or <a class="el" href="group__models.html#ga297c2dc8dbdf4ae93fc7e10860400466">apop_normal</a>.</p>
<p>If there is a PMF (I'll try <code>from</code> first, under the presumption that you are measuring the divergence of data from an observed data distribution), then I'll step through it for the points in the summation.</p>
<ul>
<li>If you have two empirical distributions, that they must be synced: if <img class="formulaInl" alt="$p_i>0$" src="form_84.png"/> but <img class="formulaInl" alt="$q_i=0$" src="form_85.png"/>, then the function returns <code>GSL_NEGINF</code>. If <code>apop_opts.verbose &gt;=1</code> I print a message as well.</li>
</ul>
<p>If neither distribution is a PMF, then I'll take <code>draw_ct</code> random draws from <code>to</code> and evaluate at those points.</p>
<ul>
<li>Set <code>apop_opts.verbose = 3</code> for observation-by-observation info.</li>
</ul>
<ul>
<li>This function uses the <a class="el" href="designated.html">Designated initializers</a> syntax for inputs. </li>
</ul>

</div>
</div>
<a class="anchor" id="afc7707d44884aa63c298510a0662956a"></a><!-- doxytag: member="apop_stats.c::apop_matrix_is_positive_semidefinite" ref="afc7707d44884aa63c298510a0662956a" args="(gsl_matrix *m, char semi)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="apop__stats_8c.html#afc7707d44884aa63c298510a0662956a">apop_matrix_is_positive_semidefinite</a> </td>
          <td>(</td>
          <td class="paramtype">gsl_matrix *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>semi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Test whether the input matrix is positive semidefinite.</p>
<p>A covariance matrix will always be PSD, so this function can tell you whether your matrix is a valid covariance matrix.</p>
<p>Consider the 1x1 matrix in the upper left of the input, then the 2x2 matrix in the upper left, on up to the full matrix. If the matrix is PSD, then each of these has a positive determinant. This function thus calculates <img class="formulaInl" alt="$N$" src="form_6.png"/> determinants for an <img class="formulaInl" alt="$N$" src="form_6.png"/>x <img class="formulaInl" alt="$N$" src="form_6.png"/> matrix.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The matrix to test. If <code>NULL</code>, I will return zero---not PSD. </td></tr>
    <tr><td class="paramname">semi</td><td>If anything but 's', check for positive definite, not semidefinite. (default 's')</td></tr>
  </table>
  </dd>
</dl>
<p>See also <a class="el" href="apop__stats_8c.html#af1fc93322ffcb4e20cfc0b9af9e2aea0">apop_matrix_to_positive_semidefinite</a>, which will change the input to something PSD.</p>
<ul>
<li>This function uses the <a class="el" href="designated.html">Designated initializers</a> syntax for inputs. </li>
</ul>

</div>
</div>
<a class="anchor" id="af6290c453c3012c1d0a6987688ebe795"></a><!-- doxytag: member="apop_stats.c::apop_matrix_normalize" ref="af6290c453c3012c1d0a6987688ebe795" args="(gsl_matrix *data, const char row_or_col, const char normalization)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="apop__stats_8c.html#af6290c453c3012c1d0a6987688ebe795">apop_matrix_normalize</a> </td>
          <td>(</td>
          <td class="paramtype">gsl_matrix *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>row_or_col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>normalization</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Normalize each row or column in the given matrix, one by one.</p>
<p>Basically just a convenience fn to iterate through the columns or rows and run <a class="el" href="apop__stats_8c.html#a194ad92b1bc632ba1d13d9958c7b5b4d">apop_vector_normalize</a> for you.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The data set to normalize. </td></tr>
    <tr><td class="paramname">row_or_col</td><td>Either 'r' or 'c'. </td></tr>
    <tr><td class="paramname">normalization</td><td>see <a class="el" href="apop__stats_8c.html#a194ad92b1bc632ba1d13d9958c7b5b4d">apop_vector_normalize</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af1fc93322ffcb4e20cfc0b9af9e2aea0"></a><!-- doxytag: member="apop_stats.c::apop_matrix_to_positive_semidefinite" ref="af1fc93322ffcb4e20cfc0b9af9e2aea0" args="(gsl_matrix *m)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="apop__stats_8c.html#af1fc93322ffcb4e20cfc0b9af9e2aea0">apop_matrix_to_positive_semidefinite</a> </td>
          <td>(</td>
          <td class="paramtype">gsl_matrix *&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>First, this function passes tests, but is under development.</p>
<p>It takes in a matrix and converts it to the `closest' positive semidefinite matrix.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>On input, any matrix; on output, a positive semidefinite matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the distance between the original and new matrices.</dd></dl>
<ul>
<li>See also the test function <a class="el" href="apop__stats_8c.html#afc7707d44884aa63c298510a0662956a">apop_matrix_is_positive_semidefinite</a>. </li>
<li>This function can be used as (the core of) a model constraint.</li>
</ul>
<p>Adapted from the R Matrix package's nearPD, which is Copyright (2007) Jens Oehlschl√§gel [and is GPL]. </p>

</div>
</div>
<a class="anchor" id="a4d8310d52c11bcb7a8d32656a21c44cd"></a><!-- doxytag: member="apop_stats.c::apop_model_entropy" ref="a4d8310d52c11bcb7a8d32656a21c44cd" args="(apop_model *in, int draws)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long double <a class="el" href="apop__stats_8c.html#a4d8310d52c11bcb7a8d32656a21c44cd">apop_model_entropy</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__model.html">apop_model</a> *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>draws</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Calculate the entropy of a model: <img class="formulaInl" alt="$\int -\ln(p(x))p(x)dx$" src="form_79.png"/>, which is the expected value of <img class="formulaInl" alt="$-\ln(p(x))$" src="form_80.png"/>.</p>
<p>The default method is to make draws using the input model's <code>draw</code> method (or the MCMC or ARMS default methods), then evaluate the log likelihood at that point using the models <code>log_likelihood</code> method.</p>
<p>There are a number of routines for specific models, inlcuding the <a class="el" href="group__models.html#ga297c2dc8dbdf4ae93fc7e10860400466">apop_normal</a> and <a class="el" href="group__models.html#gaca8f3323c57e0223a9f3c0f991c9760e">apop_pmf</a> models.</p>
<ul>
<li>If you have a data set, see <a class="el" href="apop__stats_8c.html#abd5c77978dc6972e4ba52f77fb8dfef0">apop_vector_entropy</a>.</li>
</ul>
<ul>
<li>The entropy is calculated using natural logs. If you prefer base-2 logs, just divide by <img class="formulaInl" alt="$\ln(2)$" src="form_78.png"/>: <code>apop_model_entropy(my_model)/log(2)</code>.</li>
</ul>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>A parameterized <a class="el" href="structapop__model.html">apop_model</a>. That is, you have already used <a class="el" href="group__models.html#ga2c0598e5aca68949939a189bd4ce24ca">apop_estimate</a> or <a class="el" href="group__models.html#ga36cae46a2950eb6cfb65794cdd5dac7e">apop_model_set_parameters</a> to estimate/set the model parameters. </td></tr>
    <tr><td class="paramname">draws</td><td>If using the default method of making random draws, how many random draws to make (default=1,000) </td></tr>
    <tr><td class="paramname">r</td><td>If using the default method of making random draws, the RNG to use. (default: use <a class="el" href="apop_8h.html#a1e829ce2396bf05ab10460bcc37aeeab">apop_rng_get_thread</a>)</td></tr>
  </table>
  </dd>
</dl>
<p>Sample code: </p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &lt;<a class="code" href="apop_8h.html">apop.h</a>&gt;</span>
<span class="preprocessor">#define Diff(left, right, eps) Apop_stopif(fabs((left)-(right))&gt;(eps), abort(), 0, &quot;%g is too different from %g (abitrary limit=%g).&quot;, (double)(left), (double)(right), eps)</span>
<span class="preprocessor"></span>

<span class="comment">/* The entropy function, like some other functions (including apop_update) has a lookup</span>
<span class="comment"> table for known models like the Normal distribution. If the input model has</span>
<span class="comment"> \c log_likelihood, \c p, and \c draw functions that are the ones found in \ref</span>
<span class="comment"> apop_nomrmal, then use a known calculation to report entropy; else report based on</span>
<span class="comment"> random draws from the model.</span>
<span class="comment"></span>
<span class="comment">If we make a copy of the \ref apop_normal model and replace the log likelihood with</span>
<span class="comment">a new function that produces identical values, the lookup table will not find the</span>
<span class="comment">modified model, and the calculation via random draws will be done. Of course, the</span>
<span class="comment">final entropy as calculated using both methods should differ only by a small amount.</span>
<span class="comment">*/</span>
<span class="keywordtype">long</span> <span class="keywordtype">double</span> mask(<a class="code" href="structapop__data.html">apop_data</a> *d, <a class="code" href="structapop__model.html">apop_model</a> *m){
    <span class="keywordflow">return</span> <a class="code" href="group__models.html#ga297c2dc8dbdf4ae93fc7e10860400466">apop_normal</a>-&gt;log_likelihood(d, m);
}

<span class="keywordtype">int</span> main(){
    <span class="keywordflow">for</span> (<span class="keywordtype">double</span> i=0.1; i&lt; 10; i+=.2){
        <a class="code" href="structapop__model.html">apop_model</a> *n = <a class="code" href="group__models.html#ga36cae46a2950eb6cfb65794cdd5dac7e">apop_model_set_parameters</a>(<a class="code" href="group__models.html#ga297c2dc8dbdf4ae93fc7e10860400466">apop_normal</a>, 8, i);
        <span class="keywordtype">long</span> <span class="keywordtype">double</span> v= <a class="code" href="apop_8h.html#a4d8310d52c11bcb7a8d32656a21c44cd">apop_model_entropy</a>(n);
        n-&gt;<a class="code" href="structapop__model.html#a6a098bc488ce578e0f9009f68a670cd3">log_likelihood</a> = mask;
        <span class="keywordtype">long</span> <span class="keywordtype">double</span> w= <a class="code" href="apop_8h.html#a4d8310d52c11bcb7a8d32656a21c44cd">apop_model_entropy</a>(n, 50000);
        Diff(v, w, 5e-2);
    }
}
</pre></div> 
</div>
</div>
<a class="anchor" id="a2c76ad8792959b6605402a1d71a1b6c9"></a><!-- doxytag: member="apop_stats.c::apop_multivariate_gamma" ref="a2c76ad8792959b6605402a1d71a1b6c9" args="(double a, int p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long double <a class="el" href="apop__stats_8c.html#a2c76ad8792959b6605402a1d71a1b6c9">apop_multivariate_gamma</a> </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The multivariate generalization of the Gamma distribution. </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \Gamma_p(a)= \pi^{p(p-1)/4}\prod_{j=1}^p \Gamma\left[ a+(1-j)/2\right]. \]" src="form_88.png"/>
</p>
<p>Because <img class="formulaInl" alt="$\Gamma(x)$" src="form_89.png"/> is undefined for <img class="formulaInl" alt="$x\in\{0, -1, -2, ...\}$" src="form_90.png"/>, this function returns <code>NAN</code> when <img class="formulaInl" alt="$a+(1-j)/2$" src="form_91.png"/> takes on one of those values.</p>
<p>See also <a class="el" href="apop__stats_8c.html#a180b231acc3c64d07664ed2b1a8ad0e1">apop_multivariate_lngamma</a>, which is more numerically stable in most cases. </p>

</div>
</div>
<a class="anchor" id="a180b231acc3c64d07664ed2b1a8ad0e1"></a><!-- doxytag: member="apop_stats.c::apop_multivariate_lngamma" ref="a180b231acc3c64d07664ed2b1a8ad0e1" args="(double a, int p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long double <a class="el" href="apop__stats_8c.html#a180b231acc3c64d07664ed2b1a8ad0e1">apop_multivariate_lngamma</a> </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The log of the multivariate generalization of the Gamma; see also <a class="el" href="apop__stats_8c.html#a2c76ad8792959b6605402a1d71a1b6c9">apop_multivariate_gamma</a>. </p>

</div>
</div>
<a class="anchor" id="aeb71737b8996eb15f7698246676a78dd"></a><!-- doxytag: member="apop_stats.c::apop_vector_cov" ref="aeb71737b8996eb15f7698246676a78dd" args="(const gsl_vector *v1, const gsl_vector *v2, const gsl_vector *weights)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="apop__stats_8c.html#aeb71737b8996eb15f7698246676a78dd">apop_vector_cov</a> </td>
          <td>(</td>
          <td class="paramtype">const gsl_vector *&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const gsl_vector *&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const gsl_vector *&#160;</td>
          <td class="paramname"><em>weights</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Find the sample covariance of a pair of vectors, with an optional weighting. This only makes sense if the weightings are identical, so the function takes only one weighting vector for both.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">v1,v2</td><td>The data vectors </td></tr>
    <tr><td class="paramname">weights</td><td>The weight vector. Default: equal weights for all elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The sample covariance <ul>
<li>This function uses the <a class="el" href="designated.html">Designated initializers</a> syntax for inputs. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="abd5c77978dc6972e4ba52f77fb8dfef0"></a><!-- doxytag: member="apop_stats.c::apop_vector_entropy" ref="abd5c77978dc6972e4ba52f77fb8dfef0" args="(gsl_vector *in)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long double <a class="el" href="apop__stats_8c.html#abd5c77978dc6972e4ba52f77fb8dfef0">apop_vector_entropy</a> </td>
          <td>(</td>
          <td class="paramtype">gsl_vector *&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Given a vector representing a probability distribution of observations, calculate the entropy, <img class="formulaInl" alt="$\sum_i -\ln(v_i)v_i$" src="form_77.png"/>.</p>
<ul>
<li>The input vector need not be normalized to sum to one. You may input a vector giving frequencies.</li>
</ul>
<ul>
<li>The entropy of a data set depends only on the frequency with which elements are observed, not the value of the elements themselves. The <a class="el" href="apop_8h.html#acc90578a8086a2e6f7b1575300260f08">apop_data_pmf_compress</a> function will reduce an input <a class="el" href="gentle.html#apop_data">apop_data</a> set to one weighted line per observation, and the weights would determine the entropy:</li>
</ul>
<div class="fragment"><pre class="fragment"><a class="code" href="structapop__data.html">apop_data</a> *data = <a class="code" href="group__conversions.html#ga630de5d4fcbe9ef13373029f5d813a97">apop_text_to_data</a>(<span class="stringliteral">&quot;indata&quot;</span>);
<a class="code" href="apop_8h.html#acc90578a8086a2e6f7b1575300260f08">apop_data_pmf_compress</a>(data);
data_entropy = <a class="code" href="apop_8h.html#abd5c77978dc6972e4ba52f77fb8dfef0">apop_vector_entropy</a>(d-&gt;weights);
</pre></div><ul>
<li>The entropy is calculated using natural logs. To convert to base 2, divide by <img class="formulaInl" alt="$\ln(2)$" src="form_78.png"/>; see the example.</li>
</ul>
<ul>
<li>The entropy of an empty data set (<code>NULL</code> or a total weight of zero) is zero. Print a warning when given <code>NULL</code> input and <code>apop_opts.verbose &gt;=1</code>.</li>
</ul>
<ul>
<li>If the input vector has negative elements, return <code>NaN</code>; print a warning when <code>apop_opts.verbose &gt;= 0</code>.</li>
</ul>
<p>Sample code: </p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &lt;<a class="code" href="apop_8h.html">apop.h</a>&gt;</span>

<span class="preprocessor">#define Diff(left, right, eps) Apop_stopif(fabs((left)-(right))&gt;(eps), abort(), 0, &quot;%g is too different from %g (abitrary limit=%g).&quot;, (double)(left), (double)(right), eps)</span>
<span class="preprocessor"></span>
<span class="keywordtype">long</span> <span class="keywordtype">double</span> entropy_base_2(gsl_vector *x) {
    <span class="keywordflow">return</span> <a class="code" href="apop_8h.html#abd5c77978dc6972e4ba52f77fb8dfef0">apop_vector_entropy</a>(x)/log(2);
}

<a class="code" href="structapop__data.html">apop_data</a> *flip_a_coin(<span class="keywordtype">int</span> how_many){
    <span class="keywordflow">return</span> <a class="code" href="apop_8h.html#a4e204cdc7429bef3ca2efb83453fe77a">apop_model_draws</a>(<a class="code" href="group__models.html#ga36cae46a2950eb6cfb65794cdd5dac7e">apop_model_set_parameters</a>(<a class="code" href="group__models.html#gac5437f95ff92d27f389a7b3e27812330">apop_bernoulli</a>, .5), how_many);
}

<span class="keywordtype">int</span> main(){
    <span class="comment">//zero data =&gt; entropy zero</span>
    gsl_vector *v = gsl_vector_calloc(1);
    assert(<a class="code" href="apop_8h.html#abd5c77978dc6972e4ba52f77fb8dfef0">apop_vector_entropy</a>(v) == 0);

    <span class="comment">//negative data =&gt; NaN</span>
    gsl_vector_set(v, 0, -1);
    <span class="keywordtype">int</span> v1 = <a class="code" href="apop_8h.html#a7975faa07196cf463ec261ff0ddc3ccc">apop_opts</a>.<a class="code" href="structapop__opts__type.html#aa76e9237ed45c77bc883b428c3217a66">verbose</a>;
    <a class="code" href="apop_8h.html#a7975faa07196cf463ec261ff0ddc3ccc">apop_opts</a>.<a class="code" href="structapop__opts__type.html#aa76e9237ed45c77bc883b428c3217a66">verbose</a> = -1;
    assert(isnan(<a class="code" href="apop_8h.html#abd5c77978dc6972e4ba52f77fb8dfef0">apop_vector_entropy</a>(v)));
    <a class="code" href="apop_8h.html#a7975faa07196cf463ec261ff0ddc3ccc">apop_opts</a>.<a class="code" href="structapop__opts__type.html#aa76e9237ed45c77bc883b428c3217a66">verbose</a> = v1;

    <span class="comment">//N equiprobable bins =&gt; entropy = log(N)</span>
    v = <a class="code" href="apop_8h.html#af4658a3ecc0acfd17f610bc162fa5556">apop_vector_realloc</a>(v, 100);
    gsl_vector_set_all(v, 1./100);
    Diff(log(100), <a class="code" href="apop_8h.html#abd5c77978dc6972e4ba52f77fb8dfef0">apop_vector_entropy</a>(v), 1e-5);

    <span class="comment">//flip two coins.</span>
    <a class="code" href="structapop__data.html">apop_data</a> *coin_flips = flip_a_coin(10000);
    <a class="code" href="structapop__data.html">apop_data</a> *c2         = flip_a_coin(10000);
    <a class="code" href="apop_8h.html#a0f2ffb5c5ba2bb240e930be08fc4fd56">apop_data_stack</a>(c2, coin_flips, <span class="charliteral">&#39;c&#39;</span>, .inplace=<span class="charliteral">&#39;y&#39;</span>);

    <span class="comment">//entropy of one coin flip in base2 == 1</span>
    <a class="code" href="apop_8h.html#acc90578a8086a2e6f7b1575300260f08">apop_data_pmf_compress</a>(coin_flips);
    Diff(entropy_base_2(coin_flips-&gt;weights), 1, 1e-3);

    <span class="comment">//entropy of two coin flips in base2 == 2</span>
    <a class="code" href="apop_8h.html#acc90578a8086a2e6f7b1575300260f08">apop_data_pmf_compress</a>(c2);
    Diff(entropy_base_2(c2-&gt;weights), 2, 1e-3);

    <a class="code" href="apop_8h.html#a459acfde11f2c39f5c32cff377f85b9e">apop_data_free</a>(coin_flips);
    <a class="code" href="apop_8h.html#a459acfde11f2c39f5c32cff377f85b9e">apop_data_free</a>(c2);
    gsl_vector_free(v);
}

<span class="comment">/*</span>
<span class="comment">export LDLIBS=&quot;`pkg-config --libs apophenia`&quot;</span>
<span class="comment">export CFLAGS=&quot;-g -Wall `pkg-config --cflags apophenia` -O3 -std=gnu11&quot;</span>
<span class="comment">*/</span>
</pre></div> 
</div>
</div>
<a class="anchor" id="ab20e5ad95df0f24a1ea06294695031a8"></a><!-- doxytag: member="apop_stats.c::apop_vector_mean" ref="ab20e5ad95df0f24a1ea06294695031a8" args="(gsl_vector const *v, gsl_vector const *weights)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="apop__stats_8c.html#ab20e5ad95df0f24a1ea06294695031a8">apop_vector_mean</a> </td>
          <td>(</td>
          <td class="paramtype">gsl_vector const *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsl_vector const *&#160;</td>
          <td class="paramname"><em>weights</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Find the mean, weighted or unweighted.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The data vector </td></tr>
    <tr><td class="paramname">weights</td><td>The weight vector. Default: assume equal weights. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The weighted mean <ul>
<li>This function uses the <a class="el" href="designated.html">Designated initializers</a> syntax for inputs. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a194ad92b1bc632ba1d13d9958c7b5b4d"></a><!-- doxytag: member="apop_stats.c::apop_vector_normalize" ref="a194ad92b1bc632ba1d13d9958c7b5b4d" args="(gsl_vector *in, gsl_vector **out, const char normalization_type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="apop__stats_8c.html#a194ad92b1bc632ba1d13d9958c7b5b4d">apop_vector_normalize</a> </td>
          <td>(</td>
          <td class="paramtype">gsl_vector *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsl_vector **&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>normalization_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function will normalize a vector, either such that it has mean zero and variance one, or ranges between zero and one, or sums to one.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>A gsl_vector which you have already allocated and filled. <code>NULL</code> input gives <code>NULL</code> output. (No default)</td></tr>
    <tr><td class="paramname">out</td><td>If normalizing in place, <code>NULL</code>. If not, the address of a <code>gsl_vector</code>. Do not allocate. (default = <code>NULL</code>.)</td></tr>
    <tr><td class="paramname">normalization_type</td><td>'p': normalized vector will sum to one. E.g., start with a set of observations in bins, end with the percentage of observations in each bin. (the default)<br/>
 'r': normalized vector will range between zero and one. Replace each X with (X-min) / (max - min).<br/>
 's': normalized vector will have mean zero and variance one. Replace each X with <img class="formulaInl" alt="$(X-\mu) / \sigma$" src="form_71.png"/>, where <img class="formulaInl" alt="$\sigma$" src="form_72.png"/> is the sample standard deviation.<br/>
 'm': normalize to mean zero: Replace each X with <img class="formulaInl" alt="$(X-\mu)$" src="form_73.png"/><br/>
</td></tr>
  </table>
  </dd>
</dl>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &lt;<a class="code" href="apop_8h.html">apop.h</a>&gt;</span>

<span class="keywordtype">int</span> main(<span class="keywordtype">void</span>){
gsl_vector  *in, *out;

in = gsl_vector_calloc(3);
gsl_vector_set(in, 1, 1);
gsl_vector_set(in, 2, 2);

printf(<span class="stringliteral">&quot;The original vector:\n&quot;</span>);
<a class="code" href="group__apop__print.html#ga8eafc3727869f5ec195809ad6686ba7b">apop_vector_show</a>(in);

<a class="code" href="apop_8h.html#a194ad92b1bc632ba1d13d9958c7b5b4d">apop_vector_normalize</a>(in, &amp;out, <span class="charliteral">&#39;s&#39;</span>);
printf(<span class="stringliteral">&quot;Standardized with mean zero and variance one:\n&quot;</span>);
<a class="code" href="group__apop__print.html#ga8eafc3727869f5ec195809ad6686ba7b">apop_vector_show</a>(out);

<a class="code" href="apop_8h.html#a194ad92b1bc632ba1d13d9958c7b5b4d">apop_vector_normalize</a>(in, &amp;out, <span class="charliteral">&#39;r&#39;</span>);
printf(<span class="stringliteral">&quot;Normalized range with max one and min zero:\n&quot;</span>);
<a class="code" href="group__apop__print.html#ga8eafc3727869f5ec195809ad6686ba7b">apop_vector_show</a>(out);

<a class="code" href="apop_8h.html#a194ad92b1bc632ba1d13d9958c7b5b4d">apop_vector_normalize</a>(in, NULL, <span class="charliteral">&#39;p&#39;</span>);
printf(<span class="stringliteral">&quot;Normalized into percentages:\n&quot;</span>);
<a class="code" href="group__apop__print.html#ga8eafc3727869f5ec195809ad6686ba7b">apop_vector_show</a>(in);
}
</pre></div><ul>
<li>This function uses the <a class="el" href="designated.html">Designated initializers</a> syntax for inputs. </li>
</ul>

</div>
</div>
<a class="anchor" id="adcc397ab90933d79b3062206301a0aa0"></a><!-- doxytag: member="apop_stats.c::apop_vector_var" ref="adcc397ab90933d79b3062206301a0aa0" args="(gsl_vector const *v, gsl_vector const *weights)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="apop__stats_8c.html#adcc397ab90933d79b3062206301a0aa0">apop_vector_var</a> </td>
          <td>(</td>
          <td class="paramtype">gsl_vector const *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsl_vector const *&#160;</td>
          <td class="paramname"><em>weights</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Find the sample variance of a vector, weighted or unweighted.</p>
<ul>
<li>This uses (n-1) in the denominator of the sum; i.e., it corrects for the bias introduced by using <img class="formulaInl" alt="$\bar x$" src="form_74.png"/> instead of <img class="formulaInl" alt="$\mu$" src="form_75.png"/>.</li>
</ul>
<ul>
<li>At the moment, there is no var_pop function. Just multiply this by (n-1)/n if you need that.</li>
</ul>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The data vector </td></tr>
    <tr><td class="paramname">weights</td><td>The weight vector. If NULL, assume equal weights. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The weighted sample variance.</dd></dl>
<ul>
<li>Apophenia tries to be smart about reading the weights. If weights sum to one, then the system uses <code>w-&gt;size</code> as the number of elements, and returns the usual sum over <img class="formulaInl" alt="$n-1$" src="form_57.png"/>. If weights &gt; 1, then the system uses the total weights as <img class="formulaInl" alt="$n$" src="form_10.png"/>. Thus, you can use the weights as standard weightings or to represent elements that appear repeatedly.</li>
</ul>
<ul>
<li>This function uses the <a class="el" href="designated.html">Designated initializers</a> syntax for inputs. </li>
</ul>

</div>
</div>
</div><!-- contents -->
<p><p>
<div class="tiny">Autogenerated by doxygen on Mon Apr 20 2015.</div></body></html>
