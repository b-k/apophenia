<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html> <head>
     <title>Apophenia: a library for scientific computing</title>

<!-- Google is watching. -->
<script src="http://www.google-analytics.com/urchin.js" type="text/javascript">
</script>
<script type="text/javascript">
_uacct = "UA-134313-2";
urchinTracker();
</script>


     <link rel="stylesheet" href="typical.css" type="text/css" >
     <script  type="text/javascript" language="JavaScript" src="tree.js"></script>
</head><body>
     <center><table cellpadding=10pt>
     <tr> <td><img width=140px src=flake.gif alt="Patterns in static"></td> 
    <td><table>
     	<tr> <td><center><h2><a href="http://apophenia.info">Apophenia</a></h2></center></td></tr>
<tr><td><div class="qindex"><a class="qindex" href="index.html">&nbsp;Intro</a> | <a class="qindex" href="outline.html">Outline</a> | <a class="qindex" href="globals.html">Index</a> <!--| <a class="qindex" href="files.html">File&nbsp;List&nbsp;</a> -->  </div></td></tr></table>
	</td></tr></table></center>

    <div> <!--Doxygen generates an extra </div>.-->
<!-- Generated by Doxygen 1.7.6.1 -->
</div>
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Singular value decompositions, determinants, et cetera.</div>  </div>
</div><!--header-->
<div class="contents">
<h2><a name="func-members"></a>
Functions</h2>
<ul>
<li>double <a class="el" href="group__linear__algebra.html#ga6984006ab44fa7c9c2e99463f7d4081b">apop_det_and_inv</a> (const gsl_matrix *in, gsl_matrix **out, int calc_det, int calc_inv)
<li>gsl_matrix * <a class="el" href="group__linear__algebra.html#ga185243be2d8a93686c68263cc3318f47">apop_matrix_inverse</a> (const gsl_matrix *in)
<li>double <a class="el" href="group__linear__algebra.html#ga03038130e4ba55228f9e164dba513961">apop_matrix_determinant</a> (const gsl_matrix *in)
<li><a class="el" href="structapop__data.html">apop_data</a> * <a class="el" href="group__linear__algebra.html#gaa1715c468336800a21ca86971323ae3d">apop_matrix_pca</a> (gsl_matrix *data, int const dimensions_we_want)
<li><a class="el" href="structapop__data.html">apop_data</a> * <a class="el" href="group__linear__algebra.html#gaf2d13e1b1f20f97e0772a0be41dc430e">apop_dot</a> (const <a class="el" href="structapop__data.html">apop_data</a> *d1, const <a class="el" href="structapop__data.html">apop_data</a> *d2, char form1, char form2)
<li>gsl_vector * <a class="el" href="group__linear__algebra.html#ga1b6ecb8702153658c29369dc2e7cfba9">apop_numerical_gradient</a> (<a class="el" href="structapop__data.html">apop_data</a> *data, <a class="el" href="structapop__model.html">apop_model</a> *model, double delta)
</ul>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<p>This page describes some standard bits of linear algebra that Apophenia facilitates.</p>
<p>See also the printing functions, <a class="el" href="group__apop__print.html">Assorted printing functions</a>, and the <a class="el" href="group__convenience__fns.html">Convenience functions</a>. </p>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga6984006ab44fa7c9c2e99463f7d4081b"></a><!-- doxytag: member="apop_linear_algebra.c::apop_det_and_inv" ref="ga6984006ab44fa7c9c2e99463f7d4081b" args="(const gsl_matrix *in, gsl_matrix **out, int calc_det, int calc_inv)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="group__linear__algebra.html#ga6984006ab44fa7c9c2e99463f7d4081b">apop_det_and_inv</a> </td>
          <td>(</td>
          <td class="paramtype">const gsl_matrix *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsl_matrix **&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>calc_det</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>calc_inv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Calculate the determinant of a matrix, its inverse, or both, via LU decomposition. The <code>in</code> matrix is not destroyed in the process.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__linear__algebra.html#ga03038130e4ba55228f9e164dba513961">apop_matrix_determinant</a>, <a class="el" href="group__linear__algebra.html#ga185243be2d8a93686c68263cc3318f47">apop_matrix_inverse</a></dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>The matrix to be inverted/determined. </td></tr>
    <tr><td class="paramname">out</td><td>If you want an inverse, this is where to place the matrix to be filled with the inverse. Will be allocated by the function.</td></tr>
    <tr><td class="paramname">calc_det</td><td>0: Do not calculate the determinant.\ 1: Do.</td></tr>
    <tr><td class="paramname">calc_inv</td><td>0: Do not calculate the inverse.\ 1: Do.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>If <code>calc_det == 1</code>, then return the determinant. Otherwise, just returns zero. If <code>calc_inv!=0</code>, then <code>*out</code> is pointed to the matrix inverse. In case of difficulty, I will set <code>*out=NULL</code> and return <code>NaN</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="gaf2d13e1b1f20f97e0772a0be41dc430e"></a><!-- doxytag: member="apop_linear_algebra.c::apop_dot" ref="gaf2d13e1b1f20f97e0772a0be41dc430e" args="(const apop_data *d1, const apop_data *d2, char form1, char form2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__data.html">apop_data</a>* <a class="el" href="group__linear__algebra.html#gaf2d13e1b1f20f97e0772a0be41dc430e">apop_dot</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>d1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>d2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>form1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>form2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>A convenience function for dot products, which requires less prep and typing than the <code>gsl_cblas_dgexx</code> functions.</p>
<p>Second, it makes some use of the semi-overloading of the <a class="el" href="gentle.html#apop_data">apop_data</a> structure. <code>d1</code> may be a vector or a matrix, and the same for <code>d2</code>, so this function can do vector dot matrix, matrix dot matrix, and so on. If <code>d1</code> includes both a vector and a matrix, then later parameters will indicate which to use.</p>
<p>This function uses the <a class="el" href="designated.html">Designated initializers</a> syntax for inputs.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">d1</td><td>the left part of <img class="formulaInl" alt="$ d1 \cdot d2$" src="form_24.png"/> </td></tr>
    <tr><td class="paramname">d2</td><td>the right part of <img class="formulaInl" alt="$ d1 \cdot d2$" src="form_24.png"/> </td></tr>
    <tr><td class="paramname">form1</td><td>'t' or 'p': transpose or prime <code>d1-&gt;matrix</code>, or, if <code>d1-&gt;matrix</code> is <code>NULL</code>, read <code>d1-&gt;vector</code> as a row vector.<br/>
 'n' or 0: no transpose. (the default)<br/>
 'v': ignore the matrix and use the vector.</td></tr>
    <tr><td class="paramname">form2</td><td>As above, with <code>d2</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>an <a class="el" href="gentle.html#apop_data">apop_data</a> set. If two matrices come in, the vector element is <code>NULL</code> and the matrix has the dot product; if either or both are vectors, the vector has the output and the matrix is <code>NULL</code>.</dd></dl>
<dl class="exception"><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">out-&gt;error='a'</td><td>Allocation error. </td></tr>
    <tr><td class="paramname">out-&gt;error='d'</td><td>dimension-matching error. </td></tr>
    <tr><td class="paramname">out-&gt;error='m'</td><td>GSL math error. </td></tr>
    <tr><td class="paramname">NULL</td><td>If you ask me to take the dot product of NULL, I return NULL. [May some day change.]</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>Some systems auto-transpose non-conforming matrices. You input a <img class="formulaInl" alt="$3 \times 5$" src="form_25.png"/> and a <img class="formulaInl" alt="$3 \times 5$" src="form_25.png"/> matrix, and the system assumes that you meant to transpose the second, producing a <img class="formulaInl" alt="$3 \times 5 \cdot 5 \times 3 \rightarrow 3 \times 3$" src="form_26.png"/> output. Apophenia does not do this. First, it's ambiguous whether the output should be <img class="formulaInl" alt="$3 \times 3$" src="form_27.png"/> or <img class="formulaInl" alt="$5 \times 5$" src="form_28.png"/>. Second, your next run might have three observations, and two <img class="formulaInl" alt="$3 \times 3$" src="form_27.png"/> matrices don't require transposition; auto-transposition thus creates situations where bugs can pop up on only some iterations of a loop.</li>
</ul>
<ul>
<li>For a vector <img class="formulaInl" alt="$cdot$" src="form_29.png"/> a matrix, the vector is always treated as a row vector, meaning that a <img class="formulaInl" alt="$3\times 1$" src="form_30.png"/> dot a <img class="formulaInl" alt="$3\times 4$" src="form_31.png"/> matrix is correct, and produces a <img class="formulaInl" alt="$1 \times 4$" src="form_32.png"/> vector. For a vector <img class="formulaInl" alt="$cdot$" src="form_29.png"/> a matrix, the vector is always treated as a column vector. Requests for transposition are ignored.</li>
</ul>
<ul>
<li>As a corrollary to the above rule, a vector dot a vector always produces a scalar, which will be put in the zeroth element of the output vector; see the example.</li>
</ul>
<ul>
<li>If you want to multiply an <img class="formulaInl" alt="$N \times 1$" src="form_33.png"/> vector <img class="formulaInl" alt="$\cdot$" src="form_34.png"/> a <img class="formulaInl" alt="$1 \times N$" src="form_35.png"/> matrix produce an <img class="formulaInl" alt="$N \times N$" src="form_36.png"/> matrix, then use <a class="el" href="group__conversions.html#ga604388dc6d7d08d95bbaa4422085db9c">apop_vector_to_matrix</a> to turn your vectors into matrices; see the example.</li>
</ul>
<ul>
<li>A note for readers of <em>Modeling with Data</em>: the awkward instructions on using this function on p 130 are now obsolete, thanks to the designated initializer syntax for function calls. Notably, in the case where <code>d1</code> is a vector and <code>d2</code> a matrix, then <code>apop_dot(d1,d2,'t')</code> won't work, because <code>'t'</code> now refers to <code>d1</code>. Instead use <code>apop_dot(d1,d2,.form2='t')</code> or <code>apop_dot(d1,d2,0, 't')</code></li>
</ul>
<p>Sample code: </p>
<div class="fragment"><pre class="fragment"><span class="comment">/* A demonstration of dot products and various useful </span>
<span class="comment">   transformations among types. */</span>

<span class="preprocessor">#include &lt;apop.h&gt;</span>

<span class="keywordtype">double</span> eps=1e-3;<span class="comment">//slow to converge series--&gt;large tolerance.</span>
<span class="preprocessor">#define Diff(L, R) Apop_assert(fabs((L)-(R)&lt;(eps)), &quot;%g is too different from %g (abitrary limit=%g).&quot;, (double)(L), (double)(R), eps);</span>
<span class="preprocessor"></span>
<span class="keywordtype">int</span> main(){
    <span class="keywordtype">int</span> len = 3000;
    gsl_vector *v = gsl_vector_alloc(len);
    <span class="keywordflow">for</span> (<span class="keywordtype">double</span> i=0; i&lt; len; i++) gsl_vector_set(v, i, 1./(i+1));
    <span class="keywordtype">double</span> square;
    gsl_blas_ddot(v, v, &amp;square);
<span class="preprocessor">    #ifndef Testing</span>
<span class="preprocessor"></span>    printf(<span class="stringliteral">&quot;1 + (1/2)^2 + (1/3)^2 + ...= %g\n&quot;</span>, square);
<span class="preprocessor">    #endif</span>
<span class="preprocessor"></span>
    <span class="keywordtype">double</span> pi_over_six = gsl_pow_2(M_PI)/6.;
    Diff(square, pi_over_six);

    <span class="comment">/* Now using apop_dot, in a few forms.</span>
<span class="comment">       First, vector-as-data dot itself.</span>
<span class="comment">       If one of the inputs is a vector,</span>
<span class="comment">       apop_dot puts the output in a vector-as-data:*/</span>
    <a class="code" href="structapop__data.html">apop_data</a> *v_as_data = <a class="code" href="apop__data_8c.html#a4a69e915d2b6c40f9c69ec1842e2d689">apop_vector_to_data</a>(v);
    <a class="code" href="structapop__data.html">apop_data</a> *vdotv = <a class="code" href="group__linear__algebra.html#gaf2d13e1b1f20f97e0772a0be41dc430e">apop_dot</a>(v_as_data, v_as_data);
    Diff(gsl_vector_get(vdotv-&gt;vector, 0), pi_over_six);

    <span class="comment">/* As a matrix-as-data, via a compound literal. </span>
<span class="comment">       Default is a len X 1 matrix. */</span>
    gsl_matrix *v_as_matrix = <a class="code" href="group__conversions.html#ga604388dc6d7d08d95bbaa4422085db9c">apop_vector_to_matrix</a>(v);
    <a class="code" href="structapop__data.html">apop_data</a> dm = (<a class="code" href="types_8h.html#a0c8c2a99fb8c6ec54822aca08591545e">apop_data</a>){.matrix=v_as_matrix};

    <span class="comment">// (1 X len) dot (len X 1) --- OK, produce a scalar.</span>
    <a class="code" href="structapop__data.html">apop_data</a> *mdotv = <a class="code" href="group__linear__algebra.html#gaf2d13e1b1f20f97e0772a0be41dc430e">apop_dot</a>(v_as_data, &amp;dm);
    <span class="keywordtype">double</span> scalarval = gsl_vector_get(mdotv-&gt;vector, 0);
    Diff(scalarval, pi_over_six);

    <span class="comment">//(len X 1) dot (len X 1) --- bad dimensions.</span>
    <a class="code" href="apop__db_8c.html#a7975faa07196cf463ec261ff0ddc3ccc">apop_opts</a>.<a class="code" href="structapop__opts__type.html#aa76e9237ed45c77bc883b428c3217a66">verbose</a>=-1; <span class="comment">//don&#39;t print an error.</span>
    <a class="code" href="structapop__data.html">apop_data</a> *mdotv2 = <a class="code" href="group__linear__algebra.html#gaf2d13e1b1f20f97e0772a0be41dc430e">apop_dot</a>(&amp;dm, v_as_data);
    <a class="code" href="apop__db_8c.html#a7975faa07196cf463ec261ff0ddc3ccc">apop_opts</a>.<a class="code" href="structapop__opts__type.html#aa76e9237ed45c77bc883b428c3217a66">verbose</a>=0; <span class="comment">//back to sanity.</span>
    assert(mdotv2-&gt;error);

    <span class="comment">// If we want (len X 1) dot (1 X len) --&gt; (len X len),</span>
    <span class="comment">// use apop_vector_to_matrix.</span>
    <a class="code" href="structapop__data.html">apop_data</a> dmr = (<a class="code" href="types_8h.html#a0c8c2a99fb8c6ec54822aca08591545e">apop_data</a>){.matrix=<a class="code" href="group__conversions.html#ga604388dc6d7d08d95bbaa4422085db9c">apop_vector_to_matrix</a>(v, .row_col=<span class="charliteral">&#39;r&#39;</span>)};
    <a class="code" href="structapop__data.html">apop_data</a> *product_matrix = <a class="code" href="group__linear__algebra.html#gaf2d13e1b1f20f97e0772a0be41dc430e">apop_dot</a>(&amp;dm, &amp;dmr);
    <span class="comment">//The trace is the sum of squares:</span>
    gsl_vector_view trace = gsl_matrix_diagonal(product_matrix-&gt;matrix);
    <span class="keywordtype">double</span> tracesum = <a class="code" href="group__convenience__fns.html#ga7f85a98b61078ba3dc273f17eddd34a7">apop_sum</a>(&amp;trace.vector);
    Diff(tracesum, pi_over_six);

    <a class="code" href="types_8h.html#a459acfde11f2c39f5c32cff377f85b9e">apop_data_free</a>(product_matrix);
    gsl_matrix_free(dmr.matrix);
}
</pre></div> 
</div>
</div>
<a class="anchor" id="ga03038130e4ba55228f9e164dba513961"></a><!-- doxytag: member="apop_linear_algebra.c::apop_matrix_determinant" ref="ga03038130e4ba55228f9e164dba513961" args="(const gsl_matrix *in)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="group__linear__algebra.html#ga03038130e4ba55228f9e164dba513961">apop_matrix_determinant</a> </td>
          <td>(</td>
          <td class="paramtype">const gsl_matrix *&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Find the determinant of a matrix. The <code>in</code> matrix is not destroyed in the process.</p>
<p>See also <a class="el" href="group__linear__algebra.html#ga185243be2d8a93686c68263cc3318f47">apop_matrix_inverse</a> , or <a class="el" href="group__linear__algebra.html#ga6984006ab44fa7c9c2e99463f7d4081b">apop_det_and_inv</a> to do both at once.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>The matrix to be determined. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The determinant. </dd></dl>

</div>
</div>
<a class="anchor" id="ga185243be2d8a93686c68263cc3318f47"></a><!-- doxytag: member="apop_linear_algebra.c::apop_matrix_inverse" ref="ga185243be2d8a93686c68263cc3318f47" args="(const gsl_matrix *in)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gsl_matrix* <a class="el" href="group__linear__algebra.html#ga185243be2d8a93686c68263cc3318f47">apop_matrix_inverse</a> </td>
          <td>(</td>
          <td class="paramtype">const gsl_matrix *&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Inverts a matrix. The <code>in</code> matrix is not destroyed in the process. You may want to call <a class="el" href="group__linear__algebra.html#ga03038130e4ba55228f9e164dba513961">apop_matrix_determinant</a> first to check that your input is invertible, or use <a class="el" href="group__linear__algebra.html#ga6984006ab44fa7c9c2e99463f7d4081b">apop_det_and_inv</a> to do both at once.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>The matrix to be inverted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Its inverse. </dd></dl>

</div>
</div>
<a class="anchor" id="gaa1715c468336800a21ca86971323ae3d"></a><!-- doxytag: member="apop_linear_algebra.c::apop_matrix_pca" ref="gaa1715c468336800a21ca86971323ae3d" args="(gsl_matrix *data, int const dimensions_we_want)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__data.html">apop_data</a>* <a class="el" href="group__linear__algebra.html#gaa1715c468336800a21ca86971323ae3d">apop_matrix_pca</a> </td>
          <td>(</td>
          <td class="paramtype">gsl_matrix *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int const&#160;</td>
          <td class="paramname"><em>dimensions_we_want</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Principal component analysis: hand in a matrix and (optionally) a number of desired dimensions, and I'll return a data set where each column of the matrix is an eigenvector. The columns are sorted, so column zero has the greatest weight. The vector element of the data set gives the weights.</p>
<p>You also specify the number of elements your principal component space should have. If this is equal to the rank of the space in which the input data lives, then the sum of weights will be one. If the dimensions desired is less than that (probably so you can prepare a plot), then the weights will be accordingly smaller, giving you an indication of how much variation these dimensions explain.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The input matrix. (No default. If <code>NULL</code>, I'll return <code>NULL</code>.) I modify int in place so that each column has mean zero.</td></tr>
    <tr><td class="paramname">dimensions_we_want</td><td>(default: the size of the covariance matrix, i.e. <code>data-&gt;size2</code>) The singular value decomposition will return this many of the eigenvectors with the largest eigenvalues.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns a <a class="el" href="gentle.html#apop_data">apop_data</a> set whose matrix is the principal component space. Each column of the returned matrix will be another eigenvector; the columns will be ordered by the eigenvalues. The data set's vector will be the largest eigenvalues, scaled by the total of all eigenvalues (including those that were thrown out). The sum of these returned values will give you the percentage of variance explained by the factor analysis. </dd></dl>
<dl class="exception"><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">out-&gt;error=='a'</td><td>Allocation error. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga1b6ecb8702153658c29369dc2e7cfba9"></a><!-- doxytag: member="apop_mle.c::apop_numerical_gradient" ref="ga1b6ecb8702153658c29369dc2e7cfba9" args="(apop_data *data, apop_model *model, double delta)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gsl_vector* <a class="el" href="group__linear__algebra.html#ga1b6ecb8702153658c29369dc2e7cfba9">apop_numerical_gradient</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structapop__model.html">apop_model</a> *&#160;</td>
          <td class="paramname"><em>model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>delta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The GSL provides one-dimensional numerical differentiation; here's the multidimensional extension.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The data set to use for all evaluations. It remains constant throughout. </td></tr>
    <tr><td class="paramname">model</td><td>The model, expressing the function whose derivative is sought. The gradient is taken via small changes along the model parameters. </td></tr>
    <tr><td class="paramname">delta</td><td>The size of the differential. If you explicitly give me a <code>delta</code>, I'll use it. If <code>delta</code> is not specified, but <code>model</code> has <code>method_settings</code> of type <code>apop_ml_params</code>, then the <code>delta</code> element is used for the differential. Else, I use 1e-3.</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><pre class="fragment"> gsl_vector *gradient = <a class="code" href="group__linear__algebra.html#ga1b6ecb8702153658c29369dc2e7cfba9">apop_numerical_gradient</a>(data, your_parametrized_model);
</pre></div><ul>
<li>This function uses the <a class="el" href="designated.html">Designated initializers</a> syntax for inputs. </li>
</ul>

</div>
</div>
</div><!-- contents -->
<p><p>
<div class="tiny">Autogenerated by doxygen on Mon Apr 8 2013.</div></body></html>
