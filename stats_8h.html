<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html> <head>
     <title>Apophenia: a library for scientific computing</title>

<!-- Google is watching. -->
<script src="http://www.google-analytics.com/urchin.js" type="text/javascript">
</script>
<script type="text/javascript">
_uacct = "UA-134313-2";
urchinTracker();
</script>


     <link rel="stylesheet" href="typical.css" type="text/css" >
     <script  type="text/javascript" language="JavaScript" src="tree.js"></script>
</head><body>
     <center><table cellpadding=10pt>
     <tr> <td><img width=140px src=flake.gif alt="Patterns in static"></td> 
    <td><table>
     	<tr> <td><center><h2><a href="http://apophenia.info">Apophenia</a></h2></center></td></tr>
<tr><td><div class="qindex"><a class="qindex" href="index.html">&nbsp;Intro</a> | <a class="qindex" href="outline.html">Outline</a> | <a class="qindex" href="globals.html">Index</a> <!--| <a class="qindex" href="files.html">File&nbsp;List&nbsp;</a> -->  </div></td></tr></table>
	</td></tr></table></center>

    <div> <!--Doxygen generates an extra </div>.-->
<!-- Generated by Doxygen 1.7.6.1 -->
</div>
<div class="header">
  <div class="summary">
<a href="#define-members">Defines</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">stats.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><a href="stats_8h_source.html">Go to the source code of this file.</a></p>
<h2><a name="define-members"></a>
Defines</h2>
<ul>
<li>#define <b>APOP_SUBMATRIX</b>(m, srow, scol, nrows, ncols, o)
<li>#define <b>APOP_MATRIX_ROW</b>(m, row, v)
<li>#define <b>APOP_MATRIX_COL</b>(m, col, v)
<li>#define <b>APOP_ROW_T</b>(m, row, v)
<li>#define <b>APOP_COL_T</b>(m, col, v)
<li>#define <b>APOP_ROW</b>(m, row, v)
<li>#define <b>APOP_COL</b>(m, col, v)
<li>#define <a class="el" href="stats_8h.html#a3e95f1e99a52dd9717456a68bf1fab2e">Apop_data_rows</a>(d, rownum, len, outd)
<li>#define <a class="el" href="stats_8h.html#a2a1bc770d6631e85359acb8b665439b3">Apop_data_row</a>(d, row, outd)
<li>#define <a class="el" href="stats_8h.html#a79fc915cc70adb705029a8b9322abd7d">Apop_col</a>
<li><a class="anchor" id="a1ae65fc29259a9574c22994a21acabe5"></a><!-- doxytag: member="stats.h::apop_col" ref="a1ae65fc29259a9574c22994a21acabe5" args="" -->
#define <b>apop_col</b>&#160;&#160;&#160;APOP_COL
<li>#define <a class="el" href="stats_8h.html#a74dd4339556eb22240d21d19f1ad6dc8">Apop_row</a>
<li><a class="anchor" id="a31babc8f4ae3adcaf3910b6ec0297d55"></a><!-- doxytag: member="stats.h::apop_row" ref="a31babc8f4ae3adcaf3910b6ec0297d55" args="" -->
#define <b>apop_row</b>&#160;&#160;&#160;APOP_ROW
<li>#define <a class="el" href="stats_8h.html#afdacf526f18ea8c5bd16bd2572e5d4b3">Apop_col_t</a>
<li>#define <a class="el" href="stats_8h.html#af06c1ad1043c099596fb7d5e5c1b77d9">Apop_row_t</a>
<li>#define <a class="el" href="stats_8h.html#acb72baab9748cb810584df0096397209">Apop_matrix_col</a>
<li>#define <a class="el" href="stats_8h.html#a61b1e89d679e0011517f95c118f5bcfc">Apop_matrix_row</a>
<li>#define <a class="el" href="stats_8h.html#a8c66c0e920b1898f13c58174ef2fbf86">Apop_submatrix</a>
<li><a class="anchor" id="afe40fd5f7f1d717324bdd3e158230bf2"></a><!-- doxytag: member="stats.h::apop_data_rows" ref="afe40fd5f7f1d717324bdd3e158230bf2" args="" -->
#define <b>apop_data_rows</b>&#160;&#160;&#160;<a class="el" href="stats_8h.html#a3e95f1e99a52dd9717456a68bf1fab2e">Apop_data_rows</a>
<li><a class="anchor" id="a8ccece7de26ae9d4354f835bfb3503fc"></a><!-- doxytag: member="stats.h::apop_data_row" ref="a8ccece7de26ae9d4354f835bfb3503fc" args="" -->
#define <b>apop_data_row</b>&#160;&#160;&#160;<a class="el" href="stats_8h.html#a2a1bc770d6631e85359acb8b665439b3">Apop_data_row</a>
<li>#define <a class="el" href="group__convenience__fns.html#ga7f85a98b61078ba3dc273f17eddd34a7">apop_sum</a>(in)&#160;&#160;&#160;<a class="el" href="group__convenience__fns.html#gaf6182181dd424bc4de98b4bfbd349b4e">apop_vector_sum</a>(in)
<li>#define <a class="el" href="group__vector__moments.html#gacc311abe133963c7959162a7d3d83fb8">apop_var</a>(in)&#160;&#160;&#160;<a class="el" href="group__vector__moments.html#gad212e576119859f267d126c1ba905f9b">apop_vector_var</a>(in)
<li><a class="anchor" id="a4fdef6df3f8bd190df9c26201f42ab4b"></a><!-- doxytag: member="stats.h::apop_vector_covar" ref="a4fdef6df3f8bd190df9c26201f42ab4b" args="(in)" -->
#define <b>apop_vector_covar</b>(in)&#160;&#160;&#160;<a class="el" href="group__vector__moments.html#ga381f79a935cd436e32fa382db31932b5">apop_vector_cov</a>(in)
<li>#define <a class="el" href="group__vector__moments.html#ga0f69c8414f1d93fa15f3a631710dcd7a">apop_mean</a>(in)
<li>#define <a class="el" href="group__vector__moments.html#ga92c6abe8ada7ed8121c6881bcc6daf93">apop_vector_mean</a>(in)
<li>#define <a class="el" href="group__vector__moments.html#gad212e576119859f267d126c1ba905f9b">apop_vector_var</a>(in)
<li>#define <a class="el" href="group__vector__moments.html#ga04b4c93f39a7003f0180124ec502db31">apop_vector_kurt</a>(in)&#160;&#160;&#160;<a class="el" href="group__vector__moments.html#gaf5740c698174b1a265d182f4af1c0252">apop_vector_kurtosis</a>(in)
<li><a class="anchor" id="af1210155d44e962846822abfef413fbb"></a><!-- doxytag: member="stats.h::apop_ANOVA" ref="af1210155d44e962846822abfef413fbb" args="" -->
#define <b>apop_ANOVA</b>&#160;&#160;&#160;<a class="el" href="stats_8h.html#a1309242dbb7f148916c71a9a70c6b64c">apop_anova</a>
<li><a class="anchor" id="ae6aa069a742d2480040cfdaa79b2bc54"></a><!-- doxytag: member="stats.h::apop_F_test" ref="ae6aa069a742d2480040cfdaa79b2bc54" args="" -->
#define <b>apop_F_test</b>&#160;&#160;&#160;<a class="el" href="stats_8h.html#a1902b3fd6a6682d1453a80b788e44ebb">apop_f_test</a>
<li>#define <a class="el" href="group__regression.html#ga33c353f768fb4b0e7a3f98ab7a546ba5">apop_estimate_r_squared</a>(in)
</ul>
<h2><a name="func-members"></a>
Functions</h2>
<ul>
<li>double <a class="el" href="group__linear__algebra.html#ga6984006ab44fa7c9c2e99463f7d4081b">apop_det_and_inv</a> (const gsl_matrix *in, gsl_matrix **out, int calc_det, int calc_inv)
<li><a class="el" href="structapop__data.html">apop_data</a> * <a class="el" href="group__linear__algebra.html#gaf2d13e1b1f20f97e0772a0be41dc430e">apop_dot</a> (const <a class="el" href="structapop__data.html">apop_data</a> *d1, const <a class="el" href="structapop__data.html">apop_data</a> *d2, char form1, char form2)
<li>int <a class="el" href="group__convenience__fns.html#ga136ded2b6d190739deca064701cf5ca1">apop_vector_bounded</a> (const gsl_vector *in, long double max)
<li>void <a class="el" href="group__convenience__fns.html#ga6c6853616a59a1bd26765c7ef08fb86c">apop_vector_increment</a> (gsl_vector *v, int i, double amt)
<li>void <a class="el" href="group__convenience__fns.html#ga30db74bbed6bcc9cf4fa4cdbc68313b8">apop_matrix_increment</a> (gsl_matrix *m, int i, int j, double amt)
<li>gsl_matrix * <a class="el" href="group__linear__algebra.html#ga185243be2d8a93686c68263cc3318f47">apop_matrix_inverse</a> (const gsl_matrix *in)
<li>double <a class="el" href="group__linear__algebra.html#ga03038130e4ba55228f9e164dba513961">apop_matrix_determinant</a> (const gsl_matrix *in)
<li><a class="el" href="structapop__data.html">apop_data</a> * <a class="el" href="group__linear__algebra.html#gaa1715c468336800a21ca86971323ae3d">apop_matrix_pca</a> (gsl_matrix *data, int const dimensions_we_want)
<li>gsl_vector * <a class="el" href="group__convenience__fns.html#gae603a7d511cf40b022f99dc69faa616a">apop_vector_stack</a> (gsl_vector *v1, gsl_vector *v2, char inplace)
<li>gsl_matrix * <a class="el" href="group__convenience__fns.html#gae50bc918e0d8b6ee913596f68ab731a8">apop_matrix_stack</a> (gsl_matrix *m1, gsl_matrix *m2, char posn, char inplace)
<li>gsl_matrix * <a class="el" href="stats_8h.html#a5402b8254a90f2ac68770d6867502e5a">apop_matrix_rm_columns</a> (gsl_matrix *in, int *drop)
<li>void <a class="el" href="group__convenience__fns.html#ga5a622b8360eba63795a6049c30ac54a2">apop_vector_log</a> (gsl_vector *v)
<li>void <a class="el" href="group__convenience__fns.html#ga1a4a67e0b0bec8205cfe75bd3786c30e">apop_vector_log10</a> (gsl_vector *v)
<li>void <a class="el" href="group__convenience__fns.html#ga032dcecb67155c527c884dd2c1cc6a6e">apop_vector_exp</a> (gsl_vector *v)
<li>long double <a class="el" href="group__convenience__fns.html#gaf6182181dd424bc4de98b4bfbd349b4e">apop_vector_sum</a> (const gsl_vector *in)
<li><a class="anchor" id="affb84744d90fda2b78058ba3a37f11ca"></a><!-- doxytag: member="stats.h::apop_var" ref="affb84744d90fda2b78058ba3a37f11ca" args="(const gsl_vector *in)" -->
double <b>apop_var</b> (const gsl_vector *in)
<li>double <a class="el" href="group__vector__moments.html#ga2446385225c68c62ade26402c63600a4">apop_vector_var_m</a> (const gsl_vector *in, const double mean)
<li>double <a class="el" href="group__vector__moments.html#ga381f79a935cd436e32fa382db31932b5">apop_vector_cov</a> (const gsl_vector *ina, const gsl_vector *inb)
<li>double <a class="el" href="group__vector__moments.html#gae1154897fec0c56bc0161ed24c48759c">apop_vector_correlation</a> (const gsl_vector *ina, const gsl_vector *inb)
<li>double <a class="el" href="group__vector__moments.html#ga3cc380538e85584710434da659d9f750">apop_vector_kurtosis_pop</a> (const gsl_vector *in)
<li>double <a class="el" href="group__vector__moments.html#gaf5740c698174b1a265d182f4af1c0252">apop_vector_kurtosis</a> (const gsl_vector *in)
<li>double <a class="el" href="group__vector__moments.html#gac9d269f1dc62b038c0da72085cac1c28">apop_vector_skew</a> (const gsl_vector *in)
<li>double <a class="el" href="group__vector__moments.html#gaebb237b320230c50b7569a805fc5bab7">apop_vector_skew_pop</a> (const gsl_vector *in)
<li>double <a class="el" href="stats_8h.html#a520218aa38f82de6a6297263d44afa32">apop_vector_weighted_mean</a> (const gsl_vector *, const gsl_vector *)
<li>double <a class="el" href="stats_8h.html#af287d7c166a17d35bcdce5e7c8515fce">apop_vector_weighted_var</a> (const gsl_vector *v, const gsl_vector *w)
<li>double <a class="el" href="stats_8h.html#a901c4b16e5691fedb4a8463548bc26a8">apop_vector_weighted_cov</a> (const gsl_vector *, const gsl_vector *, const gsl_vector *)
<li>double <a class="el" href="stats_8h.html#ab2c0cb715352abd662783b6f1bb4d84e">apop_vector_weighted_skew</a> (const gsl_vector *v, const gsl_vector *w)
<li>double <a class="el" href="stats_8h.html#aca7a5cac76bd44584d88781c5b3cbb23">apop_vector_weighted_kurt</a> (const gsl_vector *v, const gsl_vector *w)
<li>double <a class="el" href="group__convenience__fns.html#ga44a77f5e6867c627fd313f3f6e252ff8">apop_vector_distance</a> (const gsl_vector *ina, const gsl_vector *inb, const char metric, const double norm)
<li>void <a class="el" href="stats_8h.html#a194ad92b1bc632ba1d13d9958c7b5b4d">apop_vector_normalize</a> (gsl_vector *in, gsl_vector **out, const char normalization_type)
<li>void <a class="el" href="stats_8h.html#af6290c453c3012c1d0a6987688ebe795">apop_matrix_normalize</a> (gsl_matrix *data, const char row_or_col, const char normalization)
<li>gsl_matrix * <a class="el" href="stats_8h.html#a8ab4dde598ac3710072eb58384512153">apop_matrix_covariance</a> (gsl_matrix *in, const char normalize)
<li>gsl_matrix * <a class="el" href="stats_8h.html#a46a40bc32015eb68e605835d82c3134b">apop_matrix_correlation</a> (gsl_matrix *in, const char normalize)
<li><a class="el" href="structapop__data.html">apop_data</a> * <a class="el" href="stats_8h.html#aeae37a5bf11cddee59e272b083a4efc7">apop_data_covariance</a> (const <a class="el" href="structapop__data.html">apop_data</a> *in)
<li><a class="el" href="structapop__data.html">apop_data</a> * <a class="el" href="stats_8h.html#afa3ab967f57f8ad3cfb99a4a82cfae02">apop_data_correlation</a> (const <a class="el" href="structapop__data.html">apop_data</a> *in)
<li>long double <a class="el" href="group__convenience__fns.html#ga369c774aac917e56d8e32f9c66d9c2a0">apop_matrix_sum</a> (const gsl_matrix *m)
<li>double <a class="el" href="group__convenience__fns.html#ga040b9e9fea1abe105de86081bf396d40">apop_matrix_mean</a> (const gsl_matrix *data)
<li>void <a class="el" href="group__convenience__fns.html#gaf794cc2491ef147e0c67eb05feed7a87">apop_matrix_mean_and_var</a> (const gsl_matrix *data, double *mean, double *var)
<li><a class="el" href="structapop__data.html">apop_data</a> * <a class="el" href="group__output.html#gaca60728fc3b691acfcadebf3a8535532">apop_data_summarize</a> (<a class="el" href="structapop__data.html">apop_data</a> *data)
<li><a class="el" href="structapop__data.html">apop_data</a> * <a class="el" href="stats_8h.html#a8627a1eebf904699e90e66adc8b4b021">apop_test_fisher_exact</a> (<a class="el" href="structapop__data.html">apop_data</a> *intab)
<li>int <a class="el" href="stats_8h.html#afc7707d44884aa63c298510a0662956a">apop_matrix_is_positive_semidefinite</a> (gsl_matrix *m, char semi)
<li>double <a class="el" href="stats_8h.html#af1fc93322ffcb4e20cfc0b9af9e2aea0">apop_matrix_to_positive_semidefinite</a> (gsl_matrix *m)
<li>double <a class="el" href="stats_8h.html#a463920325a6102396515d80e57e6c519">apop_multivariate_gamma</a> (double a, double p)
<li>double <a class="el" href="stats_8h.html#a565a9c7bf2cb5b171cf0fce622d54bca">apop_multivariate_lngamma</a> (double a, double p)
<li><a class="el" href="structapop__data.html">apop_data</a> * <a class="el" href="group__ttest.html#ga65c94b79fe91308dc97829741acc9322">apop_t_test</a> (gsl_vector *a, gsl_vector *b)
<li><a class="el" href="structapop__data.html">apop_data</a> * <a class="el" href="group__ttest.html#ga0ae576fb823e38f7b6f2ce1892e4b014">apop_paired_t_test</a> (gsl_vector *a, gsl_vector *b)
<li><a class="el" href="structapop__data.html">apop_data</a> * <a class="el" href="stats_8h.html#a1309242dbb7f148916c71a9a70c6b64c">apop_anova</a> (char *table, char *data, char *grouping1, char *grouping2)
<li><a class="el" href="structapop__data.html">apop_data</a> * <a class="el" href="stats_8h.html#a1902b3fd6a6682d1453a80b788e44ebb">apop_f_test</a> (<a class="el" href="structapop__model.html">apop_model</a> *est, <a class="el" href="structapop__data.html">apop_data</a> *contrast)
<li><a class="el" href="structapop__data.html">apop_data</a> * <a class="el" href="stats_8h.html#a77c937ea4764d3da2ed9968273fa4544">apop_text_unique_elements</a> (const <a class="el" href="structapop__data.html">apop_data</a> *d, size_t col)
<li>gsl_vector * <a class="el" href="stats_8h.html#a6d68bacc086420a382366f9118cf5bc7">apop_vector_unique_elements</a> (const gsl_vector *v)
<li><a class="el" href="structapop__data.html">apop_data</a> * <a class="el" href="stats_8h.html#a27405bd5fdf48d93c8918ca4c07ee260">apop_data_to_factors</a> (<a class="el" href="structapop__data.html">apop_data</a> *data, char intype, int incol, int outcol)
<li><a class="el" href="structapop__data.html">apop_data</a> * <a class="el" href="stats_8h.html#adec9170cf1382f6cd549a5819472eb51">apop_data_get_factor_names</a> (<a class="el" href="structapop__data.html">apop_data</a> *data, int col, char type)
<li><a class="el" href="structapop__data.html">apop_data</a> * <a class="el" href="stats_8h.html#ae0c28224e10f8aacdaa2d130f96f6ba2">apop_data_to_dummies</a> (<a class="el" href="structapop__data.html">apop_data</a> *d, int col, char type, int keep_first, char append, char remove)
<li>double <a class="el" href="stats_8h.html#a4489b3994f099ed40ccd77df6143728e">apop_kl_divergence</a> (<a class="el" href="structapop__model.html">apop_model</a> *top, <a class="el" href="structapop__model.html">apop_model</a> *bottom, int draw_ct, gsl_rng *rng)
<li><a class="el" href="structapop__data.html">apop_data</a> * <a class="el" href="group__regression.html#gaceead3e4aaba543b7fc1d194fcbc40f8">apop_estimate_coefficient_of_determination</a> (<a class="el" href="structapop__model.html">apop_model</a> *)
<li>void <a class="el" href="stats_8h.html#ae165633525c5272ab83794b60076eddc">apop_estimate_parameter_tests</a> (<a class="el" href="structapop__model.html">apop_model</a> *est)
<li><a class="el" href="structapop__data.html">apop_data</a> * <a class="el" href="stats_8h.html#a95162a0f5c4879201bfd5bb98d20f7b2">apop_jackknife_cov</a> (<a class="el" href="structapop__data.html">apop_data</a> *data, <a class="el" href="structapop__model.html">apop_model</a> model)
<li><a class="el" href="structapop__data.html">apop_data</a> * <a class="el" href="stats_8h.html#aed343e0e790bd7e1fd1e455d23e394b2">apop_bootstrap_cov</a> (<a class="el" href="structapop__data.html">apop_data</a> *data, <a class="el" href="structapop__model.html">apop_model</a> model, gsl_rng *rng, int iterations, char keep_boots, char ignore_nans)
<li>gsl_rng * <a class="el" href="group__convenience__fns.html#gada044cf02135422a9f9292b6054c86dd">apop_rng_alloc</a> (int seed)
<li>double <a class="el" href="stats_8h.html#aaf0d5d65f514d9894a4ca5b0e8755873">apop_rng_GHgB3</a> (gsl_rng *r, double *a)
<li>void <a class="el" href="stats_8h.html#ad422a97e52c70bacb585a9f27a987d23">apop_arms_draw</a> (double *out, gsl_rng *r, <a class="el" href="structapop__model.html">apop_model</a> *m)
<dl class="el"><dd class="mdescRight">Adaptive rejection metropolis sampling.  <a href="#ad422a97e52c70bacb585a9f27a987d23"></a><br/></dl><li>gsl_vector * <a class="el" href="group__linear__algebra.html#ga1b6ecb8702153658c29369dc2e7cfba9">apop_numerical_gradient</a> (<a class="el" href="structapop__data.html">apop_data</a> *data, <a class="el" href="structapop__model.html">apop_model</a> *model, double delta)
<li><a class="el" href="structapop__data.html">apop_data</a> * <a class="el" href="stats_8h.html#a1a55a20880947e289767aad6e5b0117c">apop_model_hessian</a> (<a class="el" href="structapop__data.html">apop_data</a> *data, <a class="el" href="structapop__model.html">apop_model</a> *model, double delta)
<li><a class="el" href="structapop__data.html">apop_data</a> * <a class="el" href="stats_8h.html#a0f2784b69175d1ecd3833d228d2294e7">apop_model_numerical_covariance</a> (<a class="el" href="structapop__data.html">apop_data</a> *data, <a class="el" href="structapop__model.html">apop_model</a> *model, double delta)
<li><a class="el" href="structapop__model.html">apop_model</a> * <a class="el" href="group__mle.html#ga29975e75eec9ff9f48e836971a32c925">apop_maximum_likelihood</a> (<a class="el" href="structapop__data.html">apop_data</a> *data, <a class="el" href="structapop__model.html">apop_model</a> *dist)
<li><a class="el" href="structapop__model.html">apop_model</a> * <a class="el" href="group__mle.html#ga6d5e39c00012de5b51cd49ce1ffd31fe">apop_estimate_restart</a> (<a class="el" href="structapop__model.html">apop_model</a> *e, <a class="el" href="structapop__model.html">apop_model</a> *copy, char *starting_pt, double boundary)
<li>double <a class="el" href="stats_8h.html#a1db15d25579048bcc36b5aabdf9dfd65">apop_linear_constraint</a> (gsl_vector *beta, <a class="el" href="structapop__data.html">apop_data</a> *constraint, double margin)
<li><a class="el" href="structapop__model.html">apop_model</a> * <a class="el" href="stats_8h.html#ab4f6ca7e042ac7c09c3c01d29702a739">apop_model_fix_params</a> (<a class="el" href="structapop__model.html">apop_model</a> *model_in)
<li><a class="anchor" id="af676505faea1c7e30ffbd8690a092ed8"></a><!-- doxytag: member="stats.h::apop_model_fix_params_get_base" ref="af676505faea1c7e30ffbd8690a092ed8" args="(apop_model *model_in)" -->
<a class="el" href="structapop__model.html">apop_model</a> * <b>apop_model_fix_params_get_base</b> (<a class="el" href="structapop__model.html">apop_model</a> *model_in)
</ul>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"></div><hr/><h2>Define Documentation</h2>
<a class="anchor" id="a5631641ed13968da46e73b768d225b14"></a><!-- doxytag: member="stats.h::APOP_COL" ref="a5631641ed13968da46e73b768d225b14" args="(m, col, v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define APOP_COL</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">m, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">col, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">v&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">gsl_vector apop_vv_##v = (col &lt; 0) ? *((m)-&gt;vector) : gsl_matrix_column((m)-&gt;matrix, (col)).vector;\
gsl_vector * v = &amp;( apop_vv_##v );
</pre></div>
</div>
</div>
<a class="anchor" id="a79fc915cc70adb705029a8b9322abd7d"></a><!-- doxytag: member="stats.h::Apop_col" ref="a79fc915cc70adb705029a8b9322abd7d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="stats_8h.html#a79fc915cc70adb705029a8b9322abd7d">Apop_col</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>After this call, <code>v</code> will hold a vector view of the <code>col</code>th column of <a class="el" href="gentle.html#apop_data">apop_data</a> set <code>d</code>. </p>

</div>
</div>
<a class="anchor" id="a4d5d88e3945223ac9bec5a06ba090ecd"></a><!-- doxytag: member="stats.h::APOP_COL_T" ref="a4d5d88e3945223ac9bec5a06ba090ecd" args="(m, col, v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define APOP_COL_T</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">m, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">col, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">v&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">gsl_vector apop_vv_##v = gsl_matrix_column((m)-&gt;matrix, <a class="code" href="apop__name_8c.html#a6c71f6c23090592a291fc878c8836120">apop_name_find</a>((m)-&gt;names, col, <span class="charliteral">&#39;c&#39;</span>)).vector;\
gsl_vector * v = &amp;( apop_vv_##v );
</pre></div>
</div>
</div>
<a class="anchor" id="afdacf526f18ea8c5bd16bd2572e5d4b3"></a><!-- doxytag: member="stats.h::Apop_col_t" ref="afdacf526f18ea8c5bd16bd2572e5d4b3" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="stats_8h.html#afdacf526f18ea8c5bd16bd2572e5d4b3">Apop_col_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>After this call, <code>v</code> will hold a vector view of the <code>col</code>th column of <code>m</code>. Unlike <a class="el" href="stats_8h.html#a79fc915cc70adb705029a8b9322abd7d">Apop_col</a>, the second argument is a column name, that I'll look up using <a class="el" href="types_8h.html#adb1398925a93b7c2c502af8fb2abc49e">apop_name_find</a>. </p>

</div>
</div>
<a class="anchor" id="a2a1bc770d6631e85359acb8b665439b3"></a><!-- doxytag: member="stats.h::Apop_data_row" ref="a2a1bc770d6631e85359acb8b665439b3" args="(d, row, outd)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="stats_8h.html#a2a1bc770d6631e85359acb8b665439b3">Apop_data_row</a></td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">d, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">row, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">outd&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>A macro to generate a temporary one-row view of <a class="el" href="gentle.html#apop_data">apop_data</a> set <code>d</code>, pulling out only row <code>row</code>. After this call, <code>outd</code> will be a pointer to this temporary view, that you can use as you would any <a class="el" href="gentle.html#apop_data">apop_data</a> set. This macro expands to <code><a class="el" href="stats_8h.html#a3e95f1e99a52dd9717456a68bf1fab2e">Apop_data_rows(d, row, 1, outd)</a></code>. </p>

</div>
</div>
<a class="anchor" id="a3e95f1e99a52dd9717456a68bf1fab2e"></a><!-- doxytag: member="stats.h::Apop_data_rows" ref="a3e95f1e99a52dd9717456a68bf1fab2e" args="(d, rownum, len, outd)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="stats_8h.html#a3e95f1e99a52dd9717456a68bf1fab2e">Apop_data_rows</a></td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">d, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">rownum, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">len, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">outd&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>A macro to generate a temporary view of <a class="el" href="gentle.html#apop_data">apop_data</a> set <code>d</code>, beginning at row <code>row</code> and having length <code>len</code>. After this call, <code>outd</code> will be a pointer to this temporary view, that you can use as you would any <a class="el" href="gentle.html#apop_data">apop_data</a> set. However, it expires as soon as the program leaves the current scope (like with the usual statically declared vars). </p>

</div>
</div>
<a class="anchor" id="aff5598e60100c78cfc5ae527194856a0"></a><!-- doxytag: member="stats.h::APOP_MATRIX_COL" ref="aff5598e60100c78cfc5ae527194856a0" args="(m, col, v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define APOP_MATRIX_COL</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">m, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">col, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">v&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">gsl_vector apop_vv_##v = gsl_matrix_column((m), (col)).vector;\
gsl_vector * v = &amp;( apop_vv_##v );
</pre></div>
</div>
</div>
<a class="anchor" id="acb72baab9748cb810584df0096397209"></a><!-- doxytag: member="stats.h::Apop_matrix_col" ref="acb72baab9748cb810584df0096397209" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="stats_8h.html#acb72baab9748cb810584df0096397209">Apop_matrix_col</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>After this call, <code>v</code> will hold a vector view of the <code>col</code>th column of <code>m</code>. </p>

</div>
</div>
<a class="anchor" id="a09e33bc18dc5b3bdc17914fb7e72b34c"></a><!-- doxytag: member="stats.h::APOP_MATRIX_ROW" ref="a09e33bc18dc5b3bdc17914fb7e72b34c" args="(m, row, v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define APOP_MATRIX_ROW</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">m, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">row, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">v&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">gsl_vector apop_vv_##v = gsl_matrix_row((m), (row)).vector;\
gsl_vector * v = &amp;( apop_vv_##v );
</pre></div>
</div>
</div>
<a class="anchor" id="a61b1e89d679e0011517f95c118f5bcfc"></a><!-- doxytag: member="stats.h::Apop_matrix_row" ref="a61b1e89d679e0011517f95c118f5bcfc" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="stats_8h.html#a61b1e89d679e0011517f95c118f5bcfc">Apop_matrix_row</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>After this call, <code>v</code> will hold a vector view of the <code>row</code>th row of <code>m</code>. </p>

</div>
</div>
<a class="anchor" id="a5ce10978bb935f3bd01a2572358e88a6"></a><!-- doxytag: member="stats.h::APOP_ROW" ref="a5ce10978bb935f3bd01a2572358e88a6" args="(m, row, v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define APOP_ROW</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">m, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">row, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">v&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">gsl_vector apop_vv_##v = gsl_matrix_row((m)-&gt;matrix, (row)).vector;\
gsl_vector * v = &amp;( apop_vv_##v );
</pre></div>
</div>
</div>
<a class="anchor" id="a74dd4339556eb22240d21d19f1ad6dc8"></a><!-- doxytag: member="stats.h::Apop_row" ref="a74dd4339556eb22240d21d19f1ad6dc8" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="stats_8h.html#a74dd4339556eb22240d21d19f1ad6dc8">Apop_row</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>After this call, <code>v</code> will hold a vector view of the <code>row</code>th row of <a class="el" href="gentle.html#apop_data">apop_data</a> set <code>d</code>. </p>

</div>
</div>
<a class="anchor" id="aa36acf4b5e12768649c7ec2d6b957edf"></a><!-- doxytag: member="stats.h::APOP_ROW_T" ref="aa36acf4b5e12768649c7ec2d6b957edf" args="(m, row, v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define APOP_ROW_T</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">m, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">row, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">v&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">gsl_vector apop_vv_##v = gsl_matrix_row((m)-&gt;matrix, <a class="code" href="apop__name_8c.html#a6c71f6c23090592a291fc878c8836120">apop_name_find</a>((m)-&gt;names, row, <span class="charliteral">&#39;r&#39;</span>)).vector;\
gsl_vector * v = &amp;( apop_vv_##v );
</pre></div>
</div>
</div>
<a class="anchor" id="af06c1ad1043c099596fb7d5e5c1b77d9"></a><!-- doxytag: member="stats.h::Apop_row_t" ref="af06c1ad1043c099596fb7d5e5c1b77d9" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="stats_8h.html#af06c1ad1043c099596fb7d5e5c1b77d9">Apop_row_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>After this call, <code>v</code> will hold a vector view of the <code>row</code>th row of <code>m</code>. Unlike <a class="el" href="stats_8h.html#a74dd4339556eb22240d21d19f1ad6dc8">Apop_row</a>, the second argument is a row name, that I'll look up using <a class="el" href="types_8h.html#adb1398925a93b7c2c502af8fb2abc49e">apop_name_find</a>. </p>

</div>
</div>
<a class="anchor" id="a07588193981c84a4ab7f0370e38b8971"></a><!-- doxytag: member="stats.h::APOP_SUBMATRIX" ref="a07588193981c84a4ab7f0370e38b8971" args="(m, srow, scol, nrows, ncols, o)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define APOP_SUBMATRIX</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">m, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">srow, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">scol, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">nrows, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ncols, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">o&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">gsl_matrix apop_mm_##o = gsl_matrix_submatrix((m), (srow), (scol), (nrows),(ncols)).matrix;\
gsl_matrix * o = &amp;( apop_mm_##o );
</pre></div>
</div>
</div>
<a class="anchor" id="a8c66c0e920b1898f13c58174ef2fbf86"></a><!-- doxytag: member="stats.h::Apop_submatrix" ref="a8c66c0e920b1898f13c58174ef2fbf86" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="stats_8h.html#a8c66c0e920b1898f13c58174ef2fbf86">Apop_submatrix</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Pull a pointer to a submatrix into a <code>gsl_matrix</code> </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The root matrix </td></tr>
    <tr><td class="paramname">srow</td><td>the first row (in the root matrix) of the top of the submatrix </td></tr>
    <tr><td class="paramname">scol</td><td>the first column (in the root matrix) of the left edge of the submatrix </td></tr>
    <tr><td class="paramname">nrow</td><td>number of rows in the submatrix </td></tr>
    <tr><td class="paramname">ncol</td><td>number of columns in the submatrix </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a1309242dbb7f148916c71a9a70c6b64c"></a><!-- doxytag: member="stats.h::apop_anova" ref="a1309242dbb7f148916c71a9a70c6b64c" args="(char *table, char *data, char *grouping1, char *grouping2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__data.html">apop_data</a>* <a class="el" href="stats_8h.html#a1309242dbb7f148916c71a9a70c6b64c">apop_anova</a> </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>grouping1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>grouping2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function produces a traditional one- or two-way ANOVA table. It works from data in an SQL table, using queries of the form <code>select data from table group by grouping1, grouping2</code>.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>The table to be queried. Anything that can go in an SQL <code>from</code> clause is OK, so this can be a plain table name or a temp table specification like <code>(select ... )</code>, with parens. </td></tr>
    <tr><td class="paramname">data</td><td>The name of the column holding the count or other such data </td></tr>
    <tr><td class="paramname">grouping1</td><td>The name of the first column by which to group data </td></tr>
    <tr><td class="paramname">grouping2</td><td>If this is <code>NULL</code>, then the function will return a one-way ANOVA. Otherwise, the name of the second column by which to group data in a two-way ANOVA. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad422a97e52c70bacb585a9f27a987d23"></a><!-- doxytag: member="stats.h::apop_arms_draw" ref="ad422a97e52c70bacb585a9f27a987d23" args="(double *out, gsl_rng *r, apop_model *m)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="stats_8h.html#ad422a97e52c70bacb585a9f27a987d23">apop_arms_draw</a> </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsl_rng *&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structapop__model.html">apop_model</a> *&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adaptive rejection metropolis sampling. </p>
<p>This is a function to make random draws from any univariate distribution (more or less).</p>
<p>The author, Wally Gilks, explains on <a href="http://www.amsta.leeds.ac.uk/~wally.gilks/adaptive.rejection/web_page/Welcome.html,">http://www.amsta.leeds.ac.uk/~wally.gilks/adaptive.rejection/web_page/Welcome.html,</a> that ``ARS works by constructing an envelope function of the log of the target density, which is then used in rejection sampling (see, for example, Ripley, 1987). Whenever a point is rejected by ARS, the envelope is updated to correspond more closely to the true log density, thereby reducing the chance of rejecting subsequent points. Fewer ARS rejection steps implies fewer point-evaluations of the log density.''</p>
<ul>
<li>It accepts only functions with univariate inputs. I.e., it will put a single value in the vector part of a <a class="el" href="gentle.html#apop_data">apop_data</a> set, and then evaluate the log likelihood at that point.</li>
</ul>
<ul>
<li>It is currently the default for the <a class="el" href="group__models.html#gaca737ed521192a76a307bbf825ab4a97">apop_draw</a> function, so you can just call that if you prefer.</li>
</ul>
<ul>
<li>There are a great number of parameters, in the <code><a class="el" href="structapop__arms__settings.html">apop_arms_settings</a></code> structure. The structure also holds a history of the points tested to date. That means that the system will be more accurate as more draws are made. It also means that if the parameters change, or you use <a class="el" href="group__models.html#ga14f2bd54421fd6629baccb8a41ecd304">apop_model_copy</a>, you should call <code><a class="el" href="group__settings.html#ga4ff4361f65c1e848fabce24b4b8f44f7">Apop_settings_rm_group(your_model, apop_arms)</a></code> to clear the model of points that are not valid for a different situation.</li>
</ul>
<ul>
<li>See <a class="el" href="structapop__arms__settings.html">apop_arms_settings</a> for the list of parameters that you may want to set, via a form like <code>apop_model_add_group(your_model, apop_arms, .model=your_model, .xl=8, .xr =14);</code>. The <code>model</code> element is mandatory; you'll get a run-time complaint if you forget it. </li>
</ul>

</div>
</div>
<a class="anchor" id="aed343e0e790bd7e1fd1e455d23e394b2"></a><!-- doxytag: member="stats.h::apop_bootstrap_cov" ref="aed343e0e790bd7e1fd1e455d23e394b2" args="(apop_data *data, apop_model model, gsl_rng *rng, int iterations, char keep_boots, char ignore_nans)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__data.html">apop_data</a>* <a class="el" href="stats_8h.html#aed343e0e790bd7e1fd1e455d23e394b2">apop_bootstrap_cov</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structapop__model.html">apop_model</a>&#160;</td>
          <td class="paramname"><em>model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsl_rng *&#160;</td>
          <td class="paramname"><em>rng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iterations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>keep_boots</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>ignore_nans</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Give me a data set and a model, and I'll give you the bootstrapped covariance matrix of the parameter estimates.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The data set. An <code><a class="el" href="structapop__data.html">apop_data</a></code> set where each row is a single data point. (No default) </td></tr>
    <tr><td class="paramname">model</td><td>An <a class="el" href="structapop__model.html">apop_model</a>, whose <code>estimate</code> method will be used here. (No default) </td></tr>
    <tr><td class="paramname">iterations</td><td>How many bootstrap draws should I make? (default: 1,000) </td></tr>
    <tr><td class="paramname">rng</td><td>An RNG that you have initialized, probably with <code>apop_rng_alloc</code>. (Default: see <a class="el" href="autorng.html">Auto-allocated RNGs</a>) </td></tr>
    <tr><td class="paramname">keep_boots</td><td>If 'y', then add a page to the output <a class="el" href="gentle.html#apop_data">apop_data</a> set with the statistics calculated for each bootstrap iteration. They are packed via <a class="el" href="group__conversions.html#ga7e31798ab418cbfc7488eaba27dad2af">apop_data_pack</a>, so use <a class="el" href="group__conversions.html#gae3058b7f39d0442f13284464d1ba235d">apop_data_unpack</a> if needed. (Default: 'n') <div class="fragment"><pre class="fragment"><a class="code" href="structapop__data.html">apop_data</a> *boot_output = <a class="code" href="apop__bootstrap_8c.html#aed343e0e790bd7e1fd1e455d23e394b2">apop_bootstrap_cov</a>(your_data, your_model, .keep_boots=<span class="charliteral">&#39;y&#39;</span>);
<a class="code" href="structapop__data.html">apop_data</a> *boot_stats = <a class="code" href="apop__data_8c.html#a044771db76f0afb410a8d4f05ac51ca3">apop_data_get_page</a>(boot_output, <span class="stringliteral">&quot;&lt;bootstrapped statistics&gt;&quot;</span>);

<a class="code" href="stats_8h.html#a74dd4339556eb22240d21d19f1ad6dc8">Apop_row</a>(boot_stats, 27, row_27)
<span class="comment">//If the output statistic is not just a vector, you&#39;ll need to use apop_data_unpack to put</span>
<span class="comment">//it into the right shape. Let&#39;s assume for now that it&#39;s just a vector:</span>
printf(&quot;The statistics calculated on the 28th iteration:\n&quot;);
<a class="code" href="group__apop__print.html#ga6e68deb42339cf6068ab6e741237918d">apop_vector_print</a>(row_27);
</pre></div> </td></tr>
    <tr><td class="paramname">ignore_nans</td><td>If <code>'y'</code> and any of the elements in the estimation return <code>NaN</code>, then I will throw out that draw and try again. If <code>'n'</code>, then I will write that set of statistics to the list, <code>NaN</code> and all. I keep count of throw-aways; if there are more than <code>iterations</code> elements thrown out, then I throw an error and return with estimates using data I have so far. That is, I assume that <code>NaNs</code> are rare edge cases; if they are as common as good data, you might want to rethink how you are using the bootstrap mechanism. (Default: 'n') </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>An <code><a class="el" href="structapop__data.html">apop_data</a></code> set whose matrix element is the estimated covariance matrix of the parameters. </dd></dl>
<dl class="exception"><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">out-&gt;error=='n'</td><td><code>NULL</code> input data. <ul>
<li>This function uses the <a class="el" href="designated.html">Designated initializers</a> syntax for inputs. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="stats_8h.html#a95162a0f5c4879201bfd5bb98d20f7b2">apop_jackknife_cov</a> </dd></dl>

</div>
</div>
<a class="anchor" id="afa3ab967f57f8ad3cfb99a4a82cfae02"></a><!-- doxytag: member="stats.h::apop_data_correlation" ref="afa3ab967f57f8ad3cfb99a4a82cfae02" args="(const apop_data *in)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__data.html">apop_data</a>* <a class="el" href="stats_8h.html#afa3ab967f57f8ad3cfb99a4a82cfae02">apop_data_correlation</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the matrix of correlation coefficients <img class="formulaInl" alt="$(\sigma^2_{xy}/(\sigma_x\sigma_y))$" src="form_61.png"/> relating each column with each other.</p>
<p>This is the <a class="el" href="gentle.html#apop_data">apop_data</a> version of <a class="el" href="stats_8h.html#a46a40bc32015eb68e605835d82c3134b">apop_matrix_correlation</a>; if you don't have column names or weights, (or want the option for the faster, data-destroying version), use that one.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>A data matrix: rows are observations, columns are variables. If you give me a weights vector, I'll use it.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns the variance/covariance matrix relating each column with each other. This function allocates the matrix for you. </dd></dl>
<dl class="exception"><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">out-&gt;error='a'</td><td>Allocation error. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aeae37a5bf11cddee59e272b083a4efc7"></a><!-- doxytag: member="stats.h::apop_data_covariance" ref="aeae37a5bf11cddee59e272b083a4efc7" args="(const apop_data *in)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__data.html">apop_data</a>* <a class="el" href="stats_8h.html#aeae37a5bf11cddee59e272b083a4efc7">apop_data_covariance</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the variance/covariance matrix relating each column of the matrix to each other column.</p>
<p>This is the <a class="el" href="gentle.html#apop_data">apop_data</a> version of <a class="el" href="stats_8h.html#a8ab4dde598ac3710072eb58384512153">apop_matrix_covariance</a>; if you don't have column names or weights, or would like to use the speed-saving and data-destroying normalization option, use that one.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>An <a class="el" href="gentle.html#apop_data">apop_data</a> set. If the weights vector is set, I'll take it into account.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns a <a class="el" href="gentle.html#apop_data">apop_data</a> set the variance/covariance matrix relating each column with each other. </dd></dl>
<dl class="exception"><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">out-&gt;error='a'</td><td>Allocation error. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adec9170cf1382f6cd549a5819472eb51"></a><!-- doxytag: member="stats.h::apop_data_get_factor_names" ref="adec9170cf1382f6cd549a5819472eb51" args="(apop_data *data, int col, char type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__data.html">apop_data</a>* <a class="el" href="stats_8h.html#adec9170cf1382f6cd549a5819472eb51">apop_data_get_factor_names</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Factor names are stored in an auxiliary table with a name like <code>"&lt;categories for your_var&gt;"</code>. Producing this name is annoying (and prevents us from eventually making it human-language independent), so use this function to get the list of factor names.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The data set. (No default, must not be <code>NULL</code>) </td></tr>
    <tr><td class="paramname">col</td><td>The column in the main data set whose name I'll use to check for the factor name list. Vector==-1. (default=0) </td></tr>
    <tr><td class="paramname">type</td><td>If you are referring to a text column, use 't'. (default='d')</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A pointer to the page in the data set with the given factor names.</dd></dl>
<ul>
<li>This function uses the <a class="el" href="designated.html">Designated initializers</a> syntax for inputs. </li>
</ul>

</div>
</div>
<a class="anchor" id="ae0c28224e10f8aacdaa2d130f96f6ba2"></a><!-- doxytag: member="stats.h::apop_data_to_dummies" ref="ae0c28224e10f8aacdaa2d130f96f6ba2" args="(apop_data *d, int col, char type, int keep_first, char append, char remove)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__data.html">apop_data</a>* <a class="el" href="stats_8h.html#ae0c28224e10f8aacdaa2d130f96f6ba2">apop_data_to_dummies</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>keep_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>append</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>remove</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>A utility to make a matrix of dummy variables. You give me a single vector that lists the category number for each item, and I'll produce a matrix with a single one in each row in the column specified.</p>
<p>After that, you have to decide what to do with the new matrix and the original data column.</p>
<ul>
<li>You can manually join the dummy data set with your main data, e.g.: <div class="fragment"><pre class="fragment"><a class="code" href="structapop__data.html">apop_data</a> *dummies  = <a class="code" href="apop__regression_8c.html#ae0c28224e10f8aacdaa2d130f96f6ba2">apop_data_to_dummies</a>(main_regression_vars, .col=8, .type=<span class="charliteral">&#39;t&#39;</span>);
<a class="code" href="apop__data_8c.html#a0f2ffb5c5ba2bb240e930be08fc4fd56">apop_data_stack</a>(main_regression_vars, dummies, <span class="charliteral">&#39;c&#39;</span>, .inplace=<span class="charliteral">&#39;y&#39;</span>);
</pre></div></li>
</ul>
<ul>
<li>The <code>.remove='y'</code> option specifies that I should use <a class="el" href="types_8h.html#a1312f6568cfe832f1e35f7f44482ffb4">apop_data_rm_columns</a> to remove the column used to generate the dummies. Implemented only for <code>type=='d'</code>.</li>
</ul>
<ul>
<li>By specifying <code>.append='y'</code> or <code>.append='e'</code> I will run the above two lines for you. Your <a class="el" href="gentle.html#apop_data">apop_data</a> pointer will not change, but its <code>matrix</code> element will be reallocated (via <a class="el" href="types_8h.html#a0f2ffb5c5ba2bb240e930be08fc4fd56">apop_data_stack</a>).</li>
</ul>
<ul>
<li>By specifying <code>.append='i'</code>, I will place the matrix of dummies in place, immediately after the data column you had specified. You will probably use this with <code>.remove='y'</code> to replace the single column with the new set of dummy columns. Bear in mind that if there are two or more dummy columns (which there probably are if you are bothering to use this function), subsequent column numbers will change.</li>
</ul>
<ul>
<li>If <code>.append='i'</code> and you asked for a text column, I will append to the end of the table, which is equivalent to <code>append='e'</code>.</li>
</ul>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>The data set with the column to be dummified (No default.) </td></tr>
    <tr><td class="paramname">col</td><td>The column number to be transformed; -1==vector (default = 0) </td></tr>
    <tr><td class="paramname">type</td><td>'d'==data column, 't'==text column. (default = 't') </td></tr>
    <tr><td class="paramname">keep_first</td><td>if zero, return a matrix where each row has a one in the (column specified MINUS ONE). That is, the zeroth category is dropped, the first category has an entry in column zero, et cetera. If you don't know why this is useful, then this is what you need. If you know what you're doing and need something special, set this to one and the first category won't be dropped. (default = 0) </td></tr>
    <tr><td class="paramname">append</td><td>If <code>'e'</code> or <code>'y'</code>, append the dummy grid to the end of the original data matrix. If <code>'i'</code>, insert in place, immediately after the original data column. (default = <code>'n'</code>) </td></tr>
    <tr><td class="paramname">remove</td><td>If <code>'y'</code>, remove the original data or text column. (default = <code>'n'</code>)</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>An <a class="el" href="gentle.html#apop_data">apop_data</a> set whose <code>matrix</code> element is the one-zero matrix of dummies. If you used <code>.append</code>, then this is the main matrix. Also, I add a page named <code>"\&lt;categories for your_var\&gt;"</code> giving a reference table of names and column numbers (where <code>your_var</code> is the appropriate column heading). </dd></dl>
<dl class="exception"><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">out-&gt;error=='a'</td><td>allocation error </td></tr>
    <tr><td class="paramname">out-&gt;error=='d'</td><td>dimension error <ul>
<li>NaNs appear at the end of the sort order. </li>
<li>This function uses the <a class="el" href="designated.html">Designated initializers</a> syntax for inputs. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a27405bd5fdf48d93c8918ca4c07ee260"></a><!-- doxytag: member="stats.h::apop_data_to_factors" ref="a27405bd5fdf48d93c8918ca4c07ee260" args="(apop_data *data, char intype, int incol, int outcol)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__data.html">apop_data</a>* <a class="el" href="stats_8h.html#a27405bd5fdf48d93c8918ca4c07ee260">apop_data_to_factors</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>intype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>incol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>outcol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Convert a column of text or numbers into a column of numeric factors, which you can use for a multinomial probit/logit, for example.</p>
<p>If you don't run this on your data first, <a class="el" href="group__models.html#ga319b8e3d5025a6fc94829a978273eb8b">apop_probit</a> and <a class="el" href="group__models.html#gaa88a402cf7d02c25c4613a74ace1b0c1">apop_logit</a> default to running it on the vector or (if no vector) zeroth column of the matrix of the input <a class="el" href="gentle.html#apop_data">apop_data</a> set, because those models need a list of the unique values of the dependent variable.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The data set to be modified in place. (No default. If <code>NULL</code>, returns <code>NULL</code> and a warning) </td></tr>
    <tr><td class="paramname">intype</td><td>If <code>'t'</code>, then <code>incol</code> refers to text, otherwise (<code>'d'</code> is a good choice) refers to the vector or matrix. Default = <code>'t'</code>. </td></tr>
    <tr><td class="paramname">incol</td><td>The column in the text that will be converted. -1 is the vector. Default = 0. </td></tr>
    <tr><td class="paramname">outcol</td><td>The column in the data set where the numeric factors will be written (-1 means the vector). Default = 0.</td></tr>
  </table>
  </dd>
</dl>
<p>For example: </p>
<div class="fragment"><pre class="fragment"><a class="code" href="structapop__data.html">apop_data</a> *d  = <a class="code" href="group__queries.html#ga1f06db34e05b5afb63112f83ad2317b8">apop_query_to_mixed_data</a>(<span class="stringliteral">&quot;mmt&quot;</span>, <span class="stringliteral">&quot;select 1, year, color from data&quot;</span>);
<a class="code" href="apop__regression_8c.html#a27405bd5fdf48d93c8918ca4c07ee260">apop_data_to_factors</a>(d);
</pre></div><p> Notice that the query pulled a column of ones for the sake of saving room for the factors. It reads column zero of the text, and writes it to column zero of the matrix.</p>
<p>Another example: </p>
<div class="fragment"><pre class="fragment"><a class="code" href="structapop__data.html">apop_data</a> *d  = <a class="code" href="group__queries.html#gade862993166c6482f53562fb77721db9">apop_query_to_data</a>(<span class="stringliteral">&quot;mmt&quot;</span>, <span class="stringliteral">&quot;select type, year from data&quot;</span>);
<a class="code" href="apop__regression_8c.html#a27405bd5fdf48d93c8918ca4c07ee260">apop_data_to_factors</a>(d, .intype=<span class="charliteral">&#39;d&#39;</span>, .incol=0, .outcol=0);
</pre></div><p> Here, the <code>type</code> column is converted to sequential integer factors and those factors overwrite the original data. Since a reference table is added as a second page of the <a class="el" href="gentle.html#apop_data">apop_data</a> set, you can recover the original values as needed.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A table of the factors used in the code. This is an <code><a class="el" href="structapop__data.html">apop_data</a></code> set with only one column of text. Also, I add a page named <code>"&lt;categories for your_var&gt;"</code> giving a reference table of names and column numbers (where <code>your_var</code> is the appropriate column heading) use <a class="el" href="stats_8h.html#adec9170cf1382f6cd549a5819472eb51">apop_data_get_factor_names</a> to retrieve that table.</dd></dl>
<dl class="exception"><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">out-&gt;error=='a'</td><td>allocation error. </td></tr>
    <tr><td class="paramname">out-&gt;error=='d'</td><td>dimension error. <ul>
<li>If the vector or matrix you wanted to write to is <code>NULL</code>, I will allocate it for you. </li>
<li>This function uses the <a class="el" href="designated.html">Designated initializers</a> syntax for inputs. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae165633525c5272ab83794b60076eddc"></a><!-- doxytag: member="stats.h::apop_estimate_parameter_tests" ref="ae165633525c5272ab83794b60076eddc" args="(apop_model *est)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="stats_8h.html#ae165633525c5272ab83794b60076eddc">apop_estimate_parameter_tests</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__model.html">apop_model</a> *&#160;</td>
          <td class="paramname"><em>est</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>For many, it is a knee-jerk reaction to a parameter estimation to test whether each individual parameter differs from zero. This function does that.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">est</td><td>The <a class="el" href="group__models.html#ga0a3be4075a89f7119be95a4718e01ade">apop_estimate</a>, which includes pre-calculated parameter estimates, var-covar matrix, and the original data set.</td></tr>
  </table>
  </dd>
</dl>
<p>Returns nothing. At the end of the routine, <code>est-&gt;info-&gt;more</code> includes a set of t-test values: p value, confidence (=1-pval), t statistic, standard deviation, one-tailed Pval, one-tailed confidence. </p>

</div>
</div>
<a class="anchor" id="a1902b3fd6a6682d1453a80b788e44ebb"></a><!-- doxytag: member="stats.h::apop_f_test" ref="a1902b3fd6a6682d1453a80b788e44ebb" args="(apop_model *est, apop_data *contrast)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__data.html">apop_data</a>* <a class="el" href="stats_8h.html#a1902b3fd6a6682d1453a80b788e44ebb">apop_f_test</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__model.html">apop_model</a> *&#160;</td>
          <td class="paramname"><em>est</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>contrast</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Runs an F-test specified by <code>q</code> and <code>c</code>. Your best bet is to see the chapter on hypothesis testing in <a href="http://modelingwithdata.org">Modeling With Data</a>, p 309. It will tell you that: </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[{N-K\over q} {({\bf Q}'\hat\beta - {\bf c})' [{\bf Q}' ({\bf X}'{\bf X})^{-1} {\bf Q}]^{-1} ({\bf Q}' \hat\beta - {\bf c}) \over {\bf u}' {\bf u} } \sim F_{q,N-K},\]" src="form_74.png"/>
</p>
<p> and that's what this function is based on.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">est</td><td>an <a class="el" href="structapop__model.html">apop_model</a> that you have already calculated. (No default) </td></tr>
    <tr><td class="paramname">contrast</td><td>The matrix <img class="formulaInl" alt="${\bf Q}$" src="form_75.png"/> and the vector <img class="formulaInl" alt="${\bf c}$" src="form_76.png"/>, where each row represents a hypothesis. (Defaults: if matrix is <code>NULL</code>, it is set to the identity matrix with the top row missing. If the vector is <code>NULL</code>, it is set to a zero matrix of length equal to the height of the contrast matrix. Thus, if the entire <code><a class="el" href="structapop__data.html">apop_data</a></code> set is NULL or omitted, we are testing the hypothesis that all but <img class="formulaInl" alt="$\beta_1$" src="form_77.png"/> are zero.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>An <code><a class="el" href="structapop__data.html">apop_data</a></code> set with a few variants on the confidence with which we can reject the joint hypothesis. </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000005">Todo:</a></b></dt><dd>There should be a way to get OLS and GLS to store <img class="formulaInl" alt="$(X'X)^{-1}$" src="form_78.png"/>. In fact, if you did GLS, this is invalid, because you need <img class="formulaInl" alt="$(X'\Sigma X)^{-1}$" src="form_79.png"/>, and I didn't ask for <img class="formulaInl" alt="$\Sigma$" src="form_80.png"/>.</dd></dl>
<ul>
<li>There are two approaches to an <img class="formulaInl" alt="$F$" src="form_68.png"/>-test: the ANOVA approach, which is typically built around the claim that all effects but the mean are zero; and the more general regression form, which allows for any set of linear claims about the data. If you send a <code>NULL</code> contrast set, I will generate the set of linear contrasts that are equivalent to the ANOVA-type approach. Readers of {<em>Modeling</em> with Data}, note that there's a bug in the book that claims that the traditional ANOVA approach also checks that the coefficient for the constant term is also zero; this is not the custom and doesn't produce the equivalence presented in that and other textbooks.</li>
</ul>
<dl class="exception"><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">out-&gt;error='a'</td><td>Allocation error. </td></tr>
    <tr><td class="paramname">out-&gt;error='d'</td><td>dimension-matching error. </td></tr>
    <tr><td class="paramname">out-&gt;error='i'</td><td>matrix inversion error. </td></tr>
    <tr><td class="paramname">out-&gt;error='m'</td><td>GSL math error. <ul>
<li>This function uses the <a class="el" href="designated.html">Designated initializers</a> syntax for inputs. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a95162a0f5c4879201bfd5bb98d20f7b2"></a><!-- doxytag: member="stats.h::apop_jackknife_cov" ref="a95162a0f5c4879201bfd5bb98d20f7b2" args="(apop_data *data, apop_model model)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__data.html">apop_data</a>* <a class="el" href="stats_8h.html#a95162a0f5c4879201bfd5bb98d20f7b2">apop_jackknife_cov</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structapop__model.html">apop_model</a>&#160;</td>
          <td class="paramname"><em>model</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Give me a data set and a model, and I'll give you the jackknifed covariance matrix of the model parameters.</p>
<p>The basic algorithm for the jackknife (with many details glossed over): create a sequence of data sets, each with exactly one observation removed, and then produce a new set of parameter estimates using that slightly shortened data set. Then, find the covariance matrix of the derived parameters.</p>
<p>Jackknife or bootstrap? As a broad rule of thumb, the jackknife works best on models that are closer to linear. The worse a linear approximation does (at the given data), the worse the jackknife approximates the variance.</p>
<p>Sample usage: </p>
<div class="fragment"><pre class="fragment"><a class="code" href="group__output.html#ga9a30c437ec11a11e37e0db7f82386275">apop_data_show</a>(<a class="code" href="apop__bootstrap_8c.html#a00aea2894284560e88b5fcce9f100242">apop_jackknife_cov</a>(your_data, your_model));
</pre></div><dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>The data set. An <a class="el" href="gentle.html#apop_data">apop_data</a> set where each row is a single data point. </td></tr>
    <tr><td class="paramname">model</td><td>An <a class="el" href="structapop__model.html">apop_model</a>, that will be used internally by <a class="el" href="group__models.html#ga0a3be4075a89f7119be95a4718e01ade">apop_estimate</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">out-&gt;error=='n'</td><td><code>NULL</code> input data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>An <code><a class="el" href="structapop__data.html">apop_data</a></code> set whose matrix element is the estimated covariance matrix of the parameters. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="stats_8h.html#aed343e0e790bd7e1fd1e455d23e394b2">apop_bootstrap_cov</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a4489b3994f099ed40ccd77df6143728e"></a><!-- doxytag: member="stats.h::apop_kl_divergence" ref="a4489b3994f099ed40ccd77df6143728e" args="(apop_model *top, apop_model *bottom, int draw_ct, gsl_rng *rng)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="stats_8h.html#a4489b3994f099ed40ccd77df6143728e">apop_kl_divergence</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__model.html">apop_model</a> *&#160;</td>
          <td class="paramname"><em>top</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structapop__model.html">apop_model</a> *&#160;</td>
          <td class="paramname"><em>bottom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>draw_ct</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsl_rng *&#160;</td>
          <td class="paramname"><em>rng</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Kullback-Leibler divergence.</p>
<p>This measure of the divergence of one distribution from another has the form <img class="formulaInl" alt="$ D(p,q) = \sum_i \ln(p_i/q_i) p_i $" src="form_62.png"/>. Notice that it is not a distance, because there is an asymmetry between <img class="formulaInl" alt="$p$" src="form_20.png"/> and <img class="formulaInl" alt="$q$" src="form_63.png"/>, so one can expect that <img class="formulaInl" alt="$D(p, q) \neq D(q, p)$" src="form_64.png"/>.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">top</td><td>the <img class="formulaInl" alt="$p$" src="form_20.png"/> in the above formula. (No default; must not be <code>NULL</code>) </td></tr>
    <tr><td class="paramname">bottom</td><td>the <img class="formulaInl" alt="$q$" src="form_63.png"/> in the above formula. (No default; must not be <code>NULL</code>) </td></tr>
    <tr><td class="paramname">draw_ct</td><td>If I do the calculation via random draws, how many? (Default = 1e5) </td></tr>
    <tr><td class="paramname">rng</td><td>A <code>gsl_rng</code>. If NULL, I'll take care of the RNG; see <a class="el" href="autorng.html">Auto-allocated RNGs</a>. (Default = <code>NULL</code>)</td></tr>
  </table>
  </dd>
</dl>
<p>This function can take empirical histogram-type models---<a class="el" href="group__models.html#gaca8f3323c57e0223a9f3c0f991c9760e">apop_pmf</a> and <a class="el" href="group__models.html#gafa54b2573ed0868774a9a78d07d07e62">apop_histogram</a> ---or continuous models like <a class="el" href="group__models.html#gaf7d01cc4076c9319036a0cce882dac62">apop_loess</a> or <a class="el" href="group__models.html#ga297c2dc8dbdf4ae93fc7e10860400466">apop_normal</a>.</p>
<p>If there is an empirical model (I'll try <code>top</code> first, under the presumption that you are measuring the divergence of data from a `true' distribution), then I'll step through it for the points in the summation.</p>
<ul>
<li>If you have two empirical distributions, that they must be synced: if <img class="formulaInl" alt="$p_i>0$" src="form_65.png"/> but <img class="formulaInl" alt="$q_i=0$" src="form_66.png"/>, then the function returns <code>GSL_NEGINF</code>. If <code>apop_opts.verbose &gt;=1</code> I print a message as well.</li>
</ul>
<p>If neither distribution is empirical, then I'll take <code>draw_ct</code> random draws from <code>bottom</code> and evaluate at those points.</p>
<ul>
<li>Set <code>apop_opts.verbose = 3</code> for observation-by-observation info.</li>
</ul>
<p>This function uses the <a class="el" href="designated.html">Designated initializers</a> syntax for inputs. </p>

</div>
</div>
<a class="anchor" id="a1db15d25579048bcc36b5aabdf9dfd65"></a><!-- doxytag: member="stats.h::apop_linear_constraint" ref="a1db15d25579048bcc36b5aabdf9dfd65" args="(gsl_vector *beta, apop_data *constraint, double margin)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="stats_8h.html#a1db15d25579048bcc36b5aabdf9dfd65">apop_linear_constraint</a> </td>
          <td>(</td>
          <td class="paramtype">gsl_vector *&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>constraint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>margin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This is designed to be called from within the constraint method of your <a class="el" href="structapop__model.html">apop_model</a>. Just write the constraint vector+matrix and this will do the rest.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">beta</td><td>The proposed vector about to be tested. No default, must not be <code>NULL</code>.</td></tr>
    <tr><td class="paramname">constraint</td><td>See the outline page for detailed discussion on setting contrasts. To give a quick example, say your constraint is <img class="formulaInl" alt="$3 < 2x + 4y - 7z$" src="form_25.png"/>; then the first row of your <code>data-&gt;vector</code> element would be 3, and the first row of the <code>data-&gt;matrix</code> element would be [2 4 -7]. Default: each elements is greater than zero</td></tr>
    <tr><td class="paramname">margin</td><td>If zero, then this is a &gt;= constraint, otherwise I will return a point this amount within the borders. You could try <code>GSL_DBL_EPSILON</code>, which is the smallest value a <code>double</code> can hold, or something like 1e-3. Default = 0.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The penalty = the distance between beta and the closest point that meets the constraints. If the constraint is not met, this <code>beta</code> is shifted by <code>margin</code> (Euclidean distance) to meet the constraints.</dd></dl>
<ul>
<li>This function uses the <a class="el" href="designated.html">Designated initializers</a> syntax for inputs. <dl class="todo"><dt><b><a class="el" href="todo.html#_todo000001">Todo:</a></b></dt><dd>The apop_linear_constraint function doesn't check for odd cases like coplanar constraints. </dd></dl>
</li>
</ul>

</div>
</div>
<a class="anchor" id="a46a40bc32015eb68e605835d82c3134b"></a><!-- doxytag: member="stats.h::apop_matrix_correlation" ref="a46a40bc32015eb68e605835d82c3134b" args="(gsl_matrix *in, const char normalize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gsl_matrix* <a class="el" href="stats_8h.html#a46a40bc32015eb68e605835d82c3134b">apop_matrix_correlation</a> </td>
          <td>(</td>
          <td class="paramtype">gsl_matrix *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>normalize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the matrix of correlation coefficients <img class="formulaInl" alt="$(\sigma^2_{xy}/(\sigma_x\sigma_y))$" src="form_61.png"/> relating each column with each other.</p>
<p>This is the <code>gsl_matrix</code> version of <a class="el" href="stats_8h.html#afa3ab967f57f8ad3cfb99a4a82cfae02">apop_data_correlation</a>; if you have column names, use that one.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>A data matrix: rows are observations, columns are variables. (No default, must not be <code>NULL</code>) </td></tr>
    <tr><td class="paramname">normalize</td><td>'n' or 'N' = subtract the mean from each column, thus changing the input data but speeding up the computation.<br/>
 anything else (like 0)= don't modify the input data (default = no modification)</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns the variance/covariance matrix relating each column with each other. This function allocates the matrix for you.</dd></dl>
<p>This function uses the <a class="el" href="designated.html">Designated initializers</a> syntax for inputs. </p>

</div>
</div>
<a class="anchor" id="a8ab4dde598ac3710072eb58384512153"></a><!-- doxytag: member="stats.h::apop_matrix_covariance" ref="a8ab4dde598ac3710072eb58384512153" args="(gsl_matrix *in, const char normalize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gsl_matrix* <a class="el" href="stats_8h.html#a8ab4dde598ac3710072eb58384512153">apop_matrix_covariance</a> </td>
          <td>(</td>
          <td class="paramtype">gsl_matrix *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>normalize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the variance/covariance matrix relating each column with each other.</p>
<p>This is the <code>gsl_matrix</code> version of <a class="el" href="stats_8h.html#aeae37a5bf11cddee59e272b083a4efc7">apop_data_covariance</a>; if you have column names, use that one.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>A data matrix: rows are observations, columns are variables. (No default, must not be <code>NULL</code>) </td></tr>
    <tr><td class="paramname">normalize</td><td>'n', 'N', or 1 = subtract the mean from each column, thus changing the input data but speeding up the computation.<br/>
 anything else (like 0)= don't modify the input data (default = no modification)</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns the variance/covariance matrix relating each column with each other. This function allocates the matrix for you. This is the sample version---dividing by <img class="formulaInl" alt="$n-1$" src="form_47.png"/>, not <img class="formulaInl" alt="$n$" src="form_8.png"/>. It uses the <a class="el" href="designated.html">Designated initializers</a> syntax for inputs. </dd></dl>

</div>
</div>
<a class="anchor" id="afc7707d44884aa63c298510a0662956a"></a><!-- doxytag: member="stats.h::apop_matrix_is_positive_semidefinite" ref="afc7707d44884aa63c298510a0662956a" args="(gsl_matrix *m, char semi)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="stats_8h.html#afc7707d44884aa63c298510a0662956a">apop_matrix_is_positive_semidefinite</a> </td>
          <td>(</td>
          <td class="paramtype">gsl_matrix *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>semi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Test whether the input matrix is positive semidefinite.</p>
<p>A covariance matrix will always be PSD, so this function can tell you whether your matrix is a valid covariance matrix.</p>
<p>Consider the 1x1 matrix in the upper left of the input, then the 2x2 matrix in the upper left, on up to the full matrix. If the matrix is PSD, then each of these has a positive determinant. This function thus calculates <img class="formulaInl" alt="$N$" src="form_3.png"/> determinants for an <img class="formulaInl" alt="$N$" src="form_3.png"/>x <img class="formulaInl" alt="$N$" src="form_3.png"/> matrix.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The matrix to test. If <code>NULL</code>, I will return zero---not PSD. </td></tr>
    <tr><td class="paramname">semi</td><td>If anything but 's', check for positive definite, not semidefinite. (default 's')</td></tr>
  </table>
  </dd>
</dl>
<p>See also <a class="el" href="stats_8h.html#af1fc93322ffcb4e20cfc0b9af9e2aea0">apop_matrix_to_positive_semidefinite</a>, which will change the input to something PSD.</p>
<p>This function uses the <a class="el" href="designated.html">Designated initializers</a> syntax for inputs. </p>

</div>
</div>
<a class="anchor" id="af6290c453c3012c1d0a6987688ebe795"></a><!-- doxytag: member="stats.h::apop_matrix_normalize" ref="af6290c453c3012c1d0a6987688ebe795" args="(gsl_matrix *data, const char row_or_col, const char normalization)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="stats_8h.html#af6290c453c3012c1d0a6987688ebe795">apop_matrix_normalize</a> </td>
          <td>(</td>
          <td class="paramtype">gsl_matrix *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>row_or_col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>normalization</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Normalize each row or column in the given matrix, one by one.</p>
<p>Basically just a convenience fn to iterate through the columns or rows and run <a class="el" href="stats_8h.html#a194ad92b1bc632ba1d13d9958c7b5b4d">apop_vector_normalize</a> for you.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The data set to normalize. </td></tr>
    <tr><td class="paramname">row_or_col</td><td>Either 'r' or 'c'. </td></tr>
    <tr><td class="paramname">normalization</td><td>see <a class="el" href="stats_8h.html#a194ad92b1bc632ba1d13d9958c7b5b4d">apop_vector_normalize</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5402b8254a90f2ac68770d6867502e5a"></a><!-- doxytag: member="stats.h::apop_matrix_rm_columns" ref="a5402b8254a90f2ac68770d6867502e5a" args="(gsl_matrix *in, int *drop)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gsl_matrix* <a class="el" href="stats_8h.html#a5402b8254a90f2ac68770d6867502e5a">apop_matrix_rm_columns</a> </td>
          <td>(</td>
          <td class="paramtype">gsl_matrix *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>drop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Delete columns from a matrix.</p>
<p>This is done via copying, so if you have an exceptionally large data set, you're better off producing the matrix in the perfect form directly.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>the <code>gsl_matrix</code> to be subsetted </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a <code>gsl_matrix</code> with the specified columns removed. If you ask me to remove no columns, I'll return a copy of the original. If you ask me to remove all columns, I'll return <code>NULL</code>. </dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">drop</td><td>an array of <code>int</code>s. If use[7]==1, then column seven will be cut from the output. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af1fc93322ffcb4e20cfc0b9af9e2aea0"></a><!-- doxytag: member="stats.h::apop_matrix_to_positive_semidefinite" ref="af1fc93322ffcb4e20cfc0b9af9e2aea0" args="(gsl_matrix *m)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="stats_8h.html#af1fc93322ffcb4e20cfc0b9af9e2aea0">apop_matrix_to_positive_semidefinite</a> </td>
          <td>(</td>
          <td class="paramtype">gsl_matrix *&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>First, this function passes tests, but is under development.</p>
<p>It takes in a matrix and converts it to the `closest' positive semidefinite matrix.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>On input, any matrix; on output, a positive semidefinite matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the distance between the original and new matrices.</dd></dl>
<ul>
<li>See also the test function <a class="el" href="stats_8h.html#afc7707d44884aa63c298510a0662956a">apop_matrix_is_positive_semidefinite</a>. </li>
<li>This function can be used as (the core of) a model constraint.</li>
</ul>
<p>Adapted from the R Matrix package's nearPD, which is Copyright (2007) Jens Oehlschlgel [and is GPL]. </p>

</div>
</div>
<a class="anchor" id="ab4f6ca7e042ac7c09c3c01d29702a739"></a><!-- doxytag: member="stats.h::apop_model_fix_params" ref="ab4f6ca7e042ac7c09c3c01d29702a739" args="(apop_model *model_in)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__model.html">apop_model</a>* <a class="el" href="stats_8h.html#ab4f6ca7e042ac7c09c3c01d29702a739">apop_model_fix_params</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__model.html">apop_model</a> *&#160;</td>
          <td class="paramname"><em>model_in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Produce a model based on another model, but with some of the parameters fixed at a given value.</p>
<p>You will send me the model whose parameters you want fixed, with the <code>parameters</code> element set as follows. For the fixed parameters, simply give the values to which they will be fixed. Set the free parameters to <code>NaN</code>.</p>
<p>For example, here is a Binomial distribution with a fixed <img class="formulaInl" alt="$n=30$" src="form_16.png"/> but <img class="formulaInl" alt="$p_1$" src="form_17.png"/> allowed to float freely:</p>
<div class="fragment"><pre class="fragment">    <a class="code" href="structapop__model.html">apop_model</a> *bi30 = <a class="code" href="apop__fix__params_8c.html#ab4f6ca7e042ac7c09c3c01d29702a739">apop_model_fix_params</a>(<a class="code" href="group__models.html#ga36cae46a2950eb6cfb65794cdd5dac7e">apop_model_set_parameters</a>(<a class="code" href="group__models.html#ga20017e88fda3695f093279c8191f48e3">apop_binomial</a>, 30, GSL_NAN));
    <a class="code" href="group__settings.html#ga553b02de4ace5e6f16a8b26da777f9b9">Apop_model_add_group</a>(bi30, apop_mle, .starting_pt=(<span class="keywordtype">double</span>[]){.5}); <span class="comment">// The Binomial doesn&#39;t like the default </span>
                                                                       <span class="comment">// starting point of 1.</span>
    <a class="code" href="structapop__model.html">apop_model</a> *out = <a class="code" href="group__models.html#ga0a3be4075a89f7119be95a4718e01ade">apop_estimate</a>(your_data, bi30);
</pre></div><p>The output is an <code><a class="el" href="structapop__model.html">apop_model</a></code> that can be estimated, Bayesian updated, et cetera.</p>
<ul>
<li>The <code>estimate</code> method always uses an MLE, and it never calls the base model's <code>estimate</code> method.</li>
</ul>
<ul>
<li>If the input model has MLE-style settings attached, I'll use them for the <code>estimate</code> method. Otherwise, I'll set my own.</li>
</ul>
<ul>
<li>If the parameter input has non-NaN values at the free parameters, then I'll use those as the starting point for any search; else the defaults start from <b>1</b> as usual.</li>
</ul>
<ul>
<li>I do check the <code>more</code> pointer of the <code>parameters</code> for additional pages and <code>NaN</code>s on those pages.</li>
</ul>
<p>Here is a sample program. It produces a few thousand draws from a Multivariate Normal distribution, and then tries to recover the means given a var/covar matrix fixed at the correct variance.</p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &lt;apop.h&gt;</span>

<span class="keywordtype">int</span> main(){
    gsl_rng *r    = <a class="code" href="group__convenience__fns.html#gada044cf02135422a9f9292b6054c86dd">apop_rng_alloc</a>(10);
    <span class="keywordtype">size_t</span> i, ct = 5e4;

    <span class="comment">//set up the model &amp; params</span>
    <a class="code" href="structapop__data.html">apop_data</a> *d  = <a class="code" href="apop__data_8c.html#ac39d6a56933b6f084328ec5ecd5090d8">apop_data_alloc</a>(ct,2);
    <a class="code" href="structapop__data.html">apop_data</a> *params = <a class="code" href="apop__data_8c.html#ac39d6a56933b6f084328ec5ecd5090d8">apop_data_alloc</a>(2,2,2);
    <a class="code" href="types_8h.html#a4ed914f400ade913970ebbe698176218">apop_data_fill</a>(params, 8,  1, 0.5,
                           2,  0.5, 1);
    <a class="code" href="structapop__model.html">apop_model</a> *pvm = <a class="code" href="group__models.html#ga14f2bd54421fd6629baccb8a41ecd304">apop_model_copy</a>(<a class="code" href="group__models.html#ga3a4389e6e2a1a2ea606f89d55ec558d3">apop_multivariate_normal</a>);
    pvm-&gt;<a class="code" href="structapop__model.html#ae016a9e13725e84a1188bc81c8f09e45">parameters</a> = <a class="code" href="apop__data_8c.html#add67e6838ce2521a1d756894dc9b5ccf">apop_data_copy</a>(params);

    <span class="comment">//make random draws from the multivar. normal</span>
    <span class="comment">//this `pull a row view, fill its data element&#39; form works for rows but not cols.</span>
    <span class="keywordflow">for</span>(i=0; i&lt; ct; i++){
        <a class="code" href="stats_8h.html#a74dd4339556eb22240d21d19f1ad6dc8">Apop_row</a>(d, i, onerow);
        <a class="code" href="group__models.html#gaca737ed521192a76a307bbf825ab4a97">apop_draw</a>(onerow-&gt;data, r, pvm);
    }

    <span class="comment">//set up and estimate a model with fixed covariance matrix but free means</span>
    gsl_vector_set_all(pvm-&gt;<a class="code" href="structapop__model.html#ae016a9e13725e84a1188bc81c8f09e45">parameters</a>-&gt;vector, GSL_NAN);
    <a class="code" href="structapop__model.html">apop_model</a> *mep1   = <a class="code" href="apop__fix__params_8c.html#ab4f6ca7e042ac7c09c3c01d29702a739">apop_model_fix_params</a>(pvm);
    <a class="code" href="structapop__model.html">apop_model</a> *e1  = <a class="code" href="group__models.html#ga0a3be4075a89f7119be95a4718e01ade">apop_estimate</a>(d, *mep1);
    
    <span class="comment">//compare results</span>
    printf(<span class="stringliteral">&quot;original params: &quot;</span>);
    <a class="code" href="group__apop__print.html#ga8eafc3727869f5ec195809ad6686ba7b">apop_vector_show</a>(params-&gt;vector);
    printf(<span class="stringliteral">&quot;estimated params: &quot;</span>);
    <a class="code" href="group__apop__print.html#ga8eafc3727869f5ec195809ad6686ba7b">apop_vector_show</a>(e1-&gt;<a class="code" href="structapop__model.html#ae016a9e13725e84a1188bc81c8f09e45">parameters</a>-&gt;vector);
    <span class="keywordflow">return</span> 0;
}
</pre></div><dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">model_in</td><td>The base model </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a model that can be used like any other, with the given params fixed or free. </dd></dl>

</div>
</div>
<a class="anchor" id="a1a55a20880947e289767aad6e5b0117c"></a><!-- doxytag: member="stats.h::apop_model_hessian" ref="a1a55a20880947e289767aad6e5b0117c" args="(apop_data *data, apop_model *model, double delta)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__data.html">apop_data</a>* <a class="el" href="stats_8h.html#a1a55a20880947e289767aad6e5b0117c">apop_model_hessian</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structapop__model.html">apop_model</a> *&#160;</td>
          <td class="paramname"><em>model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>delta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Numerically estimate the matrix of second derivatives of the parameter values. The math is simply a series of re-evaluations at small differential steps. [Therefore, it may be expensive to do this for a very computationally-intensive model.]</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The data at which the model was estimated </td></tr>
    <tr><td class="paramname">model</td><td>The model, with parameters already estimated </td></tr>
    <tr><td class="paramname">delta</td><td>the step size for the differentials. The current default is around 1e-3. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The matrix of estimated second derivatives at the given data and parameter values.</dd></dl>
<ul>
<li>This function uses the <a class="el" href="designated.html">Designated initializers</a> syntax for inputs. </li>
</ul>

</div>
</div>
<a class="anchor" id="a0f2784b69175d1ecd3833d228d2294e7"></a><!-- doxytag: member="stats.h::apop_model_numerical_covariance" ref="a0f2784b69175d1ecd3833d228d2294e7" args="(apop_data *data, apop_model *model, double delta)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__data.html">apop_data</a>* <a class="el" href="stats_8h.html#a0f2784b69175d1ecd3833d228d2294e7">apop_model_numerical_covariance</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structapop__model.html">apop_model</a> *&#160;</td>
          <td class="paramname"><em>model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>delta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Produce the covariance matrix for the parameters of an estimated model via the derivative of the score function at the parameter. I.e., I find the second derivative via <a class="el" href="stats_8h.html#a1a55a20880947e289767aad6e5b0117c">apop_model_hessian</a> , and take the negation of the inverse.</p>
<p>I follow Efron and Hinkley in using the estimated information matrix---the value of the information matrix at the estimated value of the score---not the expected information matrix that is the integral over all possible data. See Pawitan 2001 (who cribbed a little off of Efron and Hinkley) or Klemens 2008 (who directly cribbed off of both) for further details.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The data by which your model was estimated </td></tr>
    <tr><td class="paramname">model</td><td>A model whose parameters have been estimated. </td></tr>
    <tr><td class="paramname">delta</td><td>The differential by which to step for sampling changes. (default currently = 1e-3) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A covariance matrix for the data. Also, if the data does not have a <code>"Covariance"</code> page, I'll set it to the result as well [i.e., I won't overwrite an existing covar].</dd></dl>
<p>This function uses the <a class="el" href="designated.html">Designated initializers</a> syntax for inputs. </p>

</div>
</div>
<a class="anchor" id="a463920325a6102396515d80e57e6c519"></a><!-- doxytag: member="stats.h::apop_multivariate_gamma" ref="a463920325a6102396515d80e57e6c519" args="(double a, double p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="stats_8h.html#a463920325a6102396515d80e57e6c519">apop_multivariate_gamma</a> </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The multivariate generalization of the Gamma distribution. </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \Gamma_p(a)= \pi^{p(p-1)/4}\prod_{j=1}^p \Gamma\left[ a+(1-j)/2\right]. \]" src="form_69.png"/>
</p>
<p>Because <img class="formulaInl" alt="$\Gamma(x)$" src="form_70.png"/> is undefined for <img class="formulaInl" alt="$x\in\{0, -1, -2, ...\}$" src="form_71.png"/>, this function returns <code>GSL_NAN</code> when <img class="formulaInl" alt="$a+(1-j)/2$" src="form_72.png"/> takes on one of those values.</p>
<p>See also <a class="el" href="stats_8h.html#a565a9c7bf2cb5b171cf0fce622d54bca">apop_multivariate_lngamma</a>, which is more numerically stable in most cases. </p>

</div>
</div>
<a class="anchor" id="a565a9c7bf2cb5b171cf0fce622d54bca"></a><!-- doxytag: member="stats.h::apop_multivariate_lngamma" ref="a565a9c7bf2cb5b171cf0fce622d54bca" args="(double a, double p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="stats_8h.html#a565a9c7bf2cb5b171cf0fce622d54bca">apop_multivariate_lngamma</a> </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The log of the multivariate generalization of the Gamma; see also <a class="el" href="stats_8h.html#a463920325a6102396515d80e57e6c519">apop_multivariate_gamma</a>. </p>

</div>
</div>
<a class="anchor" id="aaf0d5d65f514d9894a4ca5b0e8755873"></a><!-- doxytag: member="stats.h::apop_rng_GHgB3" ref="aaf0d5d65f514d9894a4ca5b0e8755873" args="(gsl_rng *r, double *a)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="stats_8h.html#aaf0d5d65f514d9894a4ca5b0e8755873">apop_rng_GHgB3</a> </td>
          <td>(</td>
          <td class="paramtype">gsl_rng *&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>RNG from a Generalized Hypergeometric type B3.</p>
<p>Devroye uses this as the base for many of his distribution-generators, including the Waring.</p>
<ul>
<li>If one of the inputs is &lt;=0, error. Returns <code>GSL_NAN</code> if the function doesn't stop. </li>
</ul>

</div>
</div>
<a class="anchor" id="a8627a1eebf904699e90e66adc8b4b021"></a><!-- doxytag: member="stats.h::apop_test_fisher_exact" ref="a8627a1eebf904699e90e66adc8b4b021" args="(apop_data *intab)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__data.html">apop_data</a>* <a class="el" href="stats_8h.html#a8627a1eebf904699e90e66adc8b4b021">apop_test_fisher_exact</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>intab</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Run the Fisher exact test on an input contingency table.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>An <a class="el" href="gentle.html#apop_data">apop_data</a> set with two rows:<br/>
 "probability of table": Probability of the observed table for fixed marginal totals. <br/>
 "p value": Table p-value. The probability of a more extreme table, where `extreme' is in a probabilistic sense. </dd></dl>
<dl class="exception"><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">out-&gt;error=='p'</td><td>Processing error in the test.</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>If there are processing errors, these values will be NaN. For example:</li>
</ul>
<div class="fragment"><pre class="fragment"><span class="keywordtype">void</span> test_fisher() {
    <span class="comment">/* This test is thanks to Nick Eriksson, who sent it to me in the form of a bug report. */</span>
    <span class="keywordtype">double</span> data[] = { 30, 50, 45, 34, 12,17 };
    <a class="code" href="structapop__data.html">apop_data</a> * testdata = <a class="code" href="group__conversions.html#gac92b5b4d0e985bcca2e6df1835195743">apop_line_to_data</a>(data,0,2,3);
    <a class="code" href="structapop__data.html">apop_data</a> * t2 = <a class="code" href="apop__fexact_8c.html#a8627a1eebf904699e90e66adc8b4b021">apop_test_fisher_exact</a>(testdata);
    assert(fabs(<a class="code" href="group__data__set__get.html#gae3c2f0d4bd96555e8eeb32a44511d0ac">apop_data_get</a>(t2,1) - 0.0001761) &lt; 1e-6);
}
</pre></div> 
</div>
</div>
<a class="anchor" id="a77c937ea4764d3da2ed9968273fa4544"></a><!-- doxytag: member="stats.h::apop_text_unique_elements" ref="a77c937ea4764d3da2ed9968273fa4544" args="(const apop_data *d, size_t col)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__data.html">apop_data</a>* <a class="el" href="stats_8h.html#a77c937ea4764d3da2ed9968273fa4544">apop_text_unique_elements</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>col</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Give me a column of text, and I'll give you a sorted list of the unique elements. This is basically running "select distinct * from datacolumn", but without the aid of the database.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>An <a class="el" href="gentle.html#apop_data">apop_data</a> set with a text component </td></tr>
    <tr><td class="paramname">col</td><td>The text column you want me to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>An <a class="el" href="gentle.html#apop_data">apop_data</a> set with a single sorted column of text, where each unique text input appears once. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="stats_8h.html#a6d68bacc086420a382366f9118cf5bc7">apop_vector_unique_elements</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a194ad92b1bc632ba1d13d9958c7b5b4d"></a><!-- doxytag: member="stats.h::apop_vector_normalize" ref="a194ad92b1bc632ba1d13d9958c7b5b4d" args="(gsl_vector *in, gsl_vector **out, const char normalization_type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="stats_8h.html#a194ad92b1bc632ba1d13d9958c7b5b4d">apop_vector_normalize</a> </td>
          <td>(</td>
          <td class="paramtype">gsl_vector *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsl_vector **&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>normalization_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function will normalize a vector, either such that it has mean zero and variance one, or such that it ranges between zero and one, or sums to one.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>A gsl_vector which you have already allocated and filled. <code>NULL</code> input gives <code>NULL</code> output. (No default)</td></tr>
    <tr><td class="paramname">out</td><td>If normalizing in place, <code>NULL</code>. If not, the address of a <code>gsl_vector</code>. Do not allocate. (default = <code>NULL</code>.)</td></tr>
    <tr><td class="paramname">normalization_type</td><td>'p': normalized vector will sum to one. E.g., start with a set of observations in bins, end with the percentage of observations in each bin. (the default)<br/>
 'r': normalized vector will range between zero and one. Replace each X with (X-min) / (max - min).<br/>
 's': normalized vector will have mean zero and variance one. Replace each X with <img class="formulaInl" alt="$(X-\mu) / \sigma$" src="form_58.png"/>, where <img class="formulaInl" alt="$\sigma$" src="form_59.png"/> is the sample standard deviation.<br/>
 'm': normalize to mean zero: Replace each X with <img class="formulaInl" alt="$(X-\mu)$" src="form_60.png"/><br/>
</td></tr>
  </table>
  </dd>
</dl>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &lt;apop.h&gt;</span>

<span class="keywordtype">int</span> main(<span class="keywordtype">void</span>){
gsl_vector  *in, *out;

in = gsl_vector_calloc(3);
gsl_vector_set(in, 1, 1);
gsl_vector_set(in, 2, 2);

printf(<span class="stringliteral">&quot;The original vector:\n&quot;</span>);
<a class="code" href="group__apop__print.html#ga8eafc3727869f5ec195809ad6686ba7b">apop_vector_show</a>(in);

<a class="code" href="apop__stats_8c.html#a194ad92b1bc632ba1d13d9958c7b5b4d">apop_vector_normalize</a>(in, &amp;out, <span class="charliteral">&#39;s&#39;</span>);
printf(<span class="stringliteral">&quot;Standardized with mean zero and variance one:\n&quot;</span>);
<a class="code" href="group__apop__print.html#ga8eafc3727869f5ec195809ad6686ba7b">apop_vector_show</a>(out);

<a class="code" href="apop__stats_8c.html#a194ad92b1bc632ba1d13d9958c7b5b4d">apop_vector_normalize</a>(in, &amp;out, <span class="charliteral">&#39;r&#39;</span>);
printf(<span class="stringliteral">&quot;Normalized range with max one and min zero:\n&quot;</span>);
<a class="code" href="group__apop__print.html#ga8eafc3727869f5ec195809ad6686ba7b">apop_vector_show</a>(out);

<a class="code" href="apop__stats_8c.html#a194ad92b1bc632ba1d13d9958c7b5b4d">apop_vector_normalize</a>(in, NULL, <span class="charliteral">&#39;p&#39;</span>);
printf(<span class="stringliteral">&quot;Normalized into percentages:\n&quot;</span>);
<a class="code" href="group__apop__print.html#ga8eafc3727869f5ec195809ad6686ba7b">apop_vector_show</a>(in);
}
</pre></div><p>This function uses the <a class="el" href="designated.html">Designated initializers</a> syntax for inputs. </p>

</div>
</div>
<a class="anchor" id="a6d68bacc086420a382366f9118cf5bc7"></a><!-- doxytag: member="stats.h::apop_vector_unique_elements" ref="a6d68bacc086420a382366f9118cf5bc7" args="(const gsl_vector *v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gsl_vector* <a class="el" href="stats_8h.html#a6d68bacc086420a382366f9118cf5bc7">apop_vector_unique_elements</a> </td>
          <td>(</td>
          <td class="paramtype">const gsl_vector *&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Give me a vector of numbers, and I'll give you a sorted list of the unique elements. This is basically running "select distinct datacol from data order by datacol", but without the aid of the database.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>a vector of items </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a sorted vector of the distinct elements that appear in the input. <ul>
<li>NaNs appear at the end of the sort order. </li>
</ul>
</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="stats_8h.html#a77c937ea4764d3da2ed9968273fa4544">apop_text_unique_elements</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a901c4b16e5691fedb4a8463548bc26a8"></a><!-- doxytag: member="stats.h::apop_vector_weighted_cov" ref="a901c4b16e5691fedb4a8463548bc26a8" args="(const gsl_vector *, const gsl_vector *, const gsl_vector *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="stats_8h.html#a901c4b16e5691fedb4a8463548bc26a8">apop_vector_weighted_cov</a> </td>
          <td>(</td>
          <td class="paramtype">const gsl_vector *&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const gsl_vector *&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const gsl_vector *&#160;</td>
          <td class="paramname"><em>w</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Find the sample covariance of a pair of weighted vectors. This only makes sense if the weightings are identical, so the function takes only one weighting vector for both.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">v1,v2</td><td>The data vectors </td></tr>
    <tr><td class="paramname">w</td><td>the weight vector. If NULL, assume equal weights. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The weighted sample covariance </dd></dl>

</div>
</div>
<a class="anchor" id="aca7a5cac76bd44584d88781c5b3cbb23"></a><!-- doxytag: member="stats.h::apop_vector_weighted_kurt" ref="aca7a5cac76bd44584d88781c5b3cbb23" args="(const gsl_vector *v, const gsl_vector *w)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="stats_8h.html#aca7a5cac76bd44584d88781c5b3cbb23">apop_vector_weighted_kurt</a> </td>
          <td>(</td>
          <td class="paramtype">const gsl_vector *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const gsl_vector *&#160;</td>
          <td class="paramname"><em>w</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Find the population kurtosis of a weighted vector.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The data vector </td></tr>
    <tr><td class="paramname">w</td><td>the weight vector. If NULL, assume equal weights. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The weighted kurtosis. No sample adjustment given weights. </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000004">Todo:</a></b></dt><dd><code>apop_vector_weighted_skew</code> and <code>apop_vector_weighted_kurt</code> are lazily written. </dd></dl>

</div>
</div>
<a class="anchor" id="a520218aa38f82de6a6297263d44afa32"></a><!-- doxytag: member="stats.h::apop_vector_weighted_mean" ref="a520218aa38f82de6a6297263d44afa32" args="(const gsl_vector *, const gsl_vector *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="stats_8h.html#a520218aa38f82de6a6297263d44afa32">apop_vector_weighted_mean</a> </td>
          <td>(</td>
          <td class="paramtype">const gsl_vector *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const gsl_vector *&#160;</td>
          <td class="paramname"><em>w</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Find the weighted mean.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The data vector </td></tr>
    <tr><td class="paramname">w</td><td>the weight vector. If NULL, assume equal weights. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The weighted mean </dd></dl>

</div>
</div>
<a class="anchor" id="ab2c0cb715352abd662783b6f1bb4d84e"></a><!-- doxytag: member="stats.h::apop_vector_weighted_skew" ref="ab2c0cb715352abd662783b6f1bb4d84e" args="(const gsl_vector *v, const gsl_vector *w)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="stats_8h.html#ab2c0cb715352abd662783b6f1bb4d84e">apop_vector_weighted_skew</a> </td>
          <td>(</td>
          <td class="paramtype">const gsl_vector *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const gsl_vector *&#160;</td>
          <td class="paramname"><em>w</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Find the population skew of a weighted vector.</p>
<p>Note: Apophenia tries to be smart about reading the weights. If weights sum to one, then the system uses <code>w-&gt;size</code> as the number of elements, and returns the usual sum over <img class="formulaInl" alt="$n-1$" src="form_47.png"/>. If weights &gt; 1, then the system uses the total weights as <img class="formulaInl" alt="$n$" src="form_8.png"/>. Thus, you can use the weights as standard weightings or to represent elements that appear repeatedly.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The data vector </td></tr>
    <tr><td class="paramname">w</td><td>the weight vector. If NULL, assume equal weights. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The weighted skew. No sample adjustment given weights. </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000003">Todo:</a></b></dt><dd><code>apop_vector_weighted_skew</code> and <code>apop_vector_weighted_kurt</code> are lazily written. </dd></dl>

</div>
</div>
<a class="anchor" id="af287d7c166a17d35bcdce5e7c8515fce"></a><!-- doxytag: member="stats.h::apop_vector_weighted_var" ref="af287d7c166a17d35bcdce5e7c8515fce" args="(const gsl_vector *v, const gsl_vector *w)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="stats_8h.html#af287d7c166a17d35bcdce5e7c8515fce">apop_vector_weighted_var</a> </td>
          <td>(</td>
          <td class="paramtype">const gsl_vector *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const gsl_vector *&#160;</td>
          <td class="paramname"><em>w</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Find the sample variance of a weighted vector.</p>
<p>Note: Apophenia tries to be smart about reading the weights. If weights sum to one, then the system uses <code>w-&gt;size</code> as the number of elements, and returns the usual sum over <img class="formulaInl" alt="$n-1$" src="form_47.png"/>. If weights &gt; 1, then the system uses the total weights as <img class="formulaInl" alt="$n$" src="form_8.png"/>. Thus, you can use the weights as standard weightings or to represent elements that appear repeatedly.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The data vector </td></tr>
    <tr><td class="paramname">w</td><td>the weight vector. If NULL, assume equal weights. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The weighted sample variance. </dd></dl>

</div>
</div>
</div><!-- contents -->
<p><p>
<div class="tiny">Autogenerated by doxygen on Sun Dec 2 2012.</div></body></html>
