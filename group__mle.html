<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html> <head>
     <title>Apophenia: a library for scientific computing</title>

<!-- Google is watching. -->
<script src="http://www.google-analytics.com/urchin.js" type="text/javascript">
</script>
<script type="text/javascript">
_uacct = "UA-134313-2";
urchinTracker();
</script>


     <link rel="stylesheet" href="typical.css" type="text/css" >
     <script  type="text/javascript" language="JavaScript" src="tree.js"></script>
</head><body>
     <center><table cellpadding=10pt>
     <tr> <td><img width=140px src=flake.gif alt="Patterns in static"></td> 
    <td><table>
     	<tr> <td><center><h2><a href="http://apophenia.info">Apophenia</a></h2></center></td></tr>
<tr><td><div class="qindex"><a class="qindex" href="index.html">&nbsp;Intro</a> | <a class="qindex" href="outline.html">Outline</a> | <a class="qindex" href="globals.html">Index</a> <!--| <a class="qindex" href="files.html">File&nbsp;List&nbsp;</a> -->  </div></td></tr></table>
	</td></tr></table></center>

<!-- Generated by Doxygen 1.7.3 -->
</div>
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<h1>Maximum likelihood estimation</h1>  </div>
</div>
<div class="contents">
<h2><a name="func-members"></a>
Functions</h2>
<ul>
<li><a class="el" href="struct__apop__model.html">apop_model</a> * <a class="el" href="group__mle.html#ga29975e75eec9ff9f48e836971a32c925">apop_maximum_likelihood</a> (<a class="el" href="struct__apop__data.html">apop_data</a> *data, <a class="el" href="struct__apop__model.html">apop_model</a> *dist)
<li><a class="el" href="struct__apop__model.html">apop_model</a> * <a class="el" href="group__mle.html#ga6d5e39c00012de5b51cd49ce1ffd31fe">apop_estimate_restart</a> (<a class="el" href="struct__apop__model.html">apop_model</a> *e, <a class="el" href="struct__apop__model.html">apop_model</a> *copy, char *starting_pt, double boundary)
</ul>


<h3><a class="anchor" id="trace_path"></a>Plotting the path of an ML estimation.</h3><div class="textblock"><p>If <code>trace_path</code> (in the <a class="el" href="structapop__mle__settings.html">apop_mle_settings</a> struct) has a name of positive length, then every time the MLE evaluates the function, then the value will be output to a table in the database/a file with the given name (depending on the value of <a class="el" href="structapop__opts__type.html">apop_opts.output_type</a>). You can then plot this table to get an idea of the path the estimation routine used to arrive at its MLE.</p>
<p>To write to a pipe or stdout, set <a class="el" href="structapop__opts__type.html">apop_opts.output_type</a> appropriately and set <code>trace_path</code> to the literal string <code>"NULL"</code>.</p>
<p>Below is a sample of the sort of output one would get:<br/>
  <div align="center">
<img src="search.gif" alt="search.gif"/>
<p><strong>An ML search, tracing out the surface of the function</strong></p></div>
 </div>

<h3><a class="anchor" id="simanneal"></a>Notes on simulated annealing</h3><div class="textblock"><p>Simulated annealing is a controlled random walk. As with the other methods, the system tries a new point, and if it is better, switches. Initially, the system is allowed to make large jumps, and then with each iteration, the jumps get smaller, eventually converging. Also, there is some decreasing probability that if the new point is {<em>less}</em> likely, it will still be chosen. Simulated annealing is best for situations where there may be multiple local optima. Early in the random walk, the system can readily jump from one to another; later it will fine-tune its way toward the optimum. The number of points tested is basically not dependent on the function: if you give it a 4,000 step program, that is basically how many steps it will take. If you know your function is globally convex (as are most standard probability functions), then this method is overkill.</p>
<p>The GSL's simulated annealing system doesn't actually do very much. It basically provides a for loop that calls a half-dozen functions that we the users get to write. So, the file <a class="el" href="apop__mle_8c.html">apop_mle.c</a> handles all of this for you. The likelihood function is taken from the model, the metric is the Manhattan metric, the copy/destroy functions are just the usual vector-handling fns., et cetera. The reader who wants further control is welcome to override these functions.</p>
<p>Verbosity: if ep-&gt;verbose==1, show likelihood, temp, &amp;c. in a table; if ep-&gt;verbose&gt;1, show that plus the vector of params. </p>
</div><hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga6d5e39c00012de5b51cd49ce1ffd31fe"></a><!-- doxytag: member="apop_mle.c::apop_estimate_restart" ref="ga6d5e39c00012de5b51cd49ce1ffd31fe" args="(apop_model *e, apop_model *copy, char *starting_pt, double boundary)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct__apop__model.html">apop_model</a>* apop_estimate_restart </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__apop__model.html">apop_model</a> *&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct__apop__model.html">apop_model</a> *&#160;</td>
          <td class="paramname"><em>copy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>starting_pt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>boundary</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The simplest use of this function is to restart a model at the latest parameter estimates.</p>
<div class="fragment"><pre class="fragment"><a class="code" href="struct__apop__model.html">apop_model</a> *m = <a class="code" href="group__models.html#ga0a3be4075a89f7119be95a4718e01ade">apop_estimate</a>(data, model_using_an_MLE_search);
<span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt; 10; i++)
    m = <a class="code" href="group__mle.html#ga6d5e39c00012de5b51cd49ce1ffd31fe">apop_estimate_restart</a>(m);
<a class="code" href="group__output.html#ga9a30c437ec11a11e37e0db7f82386275">apop_data_show</a>(m);
</pre></div><p>By adding a line to reduce the tolerance each round [e.g., <code>Apop_settings_set(m, apop_mle, tolerance, pow(10,-i))</code>], you can start broad and hone in on a precise optimum.</p>
<p>You may have a new estimation method, such as first doing a coarse simulated annealing search, then a fine conjugate gradient search. When reading this example, recall that the form for adding a new settings group differs from the form for modifying existing settings: </p>
<div class="fragment"><pre class="fragment">Apop_model_add_settings(your_base_model, apop_mle, .method=<a class="code" href="settings_8h.html#a8ad2736f202dd945a0d2097a59d11d1fa13857c48cea6c885b181be9539fb1aa6">APOP_SIMAN</a>);
<a class="code" href="struct__apop__model.html">apop_model</a> *m = <a class="code" href="group__models.html#ga0a3be4075a89f7119be95a4718e01ade">apop_estimate</a>(data, your_base_model);
<a class="code" href="group__settings.html#ga8659282b6003f7c2adac6f4baad5fae4">Apop_settings_set</a>(m, apop_mle, method, <a class="code" href="settings_8h.html#a8ad2736f202dd945a0d2097a59d11d1fa81b229729a74904a28270260ec86e223">APOP_CG_PR</a>);
m = <a class="code" href="group__mle.html#ga6d5e39c00012de5b51cd49ce1ffd31fe">apop_estimate_restart</a>(m);
<a class="code" href="group__output.html#ga9a30c437ec11a11e37e0db7f82386275">apop_data_show</a>(m);
</pre></div><p>Only one estimate is returned, either the one you sent in or a new one. The loser (which may be the one you sent in) is freed. That is, there is no memory leak in the above loop.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>An <a class="el" href="types_8h.html#aadd13f6aa6f5f17d48d9b7d2b606bdd4">apop_model</a> that is the output from a prior MLE estimation. (No default, must not be <code>NULL</code>.) </td></tr>
    <tr><td class="paramname">copy</td><td>Another not-yet-parametrized model that will be re-estimated with (1) the same data and (2) a <code>starting_pt</code> as per the next setting (probably to the parameters of <code>e</code>). If this is <code>NULL</code>, then copy <code>e</code>. (Default = <code>NULL</code>) </td></tr>
    <tr><td class="paramname">starting_pt</td><td>"ep"=last estimate of the first model (i.e., its current parameter estimates); "es"= starting point originally used by the first model; "np"=current parameters of the new (second) model; "ns"=starting point specified by the new model's MLE settings. (default = "ep") </td></tr>
    <tr><td class="paramname">boundary</td><td>I test whether the starting point you give me is outside this certain bound, so I can warn you if there's divergence in your sequence of re-estimations. (default: 1e8)</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>At the end of this procedure, we'll have two <a class="el" href="types_8h.html#aadd13f6aa6f5f17d48d9b7d2b606bdd4">apop_model</a> structs: the one you sent in, and the one produced using the new method/scale. If the new estimate includes any NaNs/Infs, then the old estimate is returned (even if the old estimate included NaNs/Infs). Otherwise, the estimate with the largest log likelihood is returned.</dd></dl>
<ul>
<li>This function uses the <a class="el" href="designated.html">Designated initializers</a> syntax for inputs. </li>
</ul>

</div>
</div>
<a class="anchor" id="ga29975e75eec9ff9f48e836971a32c925"></a><!-- doxytag: member="apop_mle.c::apop_maximum_likelihood" ref="ga29975e75eec9ff9f48e836971a32c925" args="(apop_data *data, apop_model *dist)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct__apop__model.html">apop_model</a>* apop_maximum_likelihood </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__apop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct__apop__model.html">apop_model</a> *&#160;</td>
          <td class="paramname"><em>dist</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The maximum likelihood calculations</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The data matrix (an <a class="el" href="gentle.html#apop_data">apop_data</a> set). </td></tr>
    <tr><td class="paramname">dist</td><td>The <a class="el" href="types_8h.html#aadd13f6aa6f5f17d48d9b7d2b606bdd4">apop_model</a> object: waring, probit, zipf, &amp;c. You can add an <code><a class="el" href="structapop__mle__settings.html">apop_mle_settings</a></code> struct to it (<code>Apop_model_add_group(your_model, apop_mle, .verbose=1, .method=APOP_CG_FR, and_so_on)</code>). So, see the <code><a class="el" href="structapop__mle__settings.html">apop_mle_settings</a></code> documentation for the many options, such as choice of method and tuning parameters.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>an <a class="el" href="types_8h.html#aadd13f6aa6f5f17d48d9b7d2b606bdd4">apop_model</a> with the parameter estimates, &amp;c.</dd></dl>
<ul>
<li>I only look at the first page of your parameter set. If you need more, perhaps use <a class="el" href="group__conversions.html#ga7e31798ab418cbfc7488eaba27dad2af">apop_data_pack</a> .</li>
</ul>
<ul>
<li>Get auxiliary info via, e.g.: <div class="fragment"><pre class="fragment"><a class="code" href="struct__apop__model.html">apop_model</a> *est = <a class="code" href="group__models.html#ga0a3be4075a89f7119be95a4718e01ade">apop_estimate</a>(your_data, <a class="code" href="group__models.html#ga319b8e3d5025a6fc94829a978273eb8b">apop_probit</a>);
<span class="keywordtype">int</span> status = <a class="code" href="group__data__set__get.html#gae3c2f0d4bd96555e8eeb32a44511d0ac">apop_data_get</a>(est-&gt;<a class="code" href="struct__apop__model.html#a9eefb73c2c6c5c1e3e3f230f1a2be9f6">info</a>, .rowname=<span class="stringliteral">&quot;status&quot;</span>);
<span class="keywordflow">if</span> (status)
    <span class="comment">//trouble</span>
<span class="keywordflow">else</span>
    <span class="comment">//optimum found</span>
</pre></div> </li>
</ul>

</div>
</div>
</div>
<p><p>
<div class="tiny">Autogenerated by doxygen on Wed Oct 19 2011.</div></body></html>
