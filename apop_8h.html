<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html> <head>
     <title>Apophenia: a library for scientific computing</title>

<!-- Google is watching. -->
<script src="http://www.google-analytics.com/urchin.js" type="text/javascript">
</script>
<script type="text/javascript">
_uacct = "UA-134313-2";
urchinTracker();
</script>


     <link rel="stylesheet" href="typical.css" type="text/css" >
     <script  type="text/javascript" language="JavaScript" src="tree.js"></script>
</head><body>
     <center><table cellpadding=10pt>
     <tr> <td><img width=140px src=flake.gif alt="Patterns in static"></td> 
    <td><table>
     	<tr> <td><center><h2><a href="http://apophenia.info">Apophenia</a></h2></center></td></tr>
<tr><td><div class="qindex"><a class="qindex" href="index.html">&nbsp;Intro</a> | <a class="qindex" href="outline.html">Outline</a> | <a class="qindex" href="globals.html">Index</a> <!--| <a class="qindex" href="files.html">File&nbsp;List&nbsp;</a> -->  </div></td></tr></table>
	</td></tr></table></center>

    <div> <!--Doxygen generates an extra </div>.-->
<!-- Generated by Doxygen 1.7.6.1 -->
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Defines</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">apop.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><a href="apop_8h_source.html">Go to the source code of this file.</a></p>
<h2><a name="nested-classes"></a>
Data Structures</h2>
<ul>
<li>struct <a class="el" href="structapop__name.html">apop_name</a>
<li>struct <a class="el" href="structapop__data.html">apop_data</a>
<li>struct <a class="el" href="structapop__settings__type.html">apop_settings_type</a>
<li>struct <a class="el" href="structapop__model.html">apop_model</a>
<li>struct <a class="el" href="structapop__opts__type.html">apop_opts_type</a>
<li>struct <a class="el" href="structapop__mle__settings.html">apop_mle_settings</a>
<li>struct <a class="el" href="structapop__lm__settings.html">apop_lm_settings</a>
<li>struct <a class="el" href="structapop__parts__wanted__settings.html">apop_parts_wanted_settings</a>
<li>struct <a class="el" href="structapop__cdf__settings.html">apop_cdf_settings</a>
<li>struct <a class="el" href="structapop__pm__settings.html">apop_pm_settings</a>
<li>struct <a class="el" href="structapop__pmf__settings.html">apop_pmf_settings</a>
<li>struct <a class="el" href="structapop__kernel__density__settings.html">apop_kernel_density_settings</a>
<li>struct <a class="el" href="structapop__mcmc__settings.html">apop_mcmc_settings</a>
<li>struct <a class="el" href="structloess__struct.html">loess_struct</a>
<li>struct <a class="el" href="structapop__loess__settings.html">apop_loess_settings</a>
<li>struct <a class="el" href="structapop__arms__settings.html">apop_arms_settings</a>
<li>struct <a class="el" href="structapop__stack__settings.html">apop_stack_settings</a>
<li>struct <a class="el" href="structapop__ct__settings.html">apop_ct_settings</a>
<li>struct <a class="el" href="structapop__dconstrain__settings.html">apop_dconstrain_settings</a>
<li>struct <a class="el" href="structapop__composition__settings.html">apop_composition_settings</a>
<li>struct <a class="el" href="structapop__mixture__settings.html">apop_mixture_settings</a>
</ul>
<h2><a name="define-members"></a>
Defines</h2>
<ul>
<li><a class="anchor" id="ad9d5b8677ddea978bba1d1a17e85a6d3"></a><!-- doxytag: member="apop.h::apop_varad_head" ref="ad9d5b8677ddea978bba1d1a17e85a6d3" args="(type, name)" -->
#define <b>apop_varad_head</b>(type, name)&#160;&#160;&#160;type variadic_##name(variadic_type_##name varad_in)
<li>#define <b>apop_varad_declare</b>(type, name,...)
<li><a class="anchor" id="a9a49368d1077a5ccc49a3ad9384fe8ce"></a><!-- doxytag: member="apop.h::apop_varad_var" ref="a9a49368d1077a5ccc49a3ad9384fe8ce" args="(name, value)" -->
#define <b>apop_varad_var</b>(name, value)&#160;&#160;&#160;name = varad_in.name ? varad_in.name : (value);
<li><a class="anchor" id="a6a5495ce1d2bec0549de5d679f1ad657"></a><!-- doxytag: member="apop.h::apop_varad_link" ref="a6a5495ce1d2bec0549de5d679f1ad657" args="(name,...)" -->
#define <b>apop_varad_link</b>(name,...)&#160;&#160;&#160;variadic_##name((variadic_type_##name) {__VA_ARGS__})
<li>#define <a class="el" href="apop_8h.html#aeca6159c82c21da0db82ae9ed0582dc6">apop_data_add_names</a>(dataset, type,...)&#160;&#160;&#160;apop_data_add_names_base((dataset), (type), (char const*[]) {__VA_ARGS__, NULL})
<li>#define <a class="el" href="apop_8h.html#a459acfde11f2c39f5c32cff377f85b9e">apop_data_free</a>(freeme)&#160;&#160;&#160;(<a class="el" href="apop__data_8c.html#a3e8377359d46c9bd02ea57205e7968d3">apop_data_free_base</a>(freeme) ? 0 : ((freeme)= NULL))
<li>#define <a class="el" href="apop_8h.html#a5ea849ee3c044e95eafb7b79124ce844">apop_data_prune_columns</a>(in,...)
<li><a class="anchor" id="a79b5994e799d38ad44d646d7a457f42d"></a><!-- doxytag: member="apop.h::apop_line_to_vector" ref="a79b5994e799d38ad44d646d7a457f42d" args="" -->
#define <b>apop_line_to_vector</b>&#160;&#160;&#160;<a class="el" href="group__conversions.html#ga8abdcdbaceaaf0dd3882a164bc2565de">apop_array_to_vector</a>
<li>#define <a class="el" href="apop_8h.html#af9b051e2fbe0e473dddeabfe4932ce0c">apop_vector_fill</a>(avfin,...)&#160;&#160;&#160;apop_vector_fill_base((avfin), (double []) {__VA_ARGS__})
<li>#define <a class="el" href="apop_8h.html#ad6be56d710a63aa1ceadf2242c553905">apop_data_fill</a>(adfin,...)&#160;&#160;&#160;apop_data_fill_base((adfin), (double []) {__VA_ARGS__})
<li>#define <a class="el" href="apop_8h.html#a74dca50ea16ed7bf25cb152315642769">apop_text_fill</a>(dataset,...)&#160;&#160;&#160;apop_text_fill_base((dataset), (char* []) {__VA_ARGS__, NULL})
<li>#define <a class="el" href="apop_8h.html#acb6b2c53478f9db902ba0340ba499819">apop_data_falloc</a>(sizes,...)&#160;&#160;&#160;<a class="el" href="apop_8h.html#ad6be56d710a63aa1ceadf2242c553905">apop_data_fill</a>(<a class="el" href="apop__data_8c.html#ac39d6a56933b6f084328ec5ecd5090d8">apop_data_alloc</a> sizes, __VA_ARGS__)
<li>#define <a class="el" href="apop_8h.html#abbdfc523f5b269827db8cebf28216e28">apop_gaussian</a>
<li><a class="anchor" id="aaae03e0c8a6bb5f02bb422f4fca465ba"></a><!-- doxytag: member="apop.h::apop_OLS" ref="aaae03e0c8a6bb5f02bb422f4fca465ba" args="" -->
#define <b>apop_OLS</b>&#160;&#160;&#160;<a class="el" href="group__models.html#ga85524b1deabd5829227888fd91740cc3">apop_ols</a>
<li><a class="anchor" id="af417b9601adfa9cefad8c9a377a9674f"></a><!-- doxytag: member="apop.h::apop_PMF" ref="af417b9601adfa9cefad8c9a377a9674f" args="" -->
#define <b>apop_PMF</b>&#160;&#160;&#160;<a class="el" href="group__models.html#gaca8f3323c57e0223a9f3c0f991c9760e">apop_pmf</a>
<li><a class="anchor" id="adb7cd4412e9fca67bb14aa22662aaa65"></a><!-- doxytag: member="apop.h::apop_F_distribution" ref="adb7cd4412e9fca67bb14aa22662aaa65" args="" -->
#define <b>apop_F_distribution</b>&#160;&#160;&#160;apop_f_distribution
<li><a class="anchor" id="ad1974e60ac54b2f06a9731ecc42c74e0"></a><!-- doxytag: member="apop.h::apop_WLS" ref="ad1974e60ac54b2f06a9731ecc42c74e0" args="" -->
#define <b>apop_WLS</b>&#160;&#160;&#160;<a class="el" href="group__models.html#gaa030af2c41ac564c3a9ccce14b06f13c">apop_wls</a>
<li><a class="anchor" id="aaf1281c546207c8e27e4c8a9239ec3f9"></a><!-- doxytag: member="apop.h::apop_IV" ref="aaf1281c546207c8e27e4c8a9239ec3f9" args="" -->
#define <b>apop_IV</b>&#160;&#160;&#160;<a class="el" href="group__models.html#ga1efcbbe0410c89401354c762363a909f">apop_iv</a>
<li>#define <a class="el" href="group__models.html#ga36cae46a2950eb6cfb65794cdd5dac7e">apop_model_set_parameters</a>(in,...)
<li>#define <a class="el" href="apop_8h.html#a40bb98b02fde8f8e4ab59a4d127b692f">apop_model_mixture</a>(...)&#160;&#160;&#160;apop_model_mixture_base((<a class="el" href="structapop__model.html">apop_model</a> *[]){__VA_ARGS__, NULL})
<li>#define <a class="el" href="apop_8h.html#ad0e4b98a3edb53646ff9b036cfb558a0">apop_model_stack</a>(...)&#160;&#160;&#160;apop_model_stack_base((<a class="el" href="structapop__model.html">apop_model</a> *[]){__VA_ARGS__, NULL})
<li><a class="anchor" id="af1210155d44e962846822abfef413fbb"></a><!-- doxytag: member="apop.h::apop_ANOVA" ref="af1210155d44e962846822abfef413fbb" args="" -->
#define <b>apop_ANOVA</b>&#160;&#160;&#160;<a class="el" href="apop__tests_8c.html#a1309242dbb7f148916c71a9a70c6b64c">apop_anova</a>
<li><a class="anchor" id="ae6aa069a742d2480040cfdaa79b2bc54"></a><!-- doxytag: member="apop.h::apop_F_test" ref="ae6aa069a742d2480040cfdaa79b2bc54" args="" -->
#define <b>apop_F_test</b>&#160;&#160;&#160;<a class="el" href="apop__tests_8c.html#a1902b3fd6a6682d1453a80b788e44ebb">apop_f_test</a>
<li>#define <a class="el" href="group__regression.html#ga33c353f768fb4b0e7a3f98ab7a546ba5">apop_estimate_r_squared</a>(in)
<li>#define <a class="el" href="apop_8h.html#a1e829ce2396bf05ab10460bcc37aeeab">apop_rng_get_thread</a>(thread_in)
<li>#define <b>apop_update_hash</b>(m1, m2)
<li><a class="anchor" id="a8cd48076436e96fccb3391a913a61ef0"></a><!-- doxytag: member="apop.h::apop_update_vtable_add" ref="a8cd48076436e96fccb3391a913a61ef0" args="(fn,...)" -->
#define <b>apop_update_vtable_add</b>(fn,...)&#160;&#160;&#160;apop_update_type_check(fn), apop_vtable_add(&quot;apop_update&quot;, fn, apop_update_hash(__VA_ARGS__))
<li><a class="anchor" id="a0a4a2a359c86f81bc940e2c1cacf1c26"></a><!-- doxytag: member="apop.h::apop_update_vtable_get" ref="a0a4a2a359c86f81bc940e2c1cacf1c26" args="(...)" -->
#define <b>apop_update_vtable_get</b>(...)&#160;&#160;&#160;apop_vtable_get(&quot;apop_update&quot;, apop_update_hash(__VA_ARGS__))
<li><a class="anchor" id="ae47c666417e84db7685304252be2bfc1"></a><!-- doxytag: member="apop.h::apop_update_vtable_drop" ref="ae47c666417e84db7685304252be2bfc1" args="(...)" -->
#define <b>apop_update_vtable_drop</b>(...)&#160;&#160;&#160;apop_vtable_drop(&quot;apop_update&quot;, apop_update_hash(__VA_ARGS__))
<li><a class="anchor" id="a199f5dc2439b633a936e344f989c73be"></a><!-- doxytag: member="apop.h::apop_score_hash" ref="a199f5dc2439b633a936e344f989c73be" args="(m1)" -->
#define <b>apop_score_hash</b>(m1)&#160;&#160;&#160;((size_t)((m1)-&gt;log_likelihood ? (m1)-&gt;log_likelihood : (m1)-&gt;p))
<li><a class="anchor" id="aef9011becba9f153c05befada14122a1"></a><!-- doxytag: member="apop.h::apop_score_vtable_add" ref="aef9011becba9f153c05befada14122a1" args="(fn,...)" -->
#define <b>apop_score_vtable_add</b>(fn,...)&#160;&#160;&#160;apop_score_type_check(fn), apop_vtable_add(&quot;apop_score&quot;, fn, apop_score_hash(__VA_ARGS__))
<li><a class="anchor" id="a3c6057f0ca24c9fc40dfd3522e8514cb"></a><!-- doxytag: member="apop.h::apop_score_vtable_get" ref="a3c6057f0ca24c9fc40dfd3522e8514cb" args="(...)" -->
#define <b>apop_score_vtable_get</b>(...)&#160;&#160;&#160;apop_vtable_get(&quot;apop_score&quot;, apop_score_hash(__VA_ARGS__))
<li><a class="anchor" id="a4a27175f1a44444ec667019cf8ced62a"></a><!-- doxytag: member="apop.h::apop_score_vtable_drop" ref="a4a27175f1a44444ec667019cf8ced62a" args="(...)" -->
#define <b>apop_score_vtable_drop</b>(...)&#160;&#160;&#160;apop_vtable_drop(&quot;apop_score&quot;, apop_score_hash(__VA_ARGS__))
<li><a class="anchor" id="a8a8d1e9d3b98d6955df9e8d033b6e942"></a><!-- doxytag: member="apop.h::apop_parameter_model_hash" ref="a8a8d1e9d3b98d6955df9e8d033b6e942" args="(m1)" -->
#define <b>apop_parameter_model_hash</b>(m1)&#160;&#160;&#160;((size_t)((m1)-&gt;log_likelihood ? (m1)-&gt;log_likelihood : (m1)-&gt;p)*33 + (m1)-&gt;estimate ? (size_t)(m1)-&gt;estimate: 27)
<li><a class="anchor" id="a7a6b40cdcb585c940b730dfd9974371f"></a><!-- doxytag: member="apop.h::apop_parameter_model_vtable_add" ref="a7a6b40cdcb585c940b730dfd9974371f" args="(fn,...)" -->
#define <b>apop_parameter_model_vtable_add</b>(fn,...)&#160;&#160;&#160;apop_parameter_model_type_check(fn), apop_vtable_add(&quot;apop_parameter_model&quot;, fn, apop_parameter_model_hash(__VA_ARGS__))
<li><a class="anchor" id="a1d58be6503a02ffb2f20724d4590d021"></a><!-- doxytag: member="apop.h::apop_parameter_model_vtable_get" ref="a1d58be6503a02ffb2f20724d4590d021" args="(...)" -->
#define <b>apop_parameter_model_vtable_get</b>(...)&#160;&#160;&#160;apop_vtable_get(&quot;apop_parameter_model&quot;, apop_parameter_model_hash(__VA_ARGS__))
<li><a class="anchor" id="a07133ab4527477a34fcf4fd2927d38df"></a><!-- doxytag: member="apop.h::apop_parameter_model_vtable_drop" ref="a07133ab4527477a34fcf4fd2927d38df" args="(...)" -->
#define <b>apop_parameter_model_vtable_drop</b>(...)&#160;&#160;&#160;apop_vtable_drop(&quot;apop_parameter_model&quot;, apop_parameter_model_hash(__VA_ARGS__))
<li><a class="anchor" id="a98bb5c58491167e8f49f139c0b903683"></a><!-- doxytag: member="apop.h::apop_predict_hash" ref="a98bb5c58491167e8f49f139c0b903683" args="(m1)" -->
#define <b>apop_predict_hash</b>(m1)&#160;&#160;&#160;((size_t)((m1)-&gt;log_likelihood ? (m1)-&gt;log_likelihood : (m1)-&gt;p)*33 + (m1)-&gt;estimate ? (size_t)(m1)-&gt;estimate: 27)
<li><a class="anchor" id="a4bc5e9268f1b6439d551aa25a37408a3"></a><!-- doxytag: member="apop.h::apop_predict_vtable_add" ref="a4bc5e9268f1b6439d551aa25a37408a3" args="(fn,...)" -->
#define <b>apop_predict_vtable_add</b>(fn,...)&#160;&#160;&#160;apop_predict_type_check(fn), apop_vtable_add(&quot;apop_predict&quot;, fn, apop_predict_hash(__VA_ARGS__))
<li><a class="anchor" id="a2f9abf5d4af072eedeceeb754cba5e78"></a><!-- doxytag: member="apop.h::apop_predict_vtable_get" ref="a2f9abf5d4af072eedeceeb754cba5e78" args="(...)" -->
#define <b>apop_predict_vtable_get</b>(...)&#160;&#160;&#160;apop_vtable_get(&quot;apop_predict&quot;, apop_predict_hash(__VA_ARGS__))
<li><a class="anchor" id="a0269008b422fd5c530f17355112acdd6"></a><!-- doxytag: member="apop.h::apop_predict_vtable_drop" ref="a0269008b422fd5c530f17355112acdd6" args="(...)" -->
#define <b>apop_predict_vtable_drop</b>(...)&#160;&#160;&#160;apop_vtable_drop(&quot;apop_predict&quot;, apop_predict_hash(__VA_ARGS__))
<li>#define <b>apop_model_print_hash</b>(m1)
<li><a class="anchor" id="a8f9b8d46ac98dcb1eeb21502d5661d41"></a><!-- doxytag: member="apop.h::apop_model_print_vtable_add" ref="a8f9b8d46ac98dcb1eeb21502d5661d41" args="(fn,...)" -->
#define <b>apop_model_print_vtable_add</b>(fn,...)&#160;&#160;&#160;apop_model_print_type_check(fn), apop_vtable_add(&quot;apop_model_print&quot;, fn, apop_model_print_hash(__VA_ARGS__))
<li><a class="anchor" id="a541056fe6b15dda51eccb31e119f1f65"></a><!-- doxytag: member="apop.h::apop_model_print_vtable_get" ref="a541056fe6b15dda51eccb31e119f1f65" args="(...)" -->
#define <b>apop_model_print_vtable_get</b>(...)&#160;&#160;&#160;apop_vtable_get(&quot;apop_model_print&quot;, apop_model_print_hash(__VA_ARGS__))
<li><a class="anchor" id="a27f8f510f16ba6a7ba154dfd9dd77d0b"></a><!-- doxytag: member="apop.h::apop_model_print_vtable_drop" ref="a27f8f510f16ba6a7ba154dfd9dd77d0b" args="(...)" -->
#define <b>apop_model_print_vtable_drop</b>(...)&#160;&#160;&#160;apop_vtable_drop(&quot;apop_model_print&quot;, apop_model_print_hash(__VA_ARGS__))
<li><a class="anchor" id="adb031d6207a4bab47be1ca9c39509184"></a><!-- doxytag: member="apop.h::apop_test_ANOVA_independence" ref="adb031d6207a4bab47be1ca9c39509184" args="(d)" -->
#define <b>apop_test_ANOVA_independence</b>(d)&#160;&#160;&#160;<a class="el" href="group__asst__tests.html#ga12b92b7494f4e24d2f47244e3792d566">apop_test_anova_independence</a>(d)
<li>#define <a class="el" href="apop_8h.html#a674b73c9b8813f35e41009428cbc80f9">Apop_notify</a>(verbosity,...)
<li>#define <b>Apop_maybe_abort</b>(level)
<li>#define <a class="el" href="apop_8h.html#abd17601e642688d033f62d346f3dace6">Apop_stopif</a>(test, onfail, level,...)
<li><a class="anchor" id="a6b522120f0e4d4533bf180e1fde1ee39"></a><!-- doxytag: member="apop.h::apop_errorlevel" ref="a6b522120f0e4d4533bf180e1fde1ee39" args="" -->
#define <b>apop_errorlevel</b>&#160;&#160;&#160;-5
<li><a class="anchor" id="a8d32f03ca035f4d2ca0ef638b07cd5df"></a><!-- doxytag: member="apop.h::apop_return_data_error" ref="a8d32f03ca035f4d2ca0ef638b07cd5df" args="(E)" -->
#define <b>apop_return_data_error</b>(E)&#160;&#160;&#160;{<a class="el" href="structapop__data.html">apop_data</a> *out=<a class="el" href="apop__data_8c.html#ac39d6a56933b6f084328ec5ecd5090d8">apop_data_alloc</a>(); out-&gt;error='E'; return out;}
<li><a class="anchor" id="a482b1a29fd707240d4f99d6da0fa0ddf"></a><!-- doxytag: member="apop.h::Apop_assert_c" ref="a482b1a29fd707240d4f99d6da0fa0ddf" args="(test, returnval, level,...)" -->
#define <b>Apop_assert_c</b>(test, returnval, level,...)&#160;&#160;&#160;<a class="el" href="apop_8h.html#abd17601e642688d033f62d346f3dace6">Apop_stopif</a>(!(test), return returnval, level, __VA_ARGS__)
<li><a class="anchor" id="aa6760fa3f2e261b93aaf25d80a11375c"></a><!-- doxytag: member="apop.h::Apop_assert" ref="aa6760fa3f2e261b93aaf25d80a11375c" args="(test,...)" -->
#define <b>Apop_assert</b>(test,...)&#160;&#160;&#160;Apop_assert_c((test), 0, apop_errorlevel, __VA_ARGS__)
<li><a class="anchor" id="a56d7ffeae727765479223682a672f6dd"></a><!-- doxytag: member="apop.h::Apop_assert_n" ref="a56d7ffeae727765479223682a672f6dd" args="(test,...)" -->
#define <b>Apop_assert_n</b>(test,...)&#160;&#160;&#160;Apop_assert_c((test),  , apop_errorlevel, __VA_ARGS__)
<li><a class="anchor" id="a55126db41995542d13819b8b9e9f794c"></a><!-- doxytag: member="apop.h::Apop_assert_nan" ref="a55126db41995542d13819b8b9e9f794c" args="(test,...)" -->
#define <b>Apop_assert_nan</b>(test,...)&#160;&#160;&#160;Apop_assert_c((test), GSL_NAN, apop_errorlevel, __VA_ARGS__)
<li><a class="anchor" id="afd6540d56da36cd8ed25aef36282f20e"></a><!-- doxytag: member="apop.h::Apop_assert_negone" ref="afd6540d56da36cd8ed25aef36282f20e" args="(test,...)" -->
#define <b>Apop_assert_negone</b>(test,...)&#160;&#160;&#160;Apop_assert_c((test), -1, apop_errorlevel, __VA_ARGS__)
<li><a class="anchor" id="a2a6667ffc981f0b56c7d6c6e7f01572d"></a><!-- doxytag: member="apop.h::apop_ml_imputation" ref="a2a6667ffc981f0b56c7d6c6e7f01572d" args="(d, m)" -->
#define <b>apop_ml_imputation</b>(d, m)&#160;&#160;&#160;<a class="el" href="apop__missing__data_8c.html#a985955429db179a45eb5936ebd324760">apop_ml_impute</a>(d, m)
<li>#define <b>APOP_SUBMATRIX</b>(m, srow, scol, nrows, ncols, o)
<li>#define <a class="el" href="apop_8h.html#a39fd40c5f39795c077716dbaf122d270">Apop_row_v</a>(m, row, v)
<li>#define <a class="el" href="apop_8h.html#a4d7938112c815272f9737685bf128ccb">Apop_col_v</a>(m, col, v)
<li>#define <a class="el" href="apop_8h.html#a6396c26f1d47cced2be3a761185d3b35">Apop_row_tv</a>(m, row, v)
<li>#define <a class="el" href="apop_8h.html#ad56ce572c7489820777290153ab7d87b">Apop_col_tv</a>(m, col, v)
<li>#define <a class="el" href="apop_8h.html#aad1642d90f82ef1f5870a2de4e807005">Apop_rows</a>(d, rownum, len, outd)
<li>#define <a class="el" href="apop_8h.html#af9032e16affac10d90dd3565e709966d">Apop_row</a>(d, row, outd)
<li>#define <a class="el" href="apop_8h.html#a7d87af4e65acbf6982a34cf3dc33eae6">Apop_row_t</a>(d, rowname, outd)
<li>#define <a class="el" href="apop_8h.html#aaaf15101ec60ce66e80737375baa7391">Apop_col_t</a>(d, colname, outd)
<li>#define <a class="el" href="apop_8h.html#afbfb5abe21c52dd24570b620ed069c4d">Apop_cols</a>(d, colnum, len, outd)
<li>#define <a class="el" href="apop_8h.html#a84e73bf42af0baed7b13de3a43eebb72">Apop_col</a>(d, col, outd)
<li><a class="anchor" id="a6c85d6dc4a491036d8e95630b46a9c45"></a><!-- doxytag: member="apop.h::APOP_COL" ref="a6c85d6dc4a491036d8e95630b46a9c45" args="" -->
#define <b>APOP_COL</b>&#160;&#160;&#160;<a class="el" href="apop_8h.html#a84e73bf42af0baed7b13de3a43eebb72">Apop_col</a>
<li><a class="anchor" id="a1ae65fc29259a9574c22994a21acabe5"></a><!-- doxytag: member="apop.h::apop_col" ref="a1ae65fc29259a9574c22994a21acabe5" args="" -->
#define <b>apop_col</b>&#160;&#160;&#160;<a class="el" href="apop_8h.html#a84e73bf42af0baed7b13de3a43eebb72">Apop_col</a>
<li><a class="anchor" id="a6e442cb35468a39369eb823ba250c9d2"></a><!-- doxytag: member="apop.h::APOP_COLS" ref="a6e442cb35468a39369eb823ba250c9d2" args="" -->
#define <b>APOP_COLS</b>&#160;&#160;&#160;<a class="el" href="apop_8h.html#afbfb5abe21c52dd24570b620ed069c4d">Apop_cols</a>
<li><a class="anchor" id="a0e38e3e944de364aad9f45597e48100d"></a><!-- doxytag: member="apop.h::apop_cols" ref="a0e38e3e944de364aad9f45597e48100d" args="" -->
#define <b>apop_cols</b>&#160;&#160;&#160;<a class="el" href="apop_8h.html#afbfb5abe21c52dd24570b620ed069c4d">Apop_cols</a>
<li><a class="anchor" id="a852a1e47bfbadda00a709c1a905f11e2"></a><!-- doxytag: member="apop.h::APOP_COL_T" ref="a852a1e47bfbadda00a709c1a905f11e2" args="" -->
#define <b>APOP_COL_T</b>&#160;&#160;&#160;<a class="el" href="apop_8h.html#aaaf15101ec60ce66e80737375baa7391">Apop_col_t</a>
<li><a class="anchor" id="aba82501c0ea1406dc7c0a308a6582b63"></a><!-- doxytag: member="apop.h::apop_col_t" ref="aba82501c0ea1406dc7c0a308a6582b63" args="" -->
#define <b>apop_col_t</b>&#160;&#160;&#160;<a class="el" href="apop_8h.html#aaaf15101ec60ce66e80737375baa7391">Apop_col_t</a>
<li><a class="anchor" id="aff4ed7793b32011f151cd9ba92e63d4d"></a><!-- doxytag: member="apop.h::APOP_COL_TV" ref="aff4ed7793b32011f151cd9ba92e63d4d" args="" -->
#define <b>APOP_COL_TV</b>&#160;&#160;&#160;<a class="el" href="apop_8h.html#ad56ce572c7489820777290153ab7d87b">Apop_col_tv</a>
<li><a class="anchor" id="a7ad3559c1a07c4e539d8bfeee7a43cf0"></a><!-- doxytag: member="apop.h::apop_col_tv" ref="a7ad3559c1a07c4e539d8bfeee7a43cf0" args="" -->
#define <b>apop_col_tv</b>&#160;&#160;&#160;<a class="el" href="apop_8h.html#ad56ce572c7489820777290153ab7d87b">Apop_col_tv</a>
<li><a class="anchor" id="af2e3e5c5064a5a4da6dd499581b54b11"></a><!-- doxytag: member="apop.h::APOP_COL_V" ref="af2e3e5c5064a5a4da6dd499581b54b11" args="" -->
#define <b>APOP_COL_V</b>&#160;&#160;&#160;<a class="el" href="apop_8h.html#a4d7938112c815272f9737685bf128ccb">Apop_col_v</a>
<li><a class="anchor" id="a0faa579670204a7faad21bbe2b6b95c3"></a><!-- doxytag: member="apop.h::apop_col_v" ref="a0faa579670204a7faad21bbe2b6b95c3" args="" -->
#define <b>apop_col_v</b>&#160;&#160;&#160;<a class="el" href="apop_8h.html#a4d7938112c815272f9737685bf128ccb">Apop_col_v</a>
<li><a class="anchor" id="af91b5791759a04072490f1ffb76287e7"></a><!-- doxytag: member="apop.h::APOP_ROW" ref="af91b5791759a04072490f1ffb76287e7" args="" -->
#define <b>APOP_ROW</b>&#160;&#160;&#160;<a class="el" href="apop_8h.html#af9032e16affac10d90dd3565e709966d">Apop_row</a>
<li><a class="anchor" id="a31babc8f4ae3adcaf3910b6ec0297d55"></a><!-- doxytag: member="apop.h::apop_row" ref="a31babc8f4ae3adcaf3910b6ec0297d55" args="" -->
#define <b>apop_row</b>&#160;&#160;&#160;<a class="el" href="apop_8h.html#af9032e16affac10d90dd3565e709966d">Apop_row</a>
<li><a class="anchor" id="a57d4c38e71ed33ce5aafca03da962d32"></a><!-- doxytag: member="apop.h::Apop_data_row" ref="a57d4c38e71ed33ce5aafca03da962d32" args="" -->
#define <b>Apop_data_row</b>&#160;&#160;&#160;<a class="el" href="apop_8h.html#af9032e16affac10d90dd3565e709966d">Apop_row</a>   #deprecated
<li><a class="anchor" id="a8ea91078c9065ed7f8e125eac7b64406"></a><!-- doxytag: member="apop.h::APOP_ROWS" ref="a8ea91078c9065ed7f8e125eac7b64406" args="" -->
#define <b>APOP_ROWS</b>&#160;&#160;&#160;<a class="el" href="apop_8h.html#aad1642d90f82ef1f5870a2de4e807005">Apop_rows</a>
<li><a class="anchor" id="ae1bdf071631bdc4b6641e96f77c087e1"></a><!-- doxytag: member="apop.h::apop_rows" ref="ae1bdf071631bdc4b6641e96f77c087e1" args="" -->
#define <b>apop_rows</b>&#160;&#160;&#160;<a class="el" href="apop_8h.html#aad1642d90f82ef1f5870a2de4e807005">Apop_rows</a>
<li><a class="anchor" id="a845facd4e5c6f62af3661e50b3fd3e88"></a><!-- doxytag: member="apop.h::APOP_ROW_T" ref="a845facd4e5c6f62af3661e50b3fd3e88" args="" -->
#define <b>APOP_ROW_T</b>&#160;&#160;&#160;<a class="el" href="apop_8h.html#a7d87af4e65acbf6982a34cf3dc33eae6">Apop_row_t</a>
<li><a class="anchor" id="ae768ac25fe2e1392becb3f45bd1b378d"></a><!-- doxytag: member="apop.h::apop_row_t" ref="ae768ac25fe2e1392becb3f45bd1b378d" args="" -->
#define <b>apop_row_t</b>&#160;&#160;&#160;<a class="el" href="apop_8h.html#a7d87af4e65acbf6982a34cf3dc33eae6">Apop_row_t</a>
<li><a class="anchor" id="a4f9aa6a71945eff937ed422bfe53d507"></a><!-- doxytag: member="apop.h::APOP_ROW_TV" ref="a4f9aa6a71945eff937ed422bfe53d507" args="" -->
#define <b>APOP_ROW_TV</b>&#160;&#160;&#160;<a class="el" href="apop_8h.html#a6396c26f1d47cced2be3a761185d3b35">Apop_row_tv</a>
<li><a class="anchor" id="aff93bd8638a66a672e53d5a4fef26a58"></a><!-- doxytag: member="apop.h::apop_row_tv" ref="aff93bd8638a66a672e53d5a4fef26a58" args="" -->
#define <b>apop_row_tv</b>&#160;&#160;&#160;<a class="el" href="apop_8h.html#a6396c26f1d47cced2be3a761185d3b35">Apop_row_tv</a>
<li><a class="anchor" id="a8456f3e332c041eeccb5ec6fe38a150b"></a><!-- doxytag: member="apop.h::APOP_ROW_V" ref="a8456f3e332c041eeccb5ec6fe38a150b" args="" -->
#define <b>APOP_ROW_V</b>&#160;&#160;&#160;<a class="el" href="apop_8h.html#a39fd40c5f39795c077716dbaf122d270">Apop_row_v</a>
<li><a class="anchor" id="acae7cb5a7711c255a76070fb6156d59a"></a><!-- doxytag: member="apop.h::apop_row_v" ref="acae7cb5a7711c255a76070fb6156d59a" args="" -->
#define <b>apop_row_v</b>&#160;&#160;&#160;<a class="el" href="apop_8h.html#a39fd40c5f39795c077716dbaf122d270">Apop_row_v</a>
<li>#define <a class="el" href="apop_8h.html#a9abee86763f92d505fd4fb792f06fd7c">Apop_matrix_row</a>(m, row, v)
<li>#define <a class="el" href="apop_8h.html#a3e7f99e26eb4d5d5438fd5fa16fcadde">Apop_matrix_col</a>(m, col, v)
<li>#define <a class="el" href="apop_8h.html#a8c66c0e920b1898f13c58174ef2fbf86">Apop_submatrix</a>&#160;&#160;&#160;APOP_SUBMATRIX
<li><a class="anchor" id="a8a70a9fff4f3a0efedb583066e6caac9"></a><!-- doxytag: member="apop.h::APOP_MATRIX_ROW" ref="a8a70a9fff4f3a0efedb583066e6caac9" args="" -->
#define <b>APOP_MATRIX_ROW</b>&#160;&#160;&#160;<a class="el" href="apop_8h.html#a9abee86763f92d505fd4fb792f06fd7c">Apop_matrix_row</a>
<li><a class="anchor" id="ad8d0f6f694fdca12dd10bc2fee643609"></a><!-- doxytag: member="apop.h::apop_matrix_row" ref="ad8d0f6f694fdca12dd10bc2fee643609" args="" -->
#define <b>apop_matrix_row</b>&#160;&#160;&#160;<a class="el" href="apop_8h.html#a9abee86763f92d505fd4fb792f06fd7c">Apop_matrix_row</a>
<li><a class="anchor" id="a51cb56786000f7dbd82fbeeae47ac60c"></a><!-- doxytag: member="apop.h::APOP_MATRIX_COL" ref="a51cb56786000f7dbd82fbeeae47ac60c" args="" -->
#define <b>APOP_MATRIX_COL</b>&#160;&#160;&#160;<a class="el" href="apop_8h.html#a3e7f99e26eb4d5d5438fd5fa16fcadde">Apop_matrix_col</a>
<li><a class="anchor" id="a23b451a0240fbebdd7a95547269c2bde"></a><!-- doxytag: member="apop.h::apop_matrix_col" ref="a23b451a0240fbebdd7a95547269c2bde" args="" -->
#define <b>apop_matrix_col</b>&#160;&#160;&#160;<a class="el" href="apop_8h.html#a3e7f99e26eb4d5d5438fd5fa16fcadde">Apop_matrix_col</a>
<li>#define <a class="el" href="group__convenience__fns.html#ga7f85a98b61078ba3dc273f17eddd34a7">apop_sum</a>(in)&#160;&#160;&#160;<a class="el" href="group__convenience__fns.html#gaf6182181dd424bc4de98b4bfbd349b4e">apop_vector_sum</a>(in)
<li>#define <a class="el" href="group__vector__moments.html#gacc311abe133963c7959162a7d3d83fb8">apop_var</a>(in)&#160;&#160;&#160;<a class="el" href="apop__stats_8c.html#adcc397ab90933d79b3062206301a0aa0">apop_vector_var</a>(in)
<li>#define <a class="el" href="group__vector__moments.html#ga0f69c8414f1d93fa15f3a631710dcd7a">apop_mean</a>(in)
<li>#define <a class="el" href="group__settings.html#gaafba071ab93465fed4cac1020082b4c8">Apop_settings_get_group</a>(m, type)
<li>#define <a class="el" href="group__settings.html#ga4ff4361f65c1e848fabce24b4b8f44f7">Apop_settings_rm_group</a>(m, type)
<li>#define <a class="el" href="group__settings.html#ga8fb1877a3cc29edd685a68dd6b4a35dc">Apop_settings_add_group</a>(model, type,...)
<li>#define <a class="el" href="group__settings.html#ga8e5f7950ae47b299e20f2c447199cf6f">apop_model_copy_set</a>(model, type,...)
<li>#define <a class="el" href="group__settings.html#ga4ba53402807c9e6b82254fb552029501">Apop_settings_get</a>(model, type, setting)
<li>#define <a class="el" href="group__settings.html#ga8659282b6003f7c2adac6f4baad5fae4">Apop_settings_set</a>(model, type, setting, data)
<li>#define <a class="el" href="apop_8h.html#aae80181842102bf58ba1ffe18391796b">Apop_settings_declarations</a>(ysg)
<li>#define <a class="el" href="apop_8h.html#aefe030e4bba4671d8b026e81be70f764">Apop_settings_init</a>(name,...)
<li><a class="anchor" id="a75a1a67c02587093d62095f3aa56c690"></a><!-- doxytag: member="apop.h::Apop_varad_set" ref="a75a1a67c02587093d62095f3aa56c690" args="(var, value)" -->
#define <b>Apop_varad_set</b>(var, value)&#160;&#160;&#160;(out)-&gt;var = (in).var ? (in).var : (value);
<li>#define <a class="el" href="apop_8h.html#a47600802191d9ccf5d48fce70e754294">Apop_settings_copy</a>(name,...)
<li>#define <a class="el" href="apop_8h.html#a833e962fb042462eeadada7484671f07">Apop_settings_free</a>(name,...)
<li>#define <a class="el" href="apop_8h.html#a15d9e73643bf66f7d69c7ebf959757aa">apop_model_coordinate_transform</a>(...)&#160;&#160;&#160;Apop_model_copy_set(<a class="el" href="group__models.html#ga80caa743557a86dffa2dd1db64421d82">apop_coordinate_transform</a>, apop_ct, __VA_ARGS__)
<li>#define <a class="el" href="apop_8h.html#ab664f68b5e481bec56c8ddc7f16928c0">apop_model_dcompose</a>(...)&#160;&#160;&#160;Apop_model_copy_set(apop_composition, apop_composition, __VA_ARGS__)
<li>#define <a class="el" href="apop_8h.html#a34644b9d55c7528b47f0b887c9241928">apop_model_dconstrain</a>(...)&#160;&#160;&#160;Apop_model_copy_set(<a class="el" href="group__models.html#gaa58cece77dea73979ea15d64ea11b049">apop_dconstrain</a>, <a class="el" href="group__models.html#gaa58cece77dea73979ea15d64ea11b049">apop_dconstrain</a>, __VA_ARGS__)
</ul>
<h2><a name="typedef-members"></a>
Typedefs</h2>
<ul>
<li>typedef struct <a class="el" href="structapop__data.html">apop_data</a> <a class="el" href="apop_8h.html#a0c8c2a99fb8c6ec54822aca08591545e">apop_data</a>
<li>typedef struct <a class="el" href="structapop__model.html">apop_model</a> <a class="el" href="apop_8h.html#afe86ae10fc82d219906211e4f88e4cf9">apop_model</a>
<li><a class="anchor" id="a41dcb5886b9edec739a7f5cec33f4130"></a><!-- doxytag: member="apop.h::apop_update_type" ref="a41dcb5886b9edec739a7f5cec33f4130" args=")(apop_data *, apop_model *, apop_model *)" -->
typedef <a class="el" href="structapop__model.html">apop_model</a> *(* <b>apop_update_type</b> )(<a class="el" href="structapop__data.html">apop_data</a> *, <a class="el" href="structapop__model.html">apop_model</a> *, <a class="el" href="structapop__model.html">apop_model</a> *)
<li><a class="anchor" id="a8dfc71e4980302f108120eaf7c927597"></a><!-- doxytag: member="apop.h::apop_score_type" ref="a8dfc71e4980302f108120eaf7c927597" args=")(apop_data *d, gsl_vector *gradient, apop_model *params)" -->
typedef void(* <b>apop_score_type</b> )(<a class="el" href="structapop__data.html">apop_data</a> *d, gsl_vector *gradient, <a class="el" href="structapop__model.html">apop_model</a> *params)
<li><a class="anchor" id="a8eec9a66311eee142fa2bfe977371066"></a><!-- doxytag: member="apop.h::apop_parameter_model_type" ref="a8eec9a66311eee142fa2bfe977371066" args=")(apop_data *, apop_model *)" -->
typedef <a class="el" href="structapop__model.html">apop_model</a> *(* <b>apop_parameter_model_type</b> )(<a class="el" href="structapop__data.html">apop_data</a> *, <a class="el" href="structapop__model.html">apop_model</a> *)
<li><a class="anchor" id="a3abcede60ca88af403cd0d7f00b884e2"></a><!-- doxytag: member="apop.h::apop_predict_type" ref="a3abcede60ca88af403cd0d7f00b884e2" args=")(apop_data *d, apop_model *params)" -->
typedef <a class="el" href="structapop__data.html">apop_data</a> *(* <b>apop_predict_type</b> )(<a class="el" href="structapop__data.html">apop_data</a> *d, <a class="el" href="structapop__model.html">apop_model</a> *params)
<li><a class="anchor" id="af691684798094626c0f43a5ca55e9a9e"></a><!-- doxytag: member="apop.h::apop_model_print_type" ref="af691684798094626c0f43a5ca55e9a9e" args=")(apop_model *params, FILE *out)" -->
typedef void(* <b>apop_model_print_type</b> )(<a class="el" href="structapop__model.html">apop_model</a> *params, FILE *out)
</ul>
<h2><a name="func-members"></a>
Functions</h2>
<ul>
<li><a class="el" href="structapop__name.html">apop_name</a> * <a class="el" href="apop_8h.html#a29ff289eb3d86e1ba5b06e5064a3286f">apop_name_alloc</a> (void)
<li>int <a class="el" href="apop_8h.html#ae32d4f48cff7788b617d40155703ae64">apop_name_add</a> (<a class="el" href="structapop__name.html">apop_name</a> *n, char const *add_me, char type)
<li>void <a class="el" href="apop_8h.html#a62a9c548fc646f28518bb1edb84dafc6">apop_name_free</a> (<a class="el" href="structapop__name.html">apop_name</a> *free_me)
<li>void <a class="el" href="apop_8h.html#af7220e4b2fe43c56593af0ceb2c7001a">apop_name_print</a> (<a class="el" href="structapop__name.html">apop_name</a> *n)
<li>void <a class="el" href="apop_8h.html#ab4fd369dba75ec4782400cf7378e56ec">apop_name_stack</a> (<a class="el" href="structapop__name.html">apop_name</a> *n1, <a class="el" href="structapop__name.html">apop_name</a> *nadd, char type1, char typeadd)
<li><a class="el" href="structapop__name.html">apop_name</a> * <a class="el" href="apop_8h.html#ad865208febeeb8cfce2f1d90e13db07a">apop_name_copy</a> (<a class="el" href="structapop__name.html">apop_name</a> *in)
<li>int <a class="el" href="apop_8h.html#adb1398925a93b7c2c502af8fb2abc49e">apop_name_find</a> (const <a class="el" href="structapop__name.html">apop_name</a> *n, const char *findme, const char type)
<li><a class="anchor" id="a1b050ee3cfbb8858576bca6ae07571df"></a><!-- doxytag: member="apop.h::apop_data_add_names_base" ref="a1b050ee3cfbb8858576bca6ae07571df" args="(apop_data *d, const char type, char const **names)" -->
void <b>apop_data_add_names_base</b> (<a class="el" href="structapop__data.html">apop_data</a> *d, const char type, char const **names)
<li>char <a class="el" href="apop_8h.html#a3e8377359d46c9bd02ea57205e7968d3">apop_data_free_base</a> (<a class="el" href="structapop__data.html">apop_data</a> *freeme)
<li><a class="el" href="structapop__data.html">apop_data</a> * <a class="el" href="apop_8h.html#ac0674dcc81232e37c27f612499495bd4">apop_matrix_to_data</a> (gsl_matrix *m)
<li><a class="el" href="structapop__data.html">apop_data</a> * <a class="el" href="apop_8h.html#a4a69e915d2b6c40f9c69ec1842e2d689">apop_vector_to_data</a> (gsl_vector *v)
<li><a class="el" href="structapop__data.html">apop_data</a> * <a class="el" href="apop_8h.html#ac39d6a56933b6f084328ec5ecd5090d8">apop_data_alloc</a> (const size_t size1, const size_t size2, const int size3)
<li><a class="el" href="structapop__data.html">apop_data</a> * <a class="el" href="apop_8h.html#a0460790f2d21f03856ed4a212a4132ec">apop_data_calloc</a> (const size_t size1, const size_t size2, const int size3)
<li><a class="el" href="structapop__data.html">apop_data</a> * <a class="el" href="apop_8h.html#a0f2ffb5c5ba2bb240e930be08fc4fd56">apop_data_stack</a> (<a class="el" href="structapop__data.html">apop_data</a> *m1, <a class="el" href="structapop__data.html">apop_data</a> *m2, char posn, char inplace)
<li><a class="el" href="structapop__data.html">apop_data</a> ** <a class="el" href="apop_8h.html#aef0284036801cb75d465a1738f65397e">apop_data_split</a> (<a class="el" href="structapop__data.html">apop_data</a> *in, int splitpoint, char r_or_c)
<li><a class="el" href="structapop__data.html">apop_data</a> * <a class="el" href="apop_8h.html#add67e6838ce2521a1d756894dc9b5ccf">apop_data_copy</a> (const <a class="el" href="structapop__data.html">apop_data</a> *in)
<li>void <a class="el" href="apop_8h.html#a1312f6568cfe832f1e35f7f44482ffb4">apop_data_rm_columns</a> (<a class="el" href="structapop__data.html">apop_data</a> *d, int *drop)
<li>void <a class="el" href="apop_8h.html#aa24d396c7fda38bc4ab03a3ba2db4943">apop_data_memcpy</a> (<a class="el" href="structapop__data.html">apop_data</a> *out, const <a class="el" href="structapop__data.html">apop_data</a> *in)
<li>double * <a class="el" href="group__data__set__get.html#ga59d1c0299c7eb87224bc6c60555784fe">apop_data_ptr</a> (<a class="el" href="structapop__data.html">apop_data</a> *data, int row, int col, const char *rowname, const char *colname, const char *page)
<li>double <a class="el" href="group__data__set__get.html#ga06107779e4a3eb229715ceca24352b89">apop_data_get</a> (const <a class="el" href="structapop__data.html">apop_data</a> *data, size_t row, int col, const char *rowname, const char *colname, const char *page)
<li>int <a class="el" href="group__data__set__get.html#gaea55629952c595bc8211d3333077dc51">apop_data_set</a> (<a class="el" href="structapop__data.html">apop_data</a> *data, size_t row, int col, const double val, const char *rowname, const char *colname, const char *page)
<li>void <a class="el" href="apop_8h.html#a44b767b375fb18f61f939c6869955331">apop_data_add_named_elmt</a> (<a class="el" href="structapop__data.html">apop_data</a> *d, char *name, double val)
<li>int <a class="el" href="apop_8h.html#ac9c6f645acce82319fb85eb9d75112ba">apop_text_add</a> (<a class="el" href="structapop__data.html">apop_data</a> *in, const size_t row, const size_t col, const char *fmt,...)
<li><a class="el" href="structapop__data.html">apop_data</a> * <a class="el" href="apop_8h.html#a9fba0f07c262a433133f6f3362617da3">apop_text_alloc</a> (<a class="el" href="structapop__data.html">apop_data</a> *in, const size_t row, const size_t col)
<li>void <a class="el" href="apop_8h.html#a65386d7b37c2eaf37d1eb4e3ae7a7554">apop_text_free</a> (char ***freeme, int rows, int cols)
<li><a class="el" href="structapop__data.html">apop_data</a> * <a class="el" href="apop_8h.html#a82281b8673cda3645054d7e061bb1167">apop_data_transpose</a> (<a class="el" href="structapop__data.html">apop_data</a> *in, char transpose_text, char inplace)
<li>gsl_matrix * <a class="el" href="apop_8h.html#aa06b6ab6ec9f78f305b1dacc8ec2efd3">apop_matrix_realloc</a> (gsl_matrix *m, size_t newheight, size_t newwidth)
<li>gsl_vector * <a class="el" href="apop_8h.html#af4658a3ecc0acfd17f610bc162fa5556">apop_vector_realloc</a> (gsl_vector *v, size_t newheight)
<li><a class="el" href="structapop__data.html">apop_data</a> * <a class="el" href="apop_8h.html#ad1efbe058d6ca85ece023eb471c66e58">apop_data_prune_columns_base</a> (<a class="el" href="structapop__data.html">apop_data</a> *d, char **colnames)
<li><a class="el" href="structapop__data.html">apop_data</a> * <a class="el" href="apop_8h.html#a044771db76f0afb410a8d4f05ac51ca3">apop_data_get_page</a> (const <a class="el" href="structapop__data.html">apop_data</a> *data, const char *title, const char match)
<li><a class="el" href="structapop__data.html">apop_data</a> * <a class="el" href="apop_8h.html#a7e7e530a692571a403e5837fda5e0f12">apop_data_add_page</a> (<a class="el" href="structapop__data.html">apop_data</a> *dataset, <a class="el" href="structapop__data.html">apop_data</a> *newpage, const char *title)
<li><a class="el" href="structapop__data.html">apop_data</a> * <a class="el" href="apop_8h.html#ac434c9d08b6a8304107d9c93afb81914">apop_data_rm_page</a> (<a class="el" href="structapop__data.html">apop_data</a> *data, const char *title, const char free_p)
<li><a class="el" href="structapop__data.html">apop_data</a> * <a class="el" href="apop_8h.html#ae2ab3a4f332adb368fe970619a8c0252">apop_data_rm_rows</a> (<a class="el" href="structapop__data.html">apop_data</a> *in, int *drop, int(*do_drop)(<a class="el" href="structapop__data.html">apop_data</a> *, void *), void *drop_parameter)
<li><a class="el" href="structapop__data.html">apop_data</a> * <a class="el" href="apop_8h.html#a4e204cdc7429bef3ca2efb83453fe77a">apop_model_draws</a> (<a class="el" href="structapop__model.html">apop_model</a> *model, int count, <a class="el" href="structapop__data.html">apop_data</a> *draws)
<li>gsl_vector * <a class="el" href="group__convenience__fns.html#ga5baf0e8717a30fdcfba350da904c1825">apop_vector_copy</a> (const gsl_vector *in)
<li>gsl_matrix * <a class="el" href="group__conversions.html#ga604388dc6d7d08d95bbaa4422085db9c">apop_vector_to_matrix</a> (const gsl_vector *in, char row_col)
<li>gsl_matrix * <a class="el" href="group__convenience__fns.html#ga45bb322b9f491c46feb1e24025b6301f">apop_matrix_copy</a> (const gsl_matrix *in)
<li><a class="el" href="structapop__data.html">apop_data</a> * <a class="el" href="apop_8h.html#aebe17fe6f2b0c49c0c90824b7a68ff90">apop_db_to_crosstab</a> (char *tabname, char *r1, char *r2, char *datacol)
<li>gsl_vector * <a class="el" href="group__conversions.html#ga8abdcdbaceaaf0dd3882a164bc2565de">apop_array_to_vector</a> (double *in, int size)
<li><a class="el" href="structapop__data.html">apop_data</a> * <a class="el" href="group__conversions.html#ga630de5d4fcbe9ef13373029f5d813a97">apop_text_to_data</a> (char const *text_file, int has_row_names, int has_col_names, int const *field_ends, char const *delimiters)
<li>int <a class="el" href="group__conversions.html#gabd00e16791a970631c3ed4ac3487da46">apop_text_to_db</a> (char const *text_file, char *tabname, int has_row_names, int has_col_names, char **field_names, int const *field_ends, <a class="el" href="structapop__data.html">apop_data</a> *field_params, char *table_params, char const *delimiters, char if_table_exists)
<li><a class="el" href="structapop__data.html">apop_data</a> * <a class="el" href="apop_8h.html#a2feb17743f8b07b8ddcf457362cabefc">apop_data_rank_expand</a> (<a class="el" href="structapop__data.html">apop_data</a> *in)
<li><a class="el" href="structapop__data.html">apop_data</a> * <a class="el" href="apop_8h.html#a8c4bb25171301f09a35c36306a7b9783">apop_data_rank_compress</a> (<a class="el" href="structapop__data.html">apop_data</a> *in)
<li>void <a class="el" href="apop_8h.html#aee8c299b83b8500b8b6ecd30817353c8">apop_crosstab_to_db</a> (<a class="el" href="structapop__data.html">apop_data</a> *in, char *tabname, char *row_col_name, char *col_col_name, char *data_col_name)
<li>gsl_vector * <a class="el" href="group__conversions.html#ga7e31798ab418cbfc7488eaba27dad2af">apop_data_pack</a> (const <a class="el" href="structapop__data.html">apop_data</a> *in, gsl_vector *out, char all_pages, char use_info_pages)
<li>void <a class="el" href="group__conversions.html#gae3058b7f39d0442f13284464d1ba235d">apop_data_unpack</a> (const gsl_vector *in, <a class="el" href="structapop__data.html">apop_data</a> *d, char use_info_pages)
<li><a class="anchor" id="a9801d051a0ea37b5f7516a70b4054188"></a><!-- doxytag: member="apop.h::apop_data_fill_base" ref="a9801d051a0ea37b5f7516a70b4054188" args="(apop_data *in, double[])" -->
<a class="el" href="structapop__data.html">apop_data</a> * <b>apop_data_fill_base</b> (<a class="el" href="structapop__data.html">apop_data</a> *in, double[])
<li><a class="anchor" id="a0b73de331ecf350babafa9418795860d"></a><!-- doxytag: member="apop.h::apop_vector_fill_base" ref="a0b73de331ecf350babafa9418795860d" args="(gsl_vector *in, double[])" -->
gsl_vector * <b>apop_vector_fill_base</b> (gsl_vector *in, double[])
<li><a class="anchor" id="a1fd20a9fd056845b5469b6d3bb48c653"></a><!-- doxytag: member="apop.h::apop_text_fill_base" ref="a1fd20a9fd056845b5469b6d3bb48c653" args="(apop_data *data, char *text[])" -->
<a class="el" href="structapop__data.html">apop_data</a> * <b>apop_text_fill_base</b> (<a class="el" href="structapop__data.html">apop_data</a> *data, char *text[])
<li>int <a class="el" href="apop_8h.html#a47313d1f22af539e43f5ff02dd0e8f90">apop_data_set_row</a> (<a class="el" href="structapop__data.html">apop_data</a> *row, <a class="el" href="structapop__data.html">apop_data</a> *d, int row_number)
<li>void <a class="el" href="group__models.html#gab29755a86b82dfe31cdd01d55431cc09">apop_model_free</a> (<a class="el" href="structapop__model.html">apop_model</a> *free_me)
<li>void <a class="el" href="group__output.html#gab7bf9adff9b97c60c5839ae72ba4fb7f">apop_model_print</a> (<a class="el" href="structapop__model.html">apop_model</a> *print_me, FILE *out)
<li><a class="anchor" id="a4fa08e29db38e8dcc111899c942022d9"></a><!-- doxytag: member="apop.h::apop_model_show" ref="a4fa08e29db38e8dcc111899c942022d9" args="(apop_model *print_me)" -->
void <b>apop_model_show</b> (<a class="el" href="structapop__model.html">apop_model</a> *print_me)
<li><a class="el" href="structapop__model.html">apop_model</a> * <a class="el" href="group__models.html#ga87d3a65f43071b9d61d9edd59249c629">apop_model_copy</a> (<a class="el" href="structapop__model.html">apop_model</a> *in)
<li><a class="el" href="structapop__model.html">apop_model</a> * <a class="el" href="group__models.html#gaa86381a72949fd3ffafefa87e3f51a4f">apop_model_clear</a> (<a class="el" href="structapop__data.html">apop_data</a> *data, <a class="el" href="structapop__model.html">apop_model</a> *model)
<li><a class="el" href="structapop__model.html">apop_model</a> * <a class="el" href="group__models.html#ga2c0598e5aca68949939a189bd4ce24ca">apop_estimate</a> (<a class="el" href="structapop__data.html">apop_data</a> *d, <a class="el" href="structapop__model.html">apop_model</a> *m)
<li>void <a class="el" href="group__models.html#ga228b013bc80f308900882312cab93eb3">apop_score</a> (<a class="el" href="structapop__data.html">apop_data</a> *d, gsl_vector *out, <a class="el" href="structapop__model.html">apop_model</a> *m)
<li>double <a class="el" href="group__models.html#ga5e160c8d0a0ee660c89fb3f6de2af89c">apop_log_likelihood</a> (<a class="el" href="structapop__data.html">apop_data</a> *d, <a class="el" href="structapop__model.html">apop_model</a> *m)
<li>double <a class="el" href="group__models.html#ga2510c7df8ccd834732ee208005738b0f">apop_p</a> (<a class="el" href="structapop__data.html">apop_data</a> *d, <a class="el" href="structapop__model.html">apop_model</a> *m)
<li>double <a class="el" href="group__models.html#gaee16258d3e52671e254f3ce03bca7754">apop_cdf</a> (<a class="el" href="structapop__data.html">apop_data</a> *d, <a class="el" href="structapop__model.html">apop_model</a> *m)
<li>int <a class="el" href="group__models.html#ga87f15cd1923ed7b5b46e52a77ca1dfef">apop_draw</a> (double *out, gsl_rng *r, <a class="el" href="structapop__model.html">apop_model</a> *m)
<li>void <a class="el" href="group__models.html#ga373ccc4cb87b162d62d07a2685ccd8ba">apop_prep</a> (<a class="el" href="structapop__data.html">apop_data</a> *d, <a class="el" href="structapop__model.html">apop_model</a> *m)
<li><a class="el" href="structapop__model.html">apop_model</a> * <a class="el" href="group__models.html#ga92355da54ab91a8dee22192ae68a37d0">apop_parameter_model</a> (<a class="el" href="structapop__data.html">apop_data</a> *d, <a class="el" href="structapop__model.html">apop_model</a> *m)
<li><a class="el" href="structapop__data.html">apop_data</a> * <a class="el" href="group__models.html#ga867f0b8df261866bb18e9040871c51f0">apop_predict</a> (<a class="el" href="structapop__data.html">apop_data</a> *d, <a class="el" href="structapop__model.html">apop_model</a> *m)
<li><a class="el" href="structapop__model.html">apop_model</a> * <a class="el" href="apop_8h.html#a69adca14afc66100168f585e05b59dcb">apop_beta_from_mean_var</a> (double m, double v)
<li><a class="anchor" id="a0b818ff6672229f10c3e559ba9cffb65"></a><!-- doxytag: member="apop.h::apop_model_set_parameters_base" ref="a0b818ff6672229f10c3e559ba9cffb65" args="(apop_model *in, double ap[])" -->
<a class="el" href="structapop__model.html">apop_model</a> * <b>apop_model_set_parameters_base</b> (<a class="el" href="structapop__model.html">apop_model</a> *in, double ap[])
<li><a class="anchor" id="a5f10c642ac9a8c9342da4530de1a4e95"></a><!-- doxytag: member="apop.h::apop_model_mixture_base" ref="a5f10c642ac9a8c9342da4530de1a4e95" args="(apop_model **inlist)" -->
<a class="el" href="structapop__model.html">apop_model</a> * <b>apop_model_mixture_base</b> (<a class="el" href="structapop__model.html">apop_model</a> **inlist)
<li><a class="anchor" id="a4c5afbd3068134ca9b20997e132d132f"></a><!-- doxytag: member="apop.h::apop_model_stack_base" ref="a4c5afbd3068134ca9b20997e132d132f" args="(apop_model *mlist[])" -->
<a class="el" href="structapop__model.html">apop_model</a> * <b>apop_model_stack_base</b> (<a class="el" href="structapop__model.html">apop_model</a> *mlist[])
<li><a class="anchor" id="aad65cf464db938a7fbd57de43dfe1c87"></a><!-- doxytag: member="apop.h::apop_map" ref="aad65cf464db938a7fbd57de43dfe1c87" args="(apop_data *in, double(*fn_d)(double), double(*fn_v)(gsl_vector *), double(*fn_r)(apop_data *), double(*fn_dp)(double, void *), double(*fn_vp)(gsl_vector *, void *), double(*fn_rp)(apop_data *, void *), double(*fn_dpi)(double, void *, int), double(*fn_vpi)(gsl_vector *, void *, int), double(*fn_rpi)(apop_data *, void *, int), double(*fn_di)(double, int), double(*fn_vi)(gsl_vector *, int), double(*fn_ri)(apop_data *, int), void *param, int inplace, char part, int all_pages)" -->
<a class="el" href="structapop__data.html">apop_data</a> * <b>apop_map</b> (<a class="el" href="structapop__data.html">apop_data</a> *in, double(*fn_d)(double), double(*fn_v)(gsl_vector *), double(*fn_r)(<a class="el" href="structapop__data.html">apop_data</a> *), double(*fn_dp)(double, void *), double(*fn_vp)(gsl_vector *, void *), double(*fn_rp)(<a class="el" href="structapop__data.html">apop_data</a> *, void *), double(*fn_dpi)(double, void *, int), double(*fn_vpi)(gsl_vector *, void *, int), double(*fn_rpi)(<a class="el" href="structapop__data.html">apop_data</a> *, void *, int), double(*fn_di)(double, int), double(*fn_vi)(gsl_vector *, int), double(*fn_ri)(<a class="el" href="structapop__data.html">apop_data</a> *, int), void *param, int inplace, char part, int all_pages)
<li><a class="anchor" id="a871b9e67a6ae243f7420e6943e28e8a0"></a><!-- doxytag: member="apop.h::apop_map_sum" ref="a871b9e67a6ae243f7420e6943e28e8a0" args="(apop_data *in, double(*fn_d)(double), double(*fn_v)(gsl_vector *), double(*fn_r)(apop_data *), double(*fn_dp)(double, void *), double(*fn_vp)(gsl_vector *, void *), double(*fn_rp)(apop_data *, void *), double(*fn_dpi)(double, void *, int), double(*fn_vpi)(gsl_vector *, void *, int), double(*fn_rpi)(apop_data *, void *, int), double(*fn_di)(double, int), double(*fn_vi)(gsl_vector *, int), double(*fn_ri)(apop_data *, int), void *param, char part, int all_pages)" -->
double <b>apop_map_sum</b> (<a class="el" href="structapop__data.html">apop_data</a> *in, double(*fn_d)(double), double(*fn_v)(gsl_vector *), double(*fn_r)(<a class="el" href="structapop__data.html">apop_data</a> *), double(*fn_dp)(double, void *), double(*fn_vp)(gsl_vector *, void *), double(*fn_rp)(<a class="el" href="structapop__data.html">apop_data</a> *, void *), double(*fn_dpi)(double, void *, int), double(*fn_vpi)(gsl_vector *, void *, int), double(*fn_rpi)(<a class="el" href="structapop__data.html">apop_data</a> *, void *, int), double(*fn_di)(double, int), double(*fn_vi)(gsl_vector *, int), double(*fn_ri)(<a class="el" href="structapop__data.html">apop_data</a> *, int), void *param, char part, int all_pages)
<li>gsl_vector * <a class="el" href="group__mapply.html#ga5da5091a11c37d3501d678b8ecec466f">apop_matrix_map</a> (const gsl_matrix *m, double(*fn)(gsl_vector *))
<li>gsl_vector * <a class="el" href="group__mapply.html#gaf30eadf8772ecb9a2689ddf104902ea4">apop_vector_map</a> (const gsl_vector *v, double(*fn)(double))
<li>void <a class="el" href="group__mapply.html#ga5c4ae58b861199bbc1a460719942d98f">apop_matrix_apply</a> (gsl_matrix *m, void(*fn)(gsl_vector *))
<li>void <a class="el" href="group__mapply.html#ga51964750c64d327e52e2230019e44f66">apop_vector_apply</a> (gsl_vector *v, void(*fn)(double *))
<li>gsl_matrix * <a class="el" href="group__mapply.html#gab1df9cb7fdd56e48593d99f5122224d7">apop_matrix_map_all</a> (const gsl_matrix *in, double(*fn)(double))
<li>void <a class="el" href="group__mapply.html#ga163589e9f5cb08f88f2032fc1229ec6f">apop_matrix_apply_all</a> (gsl_matrix *in, void(*fn)(double *))
<li>double <a class="el" href="group__mapply.html#gaa1a135fcdd8ea6f9cbc0d518773d6c3c">apop_vector_map_sum</a> (const gsl_vector *in, double(*fn)(double))
<li>double <a class="el" href="group__mapply.html#ga4f0c51a046140b563c8e12a6032e9a16">apop_matrix_map_sum</a> (const gsl_matrix *in, double(*fn)(gsl_vector *))
<li>double <a class="el" href="group__mapply.html#gae04bc576579bfb2e14d5004d4af7bb88">apop_matrix_map_all_sum</a> (const gsl_matrix *in, double(*fn)(double))
<li><a class="anchor" id="a5476bc91f3678aa20532a11430f2ab49"></a><!-- doxytag: member="apop.h::apop_plot_line_and_scatter" ref="a5476bc91f3678aa20532a11430f2ab49" args="(apop_data *data, apop_model *est, char const *output_name, FILE *output_pipe, char output_type, char output_append)" -->
void <b>apop_plot_line_and_scatter</b> (<a class="el" href="structapop__data.html">apop_data</a> *data, <a class="el" href="structapop__model.html">apop_model</a> *est, char const *output_name, FILE *output_pipe, char output_type, char output_append)
<li><a class="anchor" id="a4502235c35ff5724f8988e993b81ace1"></a><!-- doxytag: member="apop.h::apop_plot_histogram" ref="a4502235c35ff5724f8988e993b81ace1" args="(gsl_vector *data, size_t bin_count, char *with, char const *output_name, FILE *output_pipe, char output_type, char output_append)" -->
void <b>apop_plot_histogram</b> (gsl_vector *data, size_t bin_count, char *with, char const *output_name, FILE *output_pipe, char output_type, char output_append)
<li><a class="anchor" id="af95b34d17a482cff5a2d39f43b1b0492"></a><!-- doxytag: member="apop.h::apop_plot_lattice" ref="af95b34d17a482cff5a2d39f43b1b0492" args="(const apop_data *d, char const *output_name, FILE *output_pipe, char output_type, char output_append)" -->
void <b>apop_plot_lattice</b> (const <a class="el" href="structapop__data.html">apop_data</a> *d, char const *output_name, FILE *output_pipe, char output_type, char output_append)
<li><a class="anchor" id="ae5949456cfb7bbdcffd295277014a9d6"></a><!-- doxytag: member="apop.h::apop_plot_qq" ref="ae5949456cfb7bbdcffd295277014a9d6" args="(gsl_vector *v, apop_model *m, char const *output_name, FILE *output_pipe, char output_type, char output_append, size_t bins, gsl_rng *r)" -->
void <b>apop_plot_qq</b> (gsl_vector *v, <a class="el" href="structapop__model.html">apop_model</a> *m, char const *output_name, FILE *output_pipe, char output_type, char output_append, size_t bins, gsl_rng *r)
<li><a class="anchor" id="a3152bfa335887b01080e30f72d96f4b3"></a><!-- doxytag: member="apop.h::apop_plot_triangle" ref="a3152bfa335887b01080e30f72d96f4b3" args="(apop_data *in, char const *output_name, FILE *output_pipe, char output_type, char output_append)" -->
void <b>apop_plot_triangle</b> (<a class="el" href="structapop__data.html">apop_data</a> *in, char const *output_name, FILE *output_pipe, char output_type, char output_append)
<li><a class="anchor" id="a7ff17c62bcd3dd808393c9de53751195"></a><!-- doxytag: member="apop.h::apop_matrix_print" ref="a7ff17c62bcd3dd808393c9de53751195" args="(const gsl_matrix *data, char const *output_name, FILE *output_pipe, char output_type, char output_append)" -->
void <b>apop_matrix_print</b> (const gsl_matrix *data, char const *output_name, FILE *output_pipe, char output_type, char output_append)
<li><a class="anchor" id="ad3d4b5805cf1a72d302fb84405215809"></a><!-- doxytag: member="apop.h::apop_vector_print" ref="ad3d4b5805cf1a72d302fb84405215809" args="(gsl_vector *data, char const *output_name, FILE *output_pipe, char output_type, char output_append)" -->
void <b>apop_vector_print</b> (gsl_vector *data, char const *output_name, FILE *output_pipe, char output_type, char output_append)
<li><a class="anchor" id="a0e7309e87fb273a538b3c8cac2fae660"></a><!-- doxytag: member="apop.h::apop_data_print" ref="a0e7309e87fb273a538b3c8cac2fae660" args="(const apop_data *data, char const *output_name, FILE *output_pipe, char output_type, char output_append)" -->
void <b>apop_data_print</b> (const <a class="el" href="structapop__data.html">apop_data</a> *data, char const *output_name, FILE *output_pipe, char output_type, char output_append)
<li>void <a class="el" href="group__apop__print.html#gae7f619a8c83d791ce3d07bf4f6eecb32">apop_matrix_show</a> (const gsl_matrix *data)
<li>void <a class="el" href="group__apop__print.html#ga8eafc3727869f5ec195809ad6686ba7b">apop_vector_show</a> (const gsl_vector *data)
<li>void <a class="el" href="group__output.html#ga9a30c437ec11a11e37e0db7f82386275">apop_data_show</a> (const <a class="el" href="structapop__data.html">apop_data</a> *data)
<li>double <a class="el" href="apop_8h.html#ab20e5ad95df0f24a1ea06294695031a8">apop_vector_mean</a> (gsl_vector const *v, gsl_vector const *weights)
<li>double <a class="el" href="apop_8h.html#adcc397ab90933d79b3062206301a0aa0">apop_vector_var</a> (gsl_vector const *v, gsl_vector const *weights)
<li>double <a class="el" href="group__vector__moments.html#gafb284d668d567de4810620962043f827">apop_vector_skew_pop</a> (gsl_vector const *v, gsl_vector const *weights)
<li>double <a class="el" href="group__vector__moments.html#gaabe3183e8a6a496f3fd6ab316687381e">apop_vector_kurtosis_pop</a> (gsl_vector const *v, gsl_vector const *weights)
<li>double <a class="el" href="apop_8h.html#a7c0881e9b640f6c6448014f44f5ac1f5">apop_vector_cov</a> (gsl_vector const *v1, gsl_vector const *v2, gsl_vector const *weights)
<li>double <a class="el" href="group__convenience__fns.html#ga44a77f5e6867c627fd313f3f6e252ff8">apop_vector_distance</a> (const gsl_vector *ina, const gsl_vector *inb, const char metric, const double norm)
<li>void <a class="el" href="apop_8h.html#a194ad92b1bc632ba1d13d9958c7b5b4d">apop_vector_normalize</a> (gsl_vector *in, gsl_vector **out, const char normalization_type)
<li>void <a class="el" href="apop_8h.html#af6290c453c3012c1d0a6987688ebe795">apop_matrix_normalize</a> (gsl_matrix *data, const char row_or_col, const char normalization)
<li><a class="el" href="structapop__data.html">apop_data</a> * <a class="el" href="apop_8h.html#aeae37a5bf11cddee59e272b083a4efc7">apop_data_covariance</a> (const <a class="el" href="structapop__data.html">apop_data</a> *in)
<li><a class="el" href="structapop__data.html">apop_data</a> * <a class="el" href="apop_8h.html#afa3ab967f57f8ad3cfb99a4a82cfae02">apop_data_correlation</a> (const <a class="el" href="structapop__data.html">apop_data</a> *in)
<li>long double <a class="el" href="group__convenience__fns.html#ga369c774aac917e56d8e32f9c66d9c2a0">apop_matrix_sum</a> (const gsl_matrix *m)
<li>double <a class="el" href="group__convenience__fns.html#ga040b9e9fea1abe105de86081bf396d40">apop_matrix_mean</a> (const gsl_matrix *data)
<li>void <a class="el" href="group__convenience__fns.html#gaf794cc2491ef147e0c67eb05feed7a87">apop_matrix_mean_and_var</a> (const gsl_matrix *data, double *mean, double *var)
<li><a class="el" href="structapop__data.html">apop_data</a> * <a class="el" href="group__output.html#gaca60728fc3b691acfcadebf3a8535532">apop_data_summarize</a> (<a class="el" href="structapop__data.html">apop_data</a> *data)
<li><a class="el" href="structapop__data.html">apop_data</a> * <a class="el" href="apop_8h.html#a8627a1eebf904699e90e66adc8b4b021">apop_test_fisher_exact</a> (<a class="el" href="structapop__data.html">apop_data</a> *intab)
<li>int <a class="el" href="apop_8h.html#afc7707d44884aa63c298510a0662956a">apop_matrix_is_positive_semidefinite</a> (gsl_matrix *m, char semi)
<li>double <a class="el" href="apop_8h.html#af1fc93322ffcb4e20cfc0b9af9e2aea0">apop_matrix_to_positive_semidefinite</a> (gsl_matrix *m)
<li>long double <a class="el" href="apop_8h.html#a2c76ad8792959b6605402a1d71a1b6c9">apop_multivariate_gamma</a> (double a, int p)
<li>long double <a class="el" href="apop_8h.html#a180b231acc3c64d07664ed2b1a8ad0e1">apop_multivariate_lngamma</a> (double a, int p)
<li><a class="el" href="structapop__data.html">apop_data</a> * <a class="el" href="group__ttest.html#ga65c94b79fe91308dc97829741acc9322">apop_t_test</a> (gsl_vector *a, gsl_vector *b)
<li><a class="el" href="structapop__data.html">apop_data</a> * <a class="el" href="group__ttest.html#ga0ae576fb823e38f7b6f2ce1892e4b014">apop_paired_t_test</a> (gsl_vector *a, gsl_vector *b)
<li><a class="el" href="structapop__data.html">apop_data</a> * <a class="el" href="apop_8h.html#a1309242dbb7f148916c71a9a70c6b64c">apop_anova</a> (char *table, char *data, char *grouping1, char *grouping2)
<li><a class="el" href="structapop__data.html">apop_data</a> * <a class="el" href="apop_8h.html#a1902b3fd6a6682d1453a80b788e44ebb">apop_f_test</a> (<a class="el" href="structapop__model.html">apop_model</a> *est, <a class="el" href="structapop__data.html">apop_data</a> *contrast)
<li><a class="el" href="structapop__data.html">apop_data</a> * <a class="el" href="apop_8h.html#a77c937ea4764d3da2ed9968273fa4544">apop_text_unique_elements</a> (const <a class="el" href="structapop__data.html">apop_data</a> *d, size_t col)
<li>gsl_vector * <a class="el" href="apop_8h.html#a6d68bacc086420a382366f9118cf5bc7">apop_vector_unique_elements</a> (const gsl_vector *v)
<li><a class="el" href="structapop__data.html">apop_data</a> * <a class="el" href="apop_8h.html#a27405bd5fdf48d93c8918ca4c07ee260">apop_data_to_factors</a> (<a class="el" href="structapop__data.html">apop_data</a> *data, char intype, int incol, int outcol)
<li><a class="el" href="structapop__data.html">apop_data</a> * <a class="el" href="apop_8h.html#adec9170cf1382f6cd549a5819472eb51">apop_data_get_factor_names</a> (<a class="el" href="structapop__data.html">apop_data</a> *data, int col, char type)
<li><a class="el" href="structapop__data.html">apop_data</a> * <a class="el" href="apop_8h.html#ae0c28224e10f8aacdaa2d130f96f6ba2">apop_data_to_dummies</a> (<a class="el" href="structapop__data.html">apop_data</a> *d, int col, char type, int keep_first, char append, char remove)
<li>double <a class="el" href="apop_8h.html#a10b4b9735a1475cfa5ebe2dd33686686">apop_kl_divergence</a> (<a class="el" href="structapop__model.html">apop_model</a> *from, <a class="el" href="structapop__model.html">apop_model</a> *to, int draw_ct, gsl_rng *rng, <a class="el" href="structapop__model.html">apop_model</a> *top, <a class="el" href="structapop__model.html">apop_model</a> *bottom)
<li><a class="el" href="structapop__data.html">apop_data</a> * <a class="el" href="group__regression.html#gaceead3e4aaba543b7fc1d194fcbc40f8">apop_estimate_coefficient_of_determination</a> (<a class="el" href="structapop__model.html">apop_model</a> *)
<li>void <a class="el" href="apop_8h.html#ae165633525c5272ab83794b60076eddc">apop_estimate_parameter_tests</a> (<a class="el" href="structapop__model.html">apop_model</a> *est)
<li><a class="el" href="structapop__data.html">apop_data</a> * <a class="el" href="apop_8h.html#a8a85afbb18d256bcc8942d2eca7470ed">apop_jackknife_cov</a> (<a class="el" href="structapop__data.html">apop_data</a> *data, <a class="el" href="structapop__model.html">apop_model</a> *model)
<li><a class="el" href="structapop__data.html">apop_data</a> * <a class="el" href="apop_8h.html#a4eb57b1f864c650ed6d7e029550e7bb8">apop_bootstrap_cov</a> (<a class="el" href="structapop__data.html">apop_data</a> *data, <a class="el" href="structapop__model.html">apop_model</a> *model, gsl_rng *rng, int iterations, char keep_boots, char ignore_nans)
<li>gsl_rng * <a class="el" href="group__convenience__fns.html#gada044cf02135422a9f9292b6054c86dd">apop_rng_alloc</a> (int seed)
<li>double <a class="el" href="apop_8h.html#aaf0d5d65f514d9894a4ca5b0e8755873">apop_rng_GHgB3</a> (gsl_rng *r, double *a)
<li><a class="anchor" id="a72d8c995400d75922553d463f4b2b890"></a><!-- doxytag: member="apop.h::apop_rng_get_thread_base" ref="a72d8c995400d75922553d463f4b2b890" args="(int thread)" -->
gsl_rng * <b>apop_rng_get_thread_base</b> (int thread)
<li>int <a class="el" href="apop_8h.html#a0492d6f5ae8a73a60b651cadb113d643">apop_arms_draw</a> (double *out, gsl_rng *r, <a class="el" href="structapop__model.html">apop_model</a> *m)
<dl class="el"><dd class="mdescRight">Adaptive rejection metropolis sampling.  <a href="#a0492d6f5ae8a73a60b651cadb113d643"></a><br/></dl><li>gsl_vector * <a class="el" href="group__linear__algebra.html#ga1b6ecb8702153658c29369dc2e7cfba9">apop_numerical_gradient</a> (<a class="el" href="structapop__data.html">apop_data</a> *data, <a class="el" href="structapop__model.html">apop_model</a> *model, double delta)
<li><a class="el" href="structapop__data.html">apop_data</a> * <a class="el" href="apop_8h.html#a1a55a20880947e289767aad6e5b0117c">apop_model_hessian</a> (<a class="el" href="structapop__data.html">apop_data</a> *data, <a class="el" href="structapop__model.html">apop_model</a> *model, double delta)
<li><a class="el" href="structapop__data.html">apop_data</a> * <a class="el" href="apop_8h.html#a0f2784b69175d1ecd3833d228d2294e7">apop_model_numerical_covariance</a> (<a class="el" href="structapop__data.html">apop_data</a> *data, <a class="el" href="structapop__model.html">apop_model</a> *model, double delta)
<li>void <a class="el" href="group__mle.html#gae9f092d1786034dd2ab22c63de5c955c">apop_maximum_likelihood</a> (<a class="el" href="structapop__data.html">apop_data</a> *data, <a class="el" href="structapop__model.html">apop_model</a> *dist)
<li><a class="el" href="structapop__model.html">apop_model</a> * <a class="el" href="group__mle.html#ga6d5e39c00012de5b51cd49ce1ffd31fe">apop_estimate_restart</a> (<a class="el" href="structapop__model.html">apop_model</a> *e, <a class="el" href="structapop__model.html">apop_model</a> *copy, char *starting_pt, double boundary)
<li>long double <a class="el" href="apop_8h.html#ad490e5b31d1bbc99223c2cbfac7c1782">apop_linear_constraint</a> (gsl_vector *beta, <a class="el" href="structapop__data.html">apop_data</a> *constraint, double margin)
<li><a class="el" href="structapop__model.html">apop_model</a> * <a class="el" href="apop_8h.html#ab4f6ca7e042ac7c09c3c01d29702a739">apop_model_fix_params</a> (<a class="el" href="structapop__model.html">apop_model</a> *model_in)
<li><a class="el" href="structapop__model.html">apop_model</a> * <a class="el" href="apop_8h.html#af676505faea1c7e30ffbd8690a092ed8">apop_model_fix_params_get_base</a> (<a class="el" href="structapop__model.html">apop_model</a> *model_in)
<li><a class="anchor" id="a25375d4d280ac2e2e1f6c1c4308a0768"></a><!-- doxytag: member="apop.h::apop_vtable_add" ref="a25375d4d280ac2e2e1f6c1c4308a0768" args="(char const *tabname, void *fn_in, unsigned long hash)" -->
int <b>apop_vtable_add</b> (char const *tabname, void *fn_in, unsigned long hash)
<li><a class="anchor" id="ad36d4bf46ba0e0472a2986f90ad22977"></a><!-- doxytag: member="apop.h::apop_vtable_get" ref="ad36d4bf46ba0e0472a2986f90ad22977" args="(char const *tabname, unsigned long hash)" -->
void * <b>apop_vtable_get</b> (char const *tabname, unsigned long hash)
<li><a class="anchor" id="a2445b1dfe4ae37ff37e04b5d2461084f"></a><!-- doxytag: member="apop.h::apop_vtable_drop" ref="a2445b1dfe4ae37ff37e04b5d2461084f" args="(char const *tabname, unsigned long hash)" -->
int <b>apop_vtable_drop</b> (char const *tabname, unsigned long hash)
<li><a class="anchor" id="a09bdec45ab38cada87f32669a4b00100"></a><!-- doxytag: member="apop.h::apop_update_type_check" ref="a09bdec45ab38cada87f32669a4b00100" args="(apop_update_type in)" -->
void <b>apop_update_type_check</b> (apop_update_type in)
<li><a class="anchor" id="a5df7118854a6f8879a16210dc9b081c7"></a><!-- doxytag: member="apop.h::apop_score_type_check" ref="a5df7118854a6f8879a16210dc9b081c7" args="(apop_score_type in)" -->
void <b>apop_score_type_check</b> (apop_score_type in)
<li><a class="anchor" id="a14bbcbdad7fce213764f729ae84ec253"></a><!-- doxytag: member="apop.h::apop_parameter_model_type_check" ref="a14bbcbdad7fce213764f729ae84ec253" args="(apop_parameter_model_type in)" -->
void <b>apop_parameter_model_type_check</b> (apop_parameter_model_type in)
<li><a class="anchor" id="a1ac2ab6f05574d7a35791de581fa79ef"></a><!-- doxytag: member="apop.h::apop_predict_type_check" ref="a1ac2ab6f05574d7a35791de581fa79ef" args="(apop_predict_type in)" -->
void <b>apop_predict_type_check</b> (apop_predict_type in)
<li><a class="anchor" id="a2d4c94f145aad4942e12e6075e37a2c3"></a><!-- doxytag: member="apop.h::apop_model_print_type_check" ref="a2d4c94f145aad4942e12e6075e37a2c3" args="(apop_model_print_type in)" -->
void <b>apop_model_print_type_check</b> (apop_model_print_type in)
<li>double <a class="el" href="apop_8h.html#a757dd4278aac9967f9e62c3ef3c8fc69">apop_generalized_harmonic</a> (int N, double s) __attribute__((__pure__))
<li><a class="el" href="structapop__data.html">apop_data</a> * <a class="el" href="group__asst__tests.html#ga12b92b7494f4e24d2f47244e3792d566">apop_test_anova_independence</a> (<a class="el" href="structapop__data.html">apop_data</a> *d)
<li>int <a class="el" href="apop_8h.html#aa9ec5e7ed223c09bec044ced54f24fad">apop_regex</a> (const char *string, const char *regex, <a class="el" href="structapop__data.html">apop_data</a> **substrings, const char use_case)
<li><a class="anchor" id="a1d3c82855e1fb727a91dc4be17b7722d"></a><!-- doxytag: member="apop.h::apop_system" ref="a1d3c82855e1fb727a91dc4be17b7722d" args="(const char *fmt,...) __attribute__((format(printf" -->
int <b>apop_system</b> (const char *fmt,...) __attribute__((format(printf
<li>int gsl_vector * <a class="el" href="apop_8h.html#acfa62ab9157d4d92338a29093c7d1b30">apop_vector_moving_average</a> (gsl_vector *, size_t)
<li><a class="el" href="structapop__data.html">apop_data</a> * <a class="el" href="group__histograms.html#gad999220164049ce7b22d2cd11bf74c26">apop_histograms_test_goodness_of_fit</a> (<a class="el" href="structapop__model.html">apop_model</a> *h0, <a class="el" href="structapop__model.html">apop_model</a> *h1)
<li><a class="el" href="structapop__data.html">apop_data</a> * <a class="el" href="group__histograms.html#ga98ccaa9de7cb16e60a435c56eaf3400d">apop_test_kolmogorov</a> (<a class="el" href="structapop__model.html">apop_model</a> *m1, <a class="el" href="structapop__model.html">apop_model</a> *m2)
<li><a class="el" href="structapop__data.html">apop_data</a> * <a class="el" href="apop_8h.html#acc90578a8086a2e6f7b1575300260f08">apop_data_pmf_compress</a> (<a class="el" href="structapop__data.html">apop_data</a> *in)
<li><a class="el" href="structapop__data.html">apop_data</a> * <a class="el" href="apop_8h.html#a02cef4243593cf905fa54cb48d8b04c2">apop_data_to_bins</a> (<a class="el" href="structapop__data.html">apop_data</a> *indata, <a class="el" href="structapop__data.html">apop_data</a> *binspec, int bin_count, char close_top_bin)
<li><a class="el" href="structapop__model.html">apop_model</a> * <a class="el" href="group__histograms.html#ga12a8860fd05be2540b701fe7ec5acae4">apop_model_to_pmf</a> (<a class="el" href="structapop__model.html">apop_model</a> *model, <a class="el" href="structapop__data.html">apop_data</a> *binspec, long int draws, int bin_count, gsl_rng *rng)
<li>char * <a class="el" href="apop_8h.html#a6270ad55c566140e0d7962cb4d5daacc">apop_text_paste</a> (<a class="el" href="structapop__data.html">apop_data</a> const *strings, char *between, char *before, char *after, char *between_cols, int(*prune)(<a class="el" href="structapop__data.html">apop_data</a> *, int, int, void *), void *prune_parameter)
<li><a class="el" href="structapop__data.html">apop_data</a> * <a class="el" href="apop_8h.html#a0316d98bbeb6ae13532a8c071019dbe6">apop_data_listwise_delete</a> (<a class="el" href="structapop__data.html">apop_data</a> *d, char inplace)
<li><a class="el" href="structapop__model.html">apop_model</a> * <a class="el" href="apop_8h.html#a2a184259c139f1fdd970ef6b43f6274e">apop_ml_impute</a> (<a class="el" href="structapop__data.html">apop_data</a> *d, <a class="el" href="structapop__model.html">apop_model</a> *meanvar)
<li><a class="el" href="structapop__model.html">apop_model</a> * <a class="el" href="apop_8h.html#a1a6180e8caa773e287c1fce1bd78c061">apop_model_metropolis</a> (<a class="el" href="structapop__data.html">apop_data</a> *d, <a class="el" href="structapop__model.html">apop_model</a> *m, gsl_rng *rng)
<li><a class="el" href="structapop__model.html">apop_model</a> * <a class="el" href="apop_8h.html#ac7c0ddb63673ddd40ba69f7dc8bff800">apop_update</a> (<a class="el" href="structapop__data.html">apop_data</a> *data, <a class="el" href="structapop__model.html">apop_model</a> *prior, <a class="el" href="structapop__model.html">apop_model</a> *likelihood, gsl_rng *rng)
<li>double <a class="el" href="apop_8h.html#a650d1ecf6f78c3bdb85c8fce71dfae05">apop_test</a> (double statistic, char *distribution, double p1, double p2, char tail)
<li>double * <a class="el" href="apop_8h.html#afb838084f967543fa8a03e460180d53b">apop_vector_percentiles</a> (gsl_vector *data, char rounding)
<li><a class="el" href="structapop__data.html">apop_data</a> * <a class="el" href="apop_8h.html#acefe4dee819c090e57ac69d4d8bdcfd0">apop_data_sort</a> (<a class="el" href="structapop__data.html">apop_data</a> *data, <a class="el" href="structapop__data.html">apop_data</a> *sort_order, char asc, char inplace, double *col_order)
<li><a class="el" href="structapop__data.html">apop_data</a> * <a class="el" href="apop_8h.html#ac1bae5dffbbd4bc82c7369211c36f934">apop_rake</a> (char const *margin_table, char *const *var_list, int var_ct, char const *all_vars, char *const *contrasts, int contrast_ct, char const *structural_zeros, int max_iterations, double tolerance, char const *count_col, int run_number, char const *init_table, char const *init_count_col, double nudge, char const *table_name)
<li>double <a class="el" href="group__linear__algebra.html#ga6984006ab44fa7c9c2e99463f7d4081b">apop_det_and_inv</a> (const gsl_matrix *in, gsl_matrix **out, int calc_det, int calc_inv)
<li><a class="el" href="structapop__data.html">apop_data</a> * <a class="el" href="group__linear__algebra.html#gaf2d13e1b1f20f97e0772a0be41dc430e">apop_dot</a> (const <a class="el" href="structapop__data.html">apop_data</a> *d1, const <a class="el" href="structapop__data.html">apop_data</a> *d2, char form1, char form2)
<li>int <a class="el" href="group__convenience__fns.html#ga136ded2b6d190739deca064701cf5ca1">apop_vector_bounded</a> (const gsl_vector *in, long double max)
<li>gsl_matrix * <a class="el" href="group__linear__algebra.html#ga185243be2d8a93686c68263cc3318f47">apop_matrix_inverse</a> (const gsl_matrix *in)
<li>double <a class="el" href="group__linear__algebra.html#ga03038130e4ba55228f9e164dba513961">apop_matrix_determinant</a> (const gsl_matrix *in)
<li><a class="el" href="structapop__data.html">apop_data</a> * <a class="el" href="group__linear__algebra.html#gaa1715c468336800a21ca86971323ae3d">apop_matrix_pca</a> (gsl_matrix *data, int const dimensions_we_want)
<li>gsl_vector * <a class="el" href="group__convenience__fns.html#gae603a7d511cf40b022f99dc69faa616a">apop_vector_stack</a> (gsl_vector *v1, gsl_vector *v2, char inplace)
<li>gsl_matrix * <a class="el" href="group__convenience__fns.html#gae50bc918e0d8b6ee913596f68ab731a8">apop_matrix_stack</a> (gsl_matrix *m1, gsl_matrix *m2, char posn, char inplace)
<li>gsl_matrix * <a class="el" href="apop_8h.html#a5402b8254a90f2ac68770d6867502e5a">apop_matrix_rm_columns</a> (gsl_matrix *in, int *drop)
<li>void <a class="el" href="group__convenience__fns.html#ga5a622b8360eba63795a6049c30ac54a2">apop_vector_log</a> (gsl_vector *v)
<li>void <a class="el" href="group__convenience__fns.html#ga1a4a67e0b0bec8205cfe75bd3786c30e">apop_vector_log10</a> (gsl_vector *v)
<li>void <a class="el" href="group__convenience__fns.html#ga032dcecb67155c527c884dd2c1cc6a6e">apop_vector_exp</a> (gsl_vector *v)
<li>long double <a class="el" href="group__convenience__fns.html#gaf6182181dd424bc4de98b4bfbd349b4e">apop_vector_sum</a> (const gsl_vector *in)
<li>double <a class="el" href="group__vector__moments.html#ga2446385225c68c62ade26402c63600a4">apop_vector_var_m</a> (const gsl_vector *in, const double mean)
<li>double <a class="el" href="group__vector__moments.html#gae1154897fec0c56bc0161ed24c48759c">apop_vector_correlation</a> (const gsl_vector *ina, const gsl_vector *inb)
<li>double <a class="el" href="group__vector__moments.html#gaf5740c698174b1a265d182f4af1c0252">apop_vector_kurtosis</a> (const gsl_vector *in)
<li>double <a class="el" href="group__vector__moments.html#gac9d269f1dc62b038c0da72085cac1c28">apop_vector_skew</a> (const gsl_vector *in)
<li>int <a class="el" href="apop_8h.html#a01d501ca84ade92bc72fd4f67a617f64">apop_table_exists</a> (char const *name, char remove)
<li>int <a class="el" href="apop_8h.html#a4d81aff912df2982697038c51795e358">apop_db_open</a> (char const *filename)
<li>int <a class="el" href="apop_8h.html#acf205f62e9432fe293b05c077d1b61d4">apop_db_close</a> (char vacuum)
<li><a class="anchor" id="a8819ca5ff1a4156d4c20d7a3ae9ba480"></a><!-- doxytag: member="apop.h::apop_query" ref="a8819ca5ff1a4156d4c20d7a3ae9ba480" args="(const char *q,...) __attribute__((format(printf" -->
int <b>apop_query</b> (const char *q,...) __attribute__((format(printf
<li><a class="anchor" id="acf1ac01302e0578f44b1ff392324e1c8"></a><!-- doxytag: member="apop.h::apop_query_to_matrix" ref="acf1ac01302e0578f44b1ff392324e1c8" args="(const char *fmt,...) __attribute__((format(printf" -->
int gsl_matrix * <b>apop_query_to_matrix</b> (const char *fmt,...) __attribute__((format(printf
<li><a class="anchor" id="a1bb0cefbd7e74e0cfc439469982cf1be"></a><!-- doxytag: member="apop.h::apop_query_to_text" ref="a1bb0cefbd7e74e0cfc439469982cf1be" args="(const char *fmt,...) __attribute__((format(printf" -->
int gsl_matrix <a class="el" href="structapop__data.html">apop_data</a> * <b>apop_query_to_text</b> (const char *fmt,...) __attribute__((format(printf
<li><a class="anchor" id="ab2c8c9780b26ce8771fa56eb93043465"></a><!-- doxytag: member="apop.h::apop_query_to_data" ref="ab2c8c9780b26ce8771fa56eb93043465" args="(const char *fmt,...) __attribute__((format(printf" -->
int gsl_matrix <a class="el" href="structapop__data.html">apop_data</a> <br class="typebreak"/>
<a class="el" href="structapop__data.html">apop_data</a> * <b>apop_query_to_data</b> (const char *fmt,...) __attribute__((format(printf
<li><a class="anchor" id="ada6c7cc2d55608192838529e1f840f11"></a><!-- doxytag: member="apop.h::apop_query_to_mixed_data" ref="ada6c7cc2d55608192838529e1f840f11" args="(const char *typelist, const char *fmt,...) __attribute__((format(printf" -->
int gsl_matrix <a class="el" href="structapop__data.html">apop_data</a> <br class="typebreak"/>
<a class="el" href="structapop__data.html">apop_data</a> <a class="el" href="structapop__data.html">apop_data</a> * <b>apop_query_to_mixed_data</b> (const char *typelist, const char *fmt,...) __attribute__((format(printf
<li><a class="anchor" id="a1cab9e97e3d21d105f23b99be55b61ad"></a><!-- doxytag: member="apop.h::apop_query_to_vector" ref="a1cab9e97e3d21d105f23b99be55b61ad" args="(const char *fmt,...) __attribute__((format(printf" -->
int gsl_matrix <a class="el" href="structapop__data.html">apop_data</a> <br class="typebreak"/>
<a class="el" href="structapop__data.html">apop_data</a> <a class="el" href="structapop__data.html">apop_data</a> gsl_vector * <b>apop_query_to_vector</b> (const char *fmt,...) __attribute__((format(printf
<li><a class="anchor" id="a015435cd4f773fbf2d076ead2eeed356"></a><!-- doxytag: member="apop.h::apop_query_to_float" ref="a015435cd4f773fbf2d076ead2eeed356" args="(const char *fmt,...) __attribute__((format(printf" -->
int gsl_matrix <a class="el" href="structapop__data.html">apop_data</a> <br class="typebreak"/>
<a class="el" href="structapop__data.html">apop_data</a> <a class="el" href="structapop__data.html">apop_data</a> gsl_vector <br class="typebreak"/>
double <b>apop_query_to_float</b> (const char *fmt,...) __attribute__((format(printf
<li>int gsl_matrix <a class="el" href="structapop__data.html">apop_data</a> <br class="typebreak"/>
<a class="el" href="structapop__data.html">apop_data</a> <a class="el" href="structapop__data.html">apop_data</a> gsl_vector <br class="typebreak"/>
double int <a class="el" href="group__conversions.html#ga43aa7a723adab7a592a5e52961b338df">apop_data_to_db</a> (const <a class="el" href="structapop__data.html">apop_data</a> *set, const char *tabname, char)
<li>double <a class="el" href="group__ttest.html#gaf6b4c155f970f1a63c9d9cfba6300189">apop_db_t_test</a> (char *tab1, char *col1, char *tab2, char *col2)
<li>double <a class="el" href="group__ttest.html#gaeb5eee3a851024eb4a2835b0d501e15a">apop_db_paired_t_test</a> (char *tab1, char *col1, char *col2)
<li><a class="anchor" id="a447eff1b2d149fb29476e68a1bff2788"></a><!-- doxytag: member="apop.h::apop_settings_get_grp" ref="a447eff1b2d149fb29476e68a1bff2788" args="(apop_model *m, char *type, char fail)" -->
void * <b>apop_settings_get_grp</b> (<a class="el" href="structapop__model.html">apop_model</a> *m, char *type, char fail)
<li><a class="anchor" id="a564d11900c26fec78f7992617a7eee4b"></a><!-- doxytag: member="apop.h::apop_settings_remove_group" ref="a564d11900c26fec78f7992617a7eee4b" args="(apop_model *m, char *delme)" -->
void <b>apop_settings_remove_group</b> (<a class="el" href="structapop__model.html">apop_model</a> *m, char *delme)
<li>void <a class="el" href="apop_8h.html#a0dc44b7dfc3c125d19c1db3bef3a80a1">apop_settings_copy_group</a> (<a class="el" href="structapop__model.html">apop_model</a> *outm, <a class="el" href="structapop__model.html">apop_model</a> *inm, char *copyme)
<li><a class="anchor" id="a3571609cce3324b52ef96b7b844c32df"></a><!-- doxytag: member="apop.h::apop_settings_group_alloc" ref="a3571609cce3324b52ef96b7b844c32df" args="(apop_model *model, char *type, void *free_fn, void *copy_fn, void *the_group)" -->
void * <b>apop_settings_group_alloc</b> (<a class="el" href="structapop__model.html">apop_model</a> *model, char *type, void *free_fn, void *copy_fn, void *the_group)
<li><a class="anchor" id="a52cb7b05e3a71c5094f429340dfebd36"></a><!-- doxytag: member="apop.h::apop_settings_group_alloc_wm" ref="a52cb7b05e3a71c5094f429340dfebd36" args="(apop_model *model, char *type, void *free_fn, void *copy_fn, void *the_group)" -->
<a class="el" href="structapop__model.html">apop_model</a> * <b>apop_settings_group_alloc_wm</b> (<a class="el" href="structapop__model.html">apop_model</a> *model, char *type, void *free_fn, void *copy_fn, void *the_group)
</ul>
<h2><a name="var-members"></a>
Variables</h2>
<ul>
<li><a class="el" href="structapop__opts__type.html">apop_opts_type</a> <a class="el" href="apop_8h.html#a7975faa07196cf463ec261ff0ddc3ccc">apop_opts</a>
<li><a class="anchor" id="ae6cabd19bb6fe21b69caacb6e7c049cd"></a><!-- doxytag: member="apop.h::apop_beta" ref="ae6cabd19bb6fe21b69caacb6e7c049cd" args="" -->
<a class="el" href="structapop__model.html">apop_model</a> * <b>apop_beta</b>
<li><a class="anchor" id="a0b078785923b7ebf991959e5fa48630e"></a><!-- doxytag: member="apop.h::apop_bernoulli" ref="a0b078785923b7ebf991959e5fa48630e" args="" -->
<a class="el" href="structapop__model.html">apop_model</a> * <b>apop_bernoulli</b>
<li><a class="anchor" id="a59528acef7371d496b3d53f8f1972222"></a><!-- doxytag: member="apop.h::apop_binomial" ref="a59528acef7371d496b3d53f8f1972222" args="" -->
<a class="el" href="structapop__model.html">apop_model</a> * <b>apop_binomial</b>
<li><a class="anchor" id="a289aee941407e021f68214687d656056"></a><!-- doxytag: member="apop.h::apop_chi_squared" ref="a289aee941407e021f68214687d656056" args="" -->
<a class="el" href="structapop__model.html">apop_model</a> * <b>apop_chi_squared</b>
<li><a class="anchor" id="a0ac4c68d07c52e2133bea97033efb9b2"></a><!-- doxytag: member="apop.h::apop_dirichlet" ref="a0ac4c68d07c52e2133bea97033efb9b2" args="" -->
<a class="el" href="structapop__model.html">apop_model</a> * <b>apop_dirichlet</b>
<li><a class="anchor" id="a5da48b7a513b0edffc1039b793d2bf1e"></a><!-- doxytag: member="apop.h::apop_exponential" ref="a5da48b7a513b0edffc1039b793d2bf1e" args="" -->
<a class="el" href="structapop__model.html">apop_model</a> * <b>apop_exponential</b>
<li><a class="anchor" id="a5a879b97021e4187cf93d1319900e11c"></a><!-- doxytag: member="apop.h::apop_f_distribution" ref="a5a879b97021e4187cf93d1319900e11c" args="" -->
<a class="el" href="structapop__model.html">apop_model</a> * <b>apop_f_distribution</b>
<li><a class="anchor" id="a343bdd2f8ac26b9dfc3aab70371dc1a5"></a><!-- doxytag: member="apop.h::apop_gamma" ref="a343bdd2f8ac26b9dfc3aab70371dc1a5" args="" -->
<a class="el" href="structapop__model.html">apop_model</a> * <b>apop_gamma</b>
<li><a class="anchor" id="ad427ffccf160021bc1ce64ddcd792d9e"></a><!-- doxytag: member="apop.h::apop_improper_uniform" ref="ad427ffccf160021bc1ce64ddcd792d9e" args="" -->
<a class="el" href="structapop__model.html">apop_model</a> * <b>apop_improper_uniform</b>
<li><a class="anchor" id="a126c685e799d0eec806c5819f91845cc"></a><!-- doxytag: member="apop.h::apop_iv" ref="a126c685e799d0eec806c5819f91845cc" args="" -->
<a class="el" href="structapop__model.html">apop_model</a> * <b>apop_iv</b>
<li><a class="anchor" id="a4b6cd49361e8635fd5e3e3312e8040ed"></a><!-- doxytag: member="apop.h::apop_kernel_density" ref="a4b6cd49361e8635fd5e3e3312e8040ed" args="" -->
<a class="el" href="structapop__model.html">apop_model</a> * <b>apop_kernel_density</b>
<li><a class="anchor" id="a9457bd24a17a8705f4ee1c8fe7807dd9"></a><!-- doxytag: member="apop.h::apop_loess" ref="a9457bd24a17a8705f4ee1c8fe7807dd9" args="" -->
<a class="el" href="structapop__model.html">apop_model</a> * <b>apop_loess</b>
<li><a class="anchor" id="ab3e8bb3aac8ce211c9ebcb7e2ef06241"></a><!-- doxytag: member="apop.h::apop_logit" ref="ab3e8bb3aac8ce211c9ebcb7e2ef06241" args="" -->
<a class="el" href="structapop__model.html">apop_model</a> * <b>apop_logit</b>
<li><a class="anchor" id="acc72d4e9d073dd029032675fd7c7feb1"></a><!-- doxytag: member="apop.h::apop_lognormal" ref="acc72d4e9d073dd029032675fd7c7feb1" args="" -->
<a class="el" href="structapop__model.html">apop_model</a> * <b>apop_lognormal</b>
<li><a class="anchor" id="a2bc96895b91ff00eda42b36b31fe0df1"></a><!-- doxytag: member="apop.h::apop_multinomial" ref="a2bc96895b91ff00eda42b36b31fe0df1" args="" -->
<a class="el" href="structapop__model.html">apop_model</a> * <b>apop_multinomial</b>
<li><a class="anchor" id="a6133f5f2ed5172c4a98e51bd17a18b23"></a><!-- doxytag: member="apop.h::apop_multivariate_normal" ref="a6133f5f2ed5172c4a98e51bd17a18b23" args="" -->
<a class="el" href="structapop__model.html">apop_model</a> * <b>apop_multivariate_normal</b>
<li><a class="anchor" id="a74c3f0a4c9263e1f5e17c9ef873c8f02"></a><!-- doxytag: member="apop.h::apop_normal" ref="a74c3f0a4c9263e1f5e17c9ef873c8f02" args="" -->
<a class="el" href="structapop__model.html">apop_model</a> * <b>apop_normal</b>
<li><a class="anchor" id="a7a3d6eb287feb7e22399fcfcf5d30d0d"></a><!-- doxytag: member="apop.h::apop_ols" ref="a7a3d6eb287feb7e22399fcfcf5d30d0d" args="" -->
<a class="el" href="structapop__model.html">apop_model</a> * <b>apop_ols</b>
<li><a class="anchor" id="a3f90682cc2ba9b6f0f36b3ad4066b7c4"></a><!-- doxytag: member="apop.h::apop_pmf" ref="a3f90682cc2ba9b6f0f36b3ad4066b7c4" args="" -->
<a class="el" href="structapop__model.html">apop_model</a> * <b>apop_pmf</b>
<li><a class="anchor" id="a695d628d5c038a6ba9f9b983c483c535"></a><!-- doxytag: member="apop.h::apop_poisson" ref="a695d628d5c038a6ba9f9b983c483c535" args="" -->
<a class="el" href="structapop__model.html">apop_model</a> * <b>apop_poisson</b>
<li><a class="anchor" id="a0a2fe38172bbc4a70cbfd2077eb22dc4"></a><!-- doxytag: member="apop.h::apop_probit" ref="a0a2fe38172bbc4a70cbfd2077eb22dc4" args="" -->
<a class="el" href="structapop__model.html">apop_model</a> * <b>apop_probit</b>
<li><a class="anchor" id="a04c08bcad3e882d38e92ad77f9296f43"></a><!-- doxytag: member="apop.h::apop_t_distribution" ref="a04c08bcad3e882d38e92ad77f9296f43" args="" -->
<a class="el" href="structapop__model.html">apop_model</a> * <b>apop_t_distribution</b>
<li><a class="anchor" id="a6043cdfc7c38877cd1c1c9a46ae1b231"></a><!-- doxytag: member="apop.h::apop_uniform" ref="a6043cdfc7c38877cd1c1c9a46ae1b231" args="" -->
<a class="el" href="structapop__model.html">apop_model</a> * <b>apop_uniform</b>
<li><a class="anchor" id="a17169ed9be0b026a496b8d16a11c87ea"></a><!-- doxytag: member="apop.h::apop_wls" ref="a17169ed9be0b026a496b8d16a11c87ea" args="" -->
<a class="el" href="structapop__model.html">apop_model</a> * <b>apop_wls</b>
<li><a class="anchor" id="af67e6b37ea29a900a26a2c382d1f965b"></a><!-- doxytag: member="apop.h::apop_yule" ref="af67e6b37ea29a900a26a2c382d1f965b" args="" -->
<a class="el" href="structapop__model.html">apop_model</a> * <b>apop_yule</b>
<li><a class="anchor" id="af238f568423aedb7e775a6ac259e820f"></a><!-- doxytag: member="apop.h::apop_zipf" ref="af238f568423aedb7e775a6ac259e820f" args="" -->
<a class="el" href="structapop__model.html">apop_model</a> * <b>apop_zipf</b>
<li><a class="anchor" id="aeab707dc9e20143e26f6a89d0677af8f"></a><!-- doxytag: member="apop.h::apop_coordinate_transform" ref="aeab707dc9e20143e26f6a89d0677af8f" args="" -->
<a class="el" href="structapop__model.html">apop_model</a> * <b>apop_coordinate_transform</b>
<li><a class="anchor" id="a618d4cbbb5b910f361766ecc99a0ffa0"></a><!-- doxytag: member="apop.h::apop_composition" ref="a618d4cbbb5b910f361766ecc99a0ffa0" args="" -->
<a class="el" href="structapop__model.html">apop_model</a> * <b>apop_composition</b>
<li><a class="anchor" id="ae8babcd9877d0f4991ee2aca9316ca6e"></a><!-- doxytag: member="apop.h::apop_dconstrain" ref="ae8babcd9877d0f4991ee2aca9316ca6e" args="" -->
<a class="el" href="structapop__model.html">apop_model</a> * <b>apop_dconstrain</b>
<li><a class="anchor" id="ad86a3bbaf8312a5c8aa3e1c4dcc53d0d"></a><!-- doxytag: member="apop.h::apop_mixture" ref="ad86a3bbaf8312a5c8aa3e1c4dcc53d0d" args="" -->
<a class="el" href="structapop__model.html">apop_model</a> * <b>apop_mixture</b>
<li><a class="anchor" id="aedb1edfba761f1c84ef9d449d5a10fbf"></a><!-- doxytag: member="apop.h::apop_stack" ref="aedb1edfba761f1c84ef9d449d5a10fbf" args="" -->
<a class="el" href="structapop__model.html">apop_model</a> * <b>apop_stack</b>
</ul>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"></div><hr/><h2>Define Documentation</h2>
<a class="anchor" id="a84e73bf42af0baed7b13de3a43eebb72"></a><!-- doxytag: member="apop.h::Apop_col" ref="a84e73bf42af0baed7b13de3a43eebb72" args="(d, col, outd)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="apop_8h.html#a84e73bf42af0baed7b13de3a43eebb72">Apop_col</a></td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">d, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">col, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">outd&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>A macro to generate a temporary one-column view of <a class="el" href="gentle.html#apop_data">apop_data</a> set <code>d</code>, pulling out only column <code>col</code>. After this call, <code>outd</code> will be a pointer to this temporary view, that you can use as you would any <a class="el" href="gentle.html#apop_data">apop_data</a> set. This macro expands to <code><a class="el" href="apop_8h.html#afbfb5abe21c52dd24570b620ed069c4d">Apop_cols(d, col, 1, outd)</a></code>. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="apop_8h.html#afbfb5abe21c52dd24570b620ed069c4d">Apop_cols</a>, <a class="el" href="apop_8h.html#a4d7938112c815272f9737685bf128ccb">Apop_col_v</a>, <a class="el" href="apop_8h.html#ad56ce572c7489820777290153ab7d87b">Apop_col_tv</a>, <a class="el" href="apop_8h.html#aaaf15101ec60ce66e80737375baa7391">Apop_col_t</a>, <a class="el" href="apop_8h.html#a3e7f99e26eb4d5d5438fd5fa16fcadde">Apop_matrix_col</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aaaf15101ec60ce66e80737375baa7391"></a><!-- doxytag: member="apop.h::Apop_col_t" ref="aaaf15101ec60ce66e80737375baa7391" args="(d, colname, outd)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="apop_8h.html#aaaf15101ec60ce66e80737375baa7391">Apop_col_t</a></td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">d, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">colname, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">outd&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>After this call, <code>v</code> will hold a view of an <a class="el" href="gentle.html#apop_data">apop_data</a> set consisting only of vector view of the <code>col</code>th column of the <a class="el" href="gentle.html#apop_data">apop_data</a> set <code>m</code>. Unlike <a class="el" href="apop_8h.html#a84e73bf42af0baed7b13de3a43eebb72">Apop_col</a>, the second argument is a column name, that I'll look up using <a class="el" href="apop__name_8c.html#ac1b94277b0055f11d00f6dd26cb70e00">apop_name_find</a>. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="apop_8h.html#afbfb5abe21c52dd24570b620ed069c4d">Apop_cols</a>, <a class="el" href="apop_8h.html#a84e73bf42af0baed7b13de3a43eebb72">Apop_col</a>, <a class="el" href="apop_8h.html#a4d7938112c815272f9737685bf128ccb">Apop_col_v</a>, <a class="el" href="apop_8h.html#ad56ce572c7489820777290153ab7d87b">Apop_col_tv</a>, <a class="el" href="apop_8h.html#a3e7f99e26eb4d5d5438fd5fa16fcadde">Apop_matrix_col</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ad56ce572c7489820777290153ab7d87b"></a><!-- doxytag: member="apop.h::Apop_col_tv" ref="ad56ce572c7489820777290153ab7d87b" args="(m, col, v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="apop_8h.html#ad56ce572c7489820777290153ab7d87b">Apop_col_tv</a></td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">m, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">col, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">v&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>After this call, <code>v</code> will hold a vector view of the <code>col</code>th column of the <a class="el" href="gentle.html#apop_data">apop_data</a> set <code>m</code>. Unlike <a class="el" href="apop_8h.html#a4d7938112c815272f9737685bf128ccb">Apop_col_v</a>, the second argument is a column name, that I'll look up using <a class="el" href="apop__name_8c.html#ac1b94277b0055f11d00f6dd26cb70e00">apop_name_find</a>. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="apop_8h.html#afbfb5abe21c52dd24570b620ed069c4d">Apop_cols</a>, <a class="el" href="apop_8h.html#a84e73bf42af0baed7b13de3a43eebb72">Apop_col</a>, <a class="el" href="apop_8h.html#a4d7938112c815272f9737685bf128ccb">Apop_col_v</a>, <a class="el" href="apop_8h.html#aaaf15101ec60ce66e80737375baa7391">Apop_col_t</a>, <a class="el" href="apop_8h.html#a3e7f99e26eb4d5d5438fd5fa16fcadde">Apop_matrix_col</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a4d7938112c815272f9737685bf128ccb"></a><!-- doxytag: member="apop.h::Apop_col_v" ref="a4d7938112c815272f9737685bf128ccb" args="(m, col, v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="apop_8h.html#a4d7938112c815272f9737685bf128ccb">Apop_col_v</a></td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">m, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">col, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">v&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>After this call, <code>v</code> will hold a vector view of the <code>col</code>th column of the <a class="el" href="gentle.html#apop_data">apop_data</a> set <code>m</code>. This is like <a class="el" href="apop_8h.html#a84e73bf42af0baed7b13de3a43eebb72">Apop_col</a>, but the output is a <code>gsl_vector</code>, not a full <a class="el" href="gentle.html#apop_data">apop_data</a> set. It is like <a class="el" href="apop_8h.html#a3e7f99e26eb4d5d5438fd5fa16fcadde">Apop_matrix_col</a>, but the input is a <a class="el" href="gentle.html#apop_data">apop_data</a> set, not a <code>gsl_matrix</code>. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="apop_8h.html#afbfb5abe21c52dd24570b620ed069c4d">Apop_cols</a>, <a class="el" href="apop_8h.html#a84e73bf42af0baed7b13de3a43eebb72">Apop_col</a>, <a class="el" href="apop_8h.html#ad56ce572c7489820777290153ab7d87b">Apop_col_tv</a>, <a class="el" href="apop_8h.html#aaaf15101ec60ce66e80737375baa7391">Apop_col_t</a>, <a class="el" href="apop_8h.html#a3e7f99e26eb4d5d5438fd5fa16fcadde">Apop_matrix_col</a> </dd></dl>

</div>
</div>
<a class="anchor" id="afbfb5abe21c52dd24570b620ed069c4d"></a><!-- doxytag: member="apop.h::Apop_cols" ref="afbfb5abe21c52dd24570b620ed069c4d" args="(d, colnum, len, outd)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="apop_8h.html#afbfb5abe21c52dd24570b620ed069c4d">Apop_cols</a></td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">d, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">colnum, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">len, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">outd&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>A macro to generate a temporary view of <a class="el" href="gentle.html#apop_data">apop_data</a> set <code>d</code>, beginning at column <code>col</code> and having length <code>len</code>. After this call, <code>outd</code> will be a pointer to this temporary view, that you can use as you would any <a class="el" href="gentle.html#apop_data">apop_data</a> set. However, it expires as soon as the program leaves the current scope (like with the usual automatically declared vars). </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="apop_8h.html#a84e73bf42af0baed7b13de3a43eebb72">Apop_col</a>, <a class="el" href="apop_8h.html#a4d7938112c815272f9737685bf128ccb">Apop_col_v</a>, <a class="el" href="apop_8h.html#ad56ce572c7489820777290153ab7d87b">Apop_col_tv</a>, <a class="el" href="apop_8h.html#aaaf15101ec60ce66e80737375baa7391">Apop_col_t</a>, <a class="el" href="apop_8h.html#a3e7f99e26eb4d5d5438fd5fa16fcadde">Apop_matrix_col</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aeca6159c82c21da0db82ae9ed0582dc6"></a><!-- doxytag: member="apop.h::apop_data_add_names" ref="aeca6159c82c21da0db82ae9ed0582dc6" args="(dataset, type,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="apop_8h.html#aeca6159c82c21da0db82ae9ed0582dc6">apop_data_add_names</a></td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">dataset, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">type, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;apop_data_add_names_base((dataset), (type), (char const*[]) {__VA_ARGS__, NULL})</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Add a list of names to a data set.</p>
<ul>
<li>Use this with a list of names that you type in yourself, like <div class="fragment"><pre class="fragment"><a class="code" href="apop_8h.html#aeca6159c82c21da0db82ae9ed0582dc6">apop_data_add_names</a>(mydata, <span class="charliteral">&#39;c&#39;</span>, <span class="stringliteral">&quot;age&quot;</span>, <span class="stringliteral">&quot;sex&quot;</span>, <span class="stringliteral">&quot;height&quot;</span>);
</pre></div> Notice the lack of curly braces around the list.</li>
</ul>
<ul>
<li>You may have an array of names, probably autogenerated, that you would like to add. In this case, make certain that the last element of the array is <code>NULL</code>, and call the base function: <div class="fragment"><pre class="fragment"><span class="keywordtype">char</span> **[] colnames = {<span class="stringliteral">&quot;age&quot;</span>, <span class="stringliteral">&quot;sex&quot;</span>, <span class="stringliteral">&quot;height&quot;</span>, NULL};
apop_data_add_names_base(mydata, <span class="charliteral">&#39;c&#39;</span>, colnames);
</pre></div> If you forget the <code>NULL</code> marker, this has good odds of segfaulting. You may prefer to use a <code>for</code> loop that inserts each name in turn using <a class="el" href="apop__name_8c.html#ae32d4f48cff7788b617d40155703ae64">apop_name_add</a>.</li>
</ul>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="apop__name_8c.html#ae32d4f48cff7788b617d40155703ae64">apop_name_add</a>, although <a class="el" href="apop_8h.html#aeca6159c82c21da0db82ae9ed0582dc6">apop_data_add_names</a> will be more useful in most cases. </dd></dl>

</div>
</div>
<a class="anchor" id="acb6b2c53478f9db902ba0340ba499819"></a><!-- doxytag: member="apop.h::apop_data_falloc" ref="acb6b2c53478f9db902ba0340ba499819" args="(sizes,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="apop_8h.html#acb6b2c53478f9db902ba0340ba499819">apop_data_falloc</a></td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">sizes, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="apop_8h.html#ad6be56d710a63aa1ceadf2242c553905">apop_data_fill</a>(<a class="el" href="apop__data_8c.html#ac39d6a56933b6f084328ec5ecd5090d8">apop_data_alloc</a> sizes, __VA_ARGS__)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Allocate a data set and fill it with values. Put the data set dimensions (one, two, or three dimensions as per <a class="el" href="apop__data_8c.html#ac39d6a56933b6f084328ec5ecd5090d8">apop_data_alloc</a>) in parens, then the data (as per <a class="el" href="apop_8h.html#ad6be56d710a63aa1ceadf2242c553905">apop_data_fill</a>). E.g.: </p>
<div class="fragment"><pre class="fragment"><a class="code" href="structapop__data.html">apop_data</a> *identity2 = <a class="code" href="apop_8h.html#acb6b2c53478f9db902ba0340ba499819">apop_data_falloc</a>((2,2),
                         1, 0,
                         0, 1);

<a class="code" href="structapop__data.html">apop_data</a> *count_vector = <a class="code" href="apop_8h.html#acb6b2c53478f9db902ba0340ba499819">apop_data_falloc</a>((5), 0, 1, 2, 3, 4);
</pre></div><p>If you forget the parens, you will get an obscure error during compilation.</p>
<ul>
<li>This is a pretty simple macro wrapping <a class="el" href="apop_8h.html#ad6be56d710a63aa1ceadf2242c553905">apop_data_fill</a> and <a class="el" href="apop__data_8c.html#ac39d6a56933b6f084328ec5ecd5090d8">apop_data_alloc</a>, because they appear together so often. The second example expands to: <div class="fragment"><pre class="fragment"><a class="code" href="structapop__data.html">apop_data</a> *count_vector = <a class="code" href="apop_8h.html#ad6be56d710a63aa1ceadf2242c553905">apop_data_fill</a>(<a class="code" href="apop_8h.html#ac39d6a56933b6f084328ec5ecd5090d8">apop_data_alloc</a>(5), 0, 1, 2, 3, 4);
</pre></div> </li>
</ul>

</div>
</div>
<a class="anchor" id="ad6be56d710a63aa1ceadf2242c553905"></a><!-- doxytag: member="apop.h::apop_data_fill" ref="ad6be56d710a63aa1ceadf2242c553905" args="(adfin,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="apop_8h.html#ad6be56d710a63aa1ceadf2242c553905">apop_data_fill</a></td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">adfin, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;apop_data_fill_base((adfin), (double []) {__VA_ARGS__})</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Fill a pre-allocated data set with values.</p>
<p>For example: </p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &lt;<a class="code" href="apop_8h.html">apop.h</a>&gt;</span>

<span class="keywordtype">int</span> main(){
    <a class="code" href="structapop__data.html">apop_data</a> *a =<a class="code" href="apop_8h.html#ac39d6a56933b6f084328ec5ecd5090d8">apop_data_alloc</a>(2,2,2);
    <span class="keywordtype">double</span>    eight   = 8.0;
    <a class="code" href="apop_8h.html#ad6be56d710a63aa1ceadf2242c553905">apop_data_fill</a>(a, 8, 2.2, eight/2,
                      0, 6.0, eight);
    <a class="code" href="group__output.html#ga9a30c437ec11a11e37e0db7f82386275">apop_data_show</a>(a);
}
</pre></div><p>Warning: I need as many arguments as the size of the data set, and can't count them for you. Too many will be ignored; too few will produce unpredictable results, which may include padding your matrix with garbage or a simple segfault.</p>
<p>Underlying this function is a base function that takes a single list, as opposed to a set of unassociated numbers as above:</p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &lt;<a class="code" href="apop_8h.html">apop.h</a>&gt;</span>

<span class="keywordtype">int</span> main(){
  <a class="code" href="structapop__data.html">apop_data</a> *a =<a class="code" href="apop_8h.html#ac39d6a56933b6f084328ec5ecd5090d8">apop_data_alloc</a>(2,2,2);
  <span class="keywordtype">double</span>    eight   = 8.0;
  <span class="keywordtype">double</span> list[] = {8, 2.2, eight/2, 
                   0, 6.0, eight};
    apop_data_fill_base(a, list);
    <a class="code" href="group__output.html#ga9a30c437ec11a11e37e0db7f82386275">apop_data_show</a>(a);
}
</pre></div><dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">adfin</td><td>An <code><a class="el" href="structapop__data.html">apop_data</a></code> set (that you have already allocated). </td></tr>
    <tr><td class="paramname">...</td><td>A series of at least as many floating-point values as there are blanks in the data set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A pointer to the same data set that was input.</dd></dl>
<ul>
<li>I assume that <code>vector-&gt;size==matrix-&gt;size1</code>; otherwise I just use <code>matrix-&gt;size1</code>.</li>
</ul>
<ul>
<li>See also <a class="el" href="apop_8h.html#acb6b2c53478f9db902ba0340ba499819">apop_data_falloc</a> to allocate and fill on one line. E.g., to generate a unit vector for three dimensions: <div class="fragment"><pre class="fragment"><a class="code" href="structapop__data.html">apop_data</a> *unit_vector = <a class="code" href="apop_8h.html#acb6b2c53478f9db902ba0340ba499819">apop_data_falloc</a>((3), 1, 1, 1);
</pre></div></li>
</ul>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="apop_8h.html#a74dca50ea16ed7bf25cb152315642769">apop_text_fill</a>, <a class="el" href="apop_8h.html#acb6b2c53478f9db902ba0340ba499819">apop_data_falloc</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a459acfde11f2c39f5c32cff377f85b9e"></a><!-- doxytag: member="apop.h::apop_data_free" ref="a459acfde11f2c39f5c32cff377f85b9e" args="(freeme)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="apop_8h.html#a459acfde11f2c39f5c32cff377f85b9e">apop_data_free</a></td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">freeme</td><td>)</td>
          <td>&#160;&#160;&#160;(<a class="el" href="apop__data_8c.html#a3e8377359d46c9bd02ea57205e7968d3">apop_data_free_base</a>(freeme) ? 0 : ((freeme)= NULL))</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Free an <a class="el" href="gentle.html#apop_data">apop_data</a> structure.</p>
<p>As with <code>free()</code>, it is safe to send in a <code>NULL</code> pointer (in which case the function does nothing).</p>
<p>If the <code>more</code> pointer is not <code>NULL</code>, I will free the pointed-to data set first. If you don't want to free data sets down the chain, set <code>more=NULL</code> before calling this.</p>
<ul>
<li>This is actually a macro (that calls <a class="el" href="apop__data_8c.html#a3e8377359d46c9bd02ea57205e7968d3">apop_data_free_base</a> to do the real work). It sets <code>freeme</code> to <code>NULL</code> when it's done, because there's nothing safe you can do with the freed location, and you can later safely test conditions like <code>if (data) ...</code>. </li>
</ul>

</div>
</div>
<a class="anchor" id="a5ea849ee3c044e95eafb7b79124ce844"></a><!-- doxytag: member="apop.h::apop_data_prune_columns" ref="a5ea849ee3c044e95eafb7b79124ce844" args="(in,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="apop_8h.html#a5ea849ee3c044e95eafb7b79124ce844">apop_data_prune_columns</a></td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">in, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Keep only the columns of a data set that you name.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>The data set to prune. </td></tr>
    <tr><td class="paramname">...</td><td>A list of names to retain (i.e. the columns that shouldn't be pruned out). For example, if you have run <a class="el" href="group__output.html#gaca60728fc3b691acfcadebf3a8535532">apop_data_summarize</a>, you have columns for several statistics, but may care about only one or two; see the example.</td></tr>
  </table>
  </dd>
</dl>
<p>For example: </p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &lt;<a class="code" href="apop_8h.html">apop.h</a>&gt;</span>

<span class="comment">/* This sample produces a dummy times table, gets a summary, and prunes the summary table.</span>
<span class="comment">If you are not a test script, uncomment the last line to display the pruned table.  */</span>
<span class="keywordtype">int</span> main(){
    <span class="keywordtype">int</span> i, j;
    <a class="code" href="structapop__data.html">apop_data</a> *d = <a class="code" href="apop_8h.html#ac39d6a56933b6f084328ec5ecd5090d8">apop_data_alloc</a>(0, 10, 4);
    <span class="keywordflow">for</span> (i=0; i&lt; 10; i++)
        <span class="keywordflow">for</span> (j=0; j&lt; 4; j++)
            <a class="code" href="group__data__set__get.html#gaea55629952c595bc8211d3333077dc51">apop_data_set</a>(d, i, j, i*j);
    <a class="code" href="structapop__data.html">apop_data</a> *summary = <a class="code" href="group__output.html#gaca60728fc3b691acfcadebf3a8535532">apop_data_summarize</a>(d);
    <a class="code" href="apop_8h.html#a5ea849ee3c044e95eafb7b79124ce844">apop_data_prune_columns</a>(summary, <span class="stringliteral">&quot;mean&quot;</span>, <span class="stringliteral">&quot;median&quot;</span>);
    assert(<a class="code" href="apop_8h.html#adb1398925a93b7c2c502af8fb2abc49e">apop_name_find</a>(summary-&gt;names, <span class="stringliteral">&quot;mean&quot;</span>, <span class="charliteral">&#39;c&#39;</span>)!=-2);
    assert(<a class="code" href="apop_8h.html#adb1398925a93b7c2c502af8fb2abc49e">apop_name_find</a>(summary-&gt;names, <span class="stringliteral">&quot;median&quot;</span>, <span class="charliteral">&#39;c&#39;</span>)!=-2);
    assert(<a class="code" href="apop_8h.html#adb1398925a93b7c2c502af8fb2abc49e">apop_name_find</a>(summary-&gt;names, <span class="stringliteral">&quot;max&quot;</span>, <span class="charliteral">&#39;c&#39;</span>)==-2); <span class="comment">//not found</span>
    assert(<a class="code" href="apop_8h.html#adb1398925a93b7c2c502af8fb2abc49e">apop_name_find</a>(summary-&gt;names, <span class="stringliteral">&quot;variance&quot;</span>, <span class="charliteral">&#39;c&#39;</span>)==-2); <span class="comment">//not found</span>
    assert(<a class="code" href="group__data__set__get.html#ga06107779e4a3eb229715ceca24352b89">apop_data_get</a>(summary, .row=0, .colname=<span class="stringliteral">&quot;mean&quot;</span>)==0);
    assert(<a class="code" href="group__data__set__get.html#ga06107779e4a3eb229715ceca24352b89">apop_data_get</a>(summary, .row=1, .colname=<span class="stringliteral">&quot;median&quot;</span>)==4);
    assert(<a class="code" href="group__data__set__get.html#ga06107779e4a3eb229715ceca24352b89">apop_data_get</a>(summary, .row=2, .colname=<span class="stringliteral">&quot;median&quot;</span>)==8);
    <span class="comment">//apop_data_show(summary);</span>
}
</pre></div><ul>
<li>I use a case-insensitive search to find your column. </li>
<li>If your name multiple columns, I'll only give you the first. </li>
<li>If I can't find a column matching one of your strings, I throw an error to the screen and continue. </li>
<li>This is a macro calling <a class="el" href="apop__data_8c.html#ad1efbe058d6ca85ece023eb471c66e58">apop_data_prune_columns_base</a>. It packages your list of columns into a list of strings, adds a <code>NULL</code> string at the end, and calls that function. </li>
</ul>

</div>
</div>
<a class="anchor" id="abbdfc523f5b269827db8cebf28216e28"></a><!-- doxytag: member="apop.h::apop_gaussian" ref="abbdfc523f5b269827db8cebf28216e28" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="apop_8h.html#abbdfc523f5b269827db8cebf28216e28">apop_gaussian</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Alias for the <a class="el" href="group__models.html#ga297c2dc8dbdf4ae93fc7e10860400466">apop_normal</a> distribution, qv. </p>

</div>
</div>
<a class="anchor" id="a3e7f99e26eb4d5d5438fd5fa16fcadde"></a><!-- doxytag: member="apop.h::Apop_matrix_col" ref="a3e7f99e26eb4d5d5438fd5fa16fcadde" args="(m, col, v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="apop_8h.html#a3e7f99e26eb4d5d5438fd5fa16fcadde">Apop_matrix_col</a></td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">m, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">col, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">v&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">gsl_vector apop_vv_##v = gsl_matrix_column((m), (col)).vector;\
gsl_vector * v = &amp;( apop_vv_##v );
</pre></div><p>View a single column of a <code>gsl_matrix</code> as a <code>gsl_vector</code>. This is a convenience macro wrapping <code>gsl_matrix_column</code>.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The <code>gsl_matrix</code> </td></tr>
    <tr><td class="paramname">col</td><td>The number of the desired column. </td></tr>
    <tr><td class="paramname">v</td><td>The name of the vector view that will be created.</td></tr>
  </table>
  </dd>
</dl>
<p>An: example </p>
<div class="fragment"><pre class="fragment">gsl_matrix *m = [fill matrix here];
<a class="code" href="apop_8h.html#a3e7f99e26eb4d5d5438fd5fa16fcadde">Apop_matrix_col</a>(m, 2, coltwo);
<a class="code" href="apop_8h.html#a3e7f99e26eb4d5d5438fd5fa16fcadde">Apop_matrix_col</a>(m, 3, colthree);
printf(<span class="stringliteral">&quot;The correlation coefficient between columns two &quot;</span>
       <span class="stringliteral">&quot;and three is %g.\n&quot;</span>, <a class="code" href="group__vector__moments.html#gae1154897fec0c56bc0161ed24c48759c">apop_vector_correlation</a>(coltwo, colthree));
</pre></div> <dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="apop_8h.html#afbfb5abe21c52dd24570b620ed069c4d">Apop_cols</a>, <a class="el" href="apop_8h.html#a84e73bf42af0baed7b13de3a43eebb72">Apop_col</a>, <a class="el" href="apop_8h.html#a4d7938112c815272f9737685bf128ccb">Apop_col_v</a>, <a class="el" href="apop_8h.html#ad56ce572c7489820777290153ab7d87b">Apop_col_tv</a>, <a class="el" href="apop_8h.html#aaaf15101ec60ce66e80737375baa7391">Apop_col_t</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a9abee86763f92d505fd4fb792f06fd7c"></a><!-- doxytag: member="apop.h::Apop_matrix_row" ref="a9abee86763f92d505fd4fb792f06fd7c" args="(m, row, v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="apop_8h.html#a9abee86763f92d505fd4fb792f06fd7c">Apop_matrix_row</a></td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">m, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">row, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">v&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">gsl_vector apop_vv_##v = gsl_matrix_row((m), (row)).vector;\
gsl_vector * v = &amp;( apop_vv_##v );
</pre></div><p>View a single row of a <code>gsl_matrix</code> as a <code>gsl_vector</code>. This is a convenience macro wrapping <code>gsl_matrix_row</code>.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The <code>gsl_matrix</code> </td></tr>
    <tr><td class="paramname">row</td><td>The number of the desired row. </td></tr>
    <tr><td class="paramname">v</td><td>The name of the vector view that will be created.</td></tr>
  </table>
  </dd>
</dl>
<p>An: example </p>
<div class="fragment"><pre class="fragment">gsl_matrix *m = [fill matrix here];
<a class="code" href="apop_8h.html#a9abee86763f92d505fd4fb792f06fd7c">Apop_matrix_row</a>(m, 2, rowtwo);
<a class="code" href="apop_8h.html#a9abee86763f92d505fd4fb792f06fd7c">Apop_matrix_row</a>(m, 3, rowthree);
printf(<span class="stringliteral">&quot;The correlation coefficient between rows two &quot;</span>
       <span class="stringliteral">&quot;and three is %g.\n&quot;</span>, <a class="code" href="group__vector__moments.html#gae1154897fec0c56bc0161ed24c48759c">apop_vector_correlation</a>(rowtwo, rowthree));
</pre></div> <dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="apop_8h.html#aad1642d90f82ef1f5870a2de4e807005">Apop_rows</a>, <a class="el" href="apop_8h.html#af9032e16affac10d90dd3565e709966d">Apop_row</a>, <a class="el" href="apop_8h.html#a39fd40c5f39795c077716dbaf122d270">Apop_row_v</a>, <a class="el" href="apop_8h.html#a6396c26f1d47cced2be3a761185d3b35">Apop_row_tv</a>, <a class="el" href="apop_8h.html#a7d87af4e65acbf6982a34cf3dc33eae6">Apop_row_t</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ad2e17aea4a8d6dbd5c1208dfe9730415"></a><!-- doxytag: member="apop.h::Apop_maybe_abort" ref="ad2e17aea4a8d6dbd5c1208dfe9730415" args="(level)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Apop_maybe_abort</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">level</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">{<span class="keywordflow">if</span> ((level == -5 &amp;&amp; <a class="code" href="apop_8h.html#a7975faa07196cf463ec261ff0ddc3ccc">apop_opts</a>.<a class="code" href="structapop__opts__type.html#a7b3c6c9e58241b7e69db4fdfc6ee96a2">stop_on_warning</a>!=<span class="charliteral">&#39;n&#39;</span>)                \
            || (<a class="code" href="apop_8h.html#a7975faa07196cf463ec261ff0ddc3ccc">apop_opts</a>.<a class="code" href="structapop__opts__type.html#aa76e9237ed45c77bc883b428c3217a66">verbose</a> &gt;= level &amp;&amp; <a class="code" href="apop_8h.html#a7975faa07196cf463ec261ff0ddc3ccc">apop_opts</a>.<a class="code" href="structapop__opts__type.html#a7b3c6c9e58241b7e69db4fdfc6ee96a2">stop_on_warning</a> == <span class="charliteral">&#39;v&#39;</span>) \
            || (<a class="code" href="apop_8h.html#a7975faa07196cf463ec261ff0ddc3ccc">apop_opts</a>.<a class="code" href="structapop__opts__type.html#a7b3c6c9e58241b7e69db4fdfc6ee96a2">stop_on_warning</a>==<span class="charliteral">&#39;w&#39;</span>) ) \
                raise(SIGTRAP);}
</pre></div>
</div>
</div>
<a class="anchor" id="a15d9e73643bf66f7d69c7ebf959757aa"></a><!-- doxytag: member="apop.h::apop_model_coordinate_transform" ref="a15d9e73643bf66f7d69c7ebf959757aa" args="(...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="apop_8h.html#a15d9e73643bf66f7d69c7ebf959757aa">apop_model_coordinate_transform</a></td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td>&#160;&#160;&#160;Apop_model_copy_set(<a class="el" href="group__models.html#ga80caa743557a86dffa2dd1db64421d82">apop_coordinate_transform</a>, apop_ct, __VA_ARGS__)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Build an <a class="el" href="group__models.html#ga80caa743557a86dffa2dd1db64421d82">apop_coordinate_transform</a> model, qv.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>An <a class="el" href="structapop__model.html">apop_model</a> that is a copy of <a class="el" href="group__models.html#ga80caa743557a86dffa2dd1db64421d82">apop_coordinate_transform</a> and is appropriately set up.</dd></dl>
<ul>
<li>Uses the <a class="el" href="structapop__ct__settings.html">apop_ct_settings</a> group. This macro takes elements of that struct as inputs.</li>
</ul>
<ul>
<li>This function uses the <a class="el" href="designated.html">Designated initializers</a> syntax for inputs. </li>
</ul>

</div>
</div>
<a class="anchor" id="ab664f68b5e481bec56c8ddc7f16928c0"></a><!-- doxytag: member="apop.h::apop_model_dcompose" ref="ab664f68b5e481bec56c8ddc7f16928c0" args="(...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="apop_8h.html#ab664f68b5e481bec56c8ddc7f16928c0">apop_model_dcompose</a></td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td>&#160;&#160;&#160;Apop_model_copy_set(apop_composition, apop_composition, __VA_ARGS__)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><em>Data composition</em> is using either random draws or parameter estimates from the output of one model as the input data for another model.</p>
<ul>
<li>The <a class="el" href="group__models.html#gaedd07c678027bea683f48aa8617c4b89">apop_dcomposition</a> model relies on the <a class="el" href="structapop__composition__settings.html">apop_composition_settings</a> struct, qv. This macro takes the elements of that struct as input. You can use the designated initializer syntax to specify them.</li>
</ul>
<dl class="return"><dt><b>Returns:</b></dt><dd>An <a class="el" href="structapop__model.html">apop_model</a> that is a copy of the <code>apop_composition</code> model. </dd></dl>

</div>
</div>
<a class="anchor" id="a34644b9d55c7528b47f0b887c9241928"></a><!-- doxytag: member="apop.h::apop_model_dconstrain" ref="a34644b9d55c7528b47f0b887c9241928" args="(...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="apop_8h.html#a34644b9d55c7528b47f0b887c9241928">apop_model_dconstrain</a></td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td>&#160;&#160;&#160;Apop_model_copy_set(<a class="el" href="group__models.html#gaa58cece77dea73979ea15d64ea11b049">apop_dconstrain</a>, <a class="el" href="group__models.html#gaa58cece77dea73979ea15d64ea11b049">apop_dconstrain</a>, __VA_ARGS__)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Build an <code>apop_dconstrain</code> model, q.v., which applies a data constraint to the data set. For example, this is how one would truncate a model to have data above zero.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>An <a class="el" href="structapop__model.html">apop_model</a> that is a copy of <a class="el" href="group__models.html#gaa58cece77dea73979ea15d64ea11b049">apop_dconstrain</a> and is appropriately set up.</dd></dl>
<ul>
<li>Uses the <a class="el" href="structapop__dconstrain__settings.html">apop_dconstrain_settings</a> group. This macro takes elements of that struct as inputs.</li>
</ul>
<ul>
<li>This function uses the <a class="el" href="designated.html">Designated initializers</a> syntax for inputs. </li>
</ul>

</div>
</div>
<a class="anchor" id="a40bb98b02fde8f8e4ab59a4d127b692f"></a><!-- doxytag: member="apop.h::apop_model_mixture" ref="a40bb98b02fde8f8e4ab59a4d127b692f" args="(...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="apop_8h.html#a40bb98b02fde8f8e4ab59a4d127b692f">apop_model_mixture</a></td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td>&#160;&#160;&#160;apop_model_mixture_base((<a class="el" href="structapop__model.html">apop_model</a> *[]){__VA_ARGS__, NULL})</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Produce a model as a linear combination of other models. See the documentation for the <a class="el" href="group__models.html#gaf085564a8adc67ba156c4cd1db8145e3">apop_mixture</a> model. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">...</td><td>A list of models, either all parameterized or all unparameterized. See examples in the <a class="el" href="group__models.html#gaf085564a8adc67ba156c4cd1db8145e3">apop_mixture</a> documentation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad9e0398c343aca26d53046462cea770f"></a><!-- doxytag: member="apop.h::apop_model_print_hash" ref="ad9e0398c343aca26d53046462cea770f" args="(m1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define apop_model_print_hash</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">m1</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">((m1)-&gt;log_likelihood ? (<span class="keywordtype">size_t</span>)(m1)-&gt;log_likelihood : \
            (m1)-&gt;p ? (size_t)(m1)-&gt;p*33 : \
            (m1)-&gt;estimate ? (<span class="keywordtype">size_t</span>)(m1)-&gt;estimate*33*33 : \
            (m1)-&gt;draw ? (size_t)(m1)-&gt;draw*33*27  : \
            (m1)-&gt;cdf ? (<span class="keywordtype">size_t</span>)(m1)-&gt;cdf*27*27  \
            : 27)
</pre></div>
</div>
</div>
<a class="anchor" id="ad0e4b98a3edb53646ff9b036cfb558a0"></a><!-- doxytag: member="apop.h::apop_model_stack" ref="ad0e4b98a3edb53646ff9b036cfb558a0" args="(...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="apop_8h.html#ad0e4b98a3edb53646ff9b036cfb558a0">apop_model_stack</a></td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td>&#160;&#160;&#160;apop_model_stack_base((<a class="el" href="structapop__model.html">apop_model</a> *[]){__VA_ARGS__, NULL})</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Generate a model consisting of several models bound together. The output <a class="el" href="structapop__model.html">apop_model</a> is a copy of <a class="el" href="group__models.html#gaf4fa26b04f324b9895b7599e323203df">apop_stack</a>; see that model's documentation for details.</p>
<p>Sample use:</p>
<div class="fragment"><pre class="fragment">    <a class="code" href="structapop__model.html">apop_model</a> *m1 = <a class="code" href="group__models.html#ga36cae46a2950eb6cfb65794cdd5dac7e">apop_model_set_parameters</a>(<a class="code" href="group__models.html#ga297c2dc8dbdf4ae93fc7e10860400466">apop_normal</a>, 0, 1);
    <a class="code" href="structapop__model.html">apop_model</a> *m2 = <a class="code" href="group__models.html#ga87d3a65f43071b9d61d9edd59249c629">apop_model_copy</a>(m1);
    <a class="code" href="structapop__model.html">apop_model</a> *m3 = <a class="code" href="group__models.html#ga87d3a65f43071b9d61d9edd59249c629">apop_model_copy</a>(m1);
    <a class="code" href="structapop__model.html">apop_model</a> *two_independent_normals = <a class="code" href="apop_8h.html#ad0e4b98a3edb53646ff9b036cfb558a0">apop_model_stack</a>(n1, n2);
    <a class="code" href="structapop__model.html">apop_model</a> *three_independent_normals = <a class="code" href="apop_8h.html#ad0e4b98a3edb53646ff9b036cfb558a0">apop_model_stack</a>(n1, n2, n3);

    <span class="comment">//But you don&#39;t have to parameterize ahead of time. E.g.</span>
    <a class="code" href="structapop__model.html">apop_model</a> *two_n = <a class="code" href="apop_8h.html#ad0e4b98a3edb53646ff9b036cfb558a0">apop_model_stack</a>(
                    <a class="code" href="group__models.html#ga87d3a65f43071b9d61d9edd59249c629">apop_model_copy</a>(<a class="code" href="group__models.html#ga297c2dc8dbdf4ae93fc7e10860400466">apop_normal</a>),
                    <a class="code" href="group__models.html#ga87d3a65f43071b9d61d9edd59249c629">apop_model_copy</a>(<a class="code" href="group__models.html#ga297c2dc8dbdf4ae93fc7e10860400466">apop_normal</a>)
                    );
    <a class="code" href="structapop__model.html">apop_model</a> *estimated_norms = <a class="code" href="group__models.html#ga2c0598e5aca68949939a189bd4ce24ca">apop_estimate</a>(indata, two_n);
</pre></div><ul>
<li>If you input only one model, return a copy of that model; print a warning iff <code>apop_opts.verbose &gt;= 1</code>. <dl class="exception"><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">error=='n'</td><td>First model input is <code>NULL</code>. </td></tr>
  </table>
  </dd>
</dl>
</li>
</ul>

</div>
</div>
<a class="anchor" id="a674b73c9b8813f35e41009428cbc80f9"></a><!-- doxytag: member="apop.h::Apop_notify" ref="a674b73c9b8813f35e41009428cbc80f9" args="(verbosity,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="apop_8h.html#a674b73c9b8813f35e41009428cbc80f9">Apop_notify</a></td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">verbosity, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">{\
    if (<a class="code" href="apop_8h.html#a7975faa07196cf463ec261ff0ddc3ccc">apop_opts</a>.<a class="code" href="structapop__opts__type.html#aa76e9237ed45c77bc883b428c3217a66">verbose</a> != -1 &amp;&amp; <a class="code" href="apop_8h.html#a7975faa07196cf463ec261ff0ddc3ccc">apop_opts</a>.<a class="code" href="structapop__opts__type.html#aa76e9237ed45c77bc883b428c3217a66">verbose</a> &gt;= verbosity) {  \
        if (!<a class="code" href="apop_8h.html#a7975faa07196cf463ec261ff0ddc3ccc">apop_opts</a>.<a class="code" href="structapop__opts__type.html#a27e596063680b5b56ba5bf39fc2b6647">log_file</a>) <a class="code" href="apop_8h.html#a7975faa07196cf463ec261ff0ddc3ccc">apop_opts</a>.log_file = stderr; \
        fprintf(<a class="code" href="apop_8h.html#a7975faa07196cf463ec261ff0ddc3ccc">apop_opts</a>.log_file, &quot;%s: &quot;, __func__); fprintf(<a class="code" href="apop_8h.html#a7975faa07196cf463ec261ff0ddc3ccc">apop_opts</a>.log_file, __VA_ARGS__); fprintf(<a class="code" href="apop_8h.html#a7975faa07196cf463ec261ff0ddc3ccc">apop_opts</a>.log_file, &quot;\n&quot;);   \
        fflush(<a class="code" href="apop_8h.html#a7975faa07196cf463ec261ff0ddc3ccc">apop_opts</a>.log_file); \
} }
</pre></div><p>Notify the user of errors, warning, or debug info.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">verbosity</td><td>At what verbosity level should the user be warned? E.g., if level==2, then print iff apop_opts.verbosity &gt;= 2. </td></tr>
    <tr><td class="paramname">...</td><td>The message to write to STDERR (presuming the verbosity level is high enough). This can be a printf-style format with following arguments. You can produce much more informative error messages this way, e.g., <code>apop_notify</code>(0, "Beta is %g but should be greater than zero.", beta);. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1e829ce2396bf05ab10460bcc37aeeab"></a><!-- doxytag: member="apop.h::apop_rng_get_thread" ref="a1e829ce2396bf05ab10460bcc37aeeab" args="(thread_in)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="apop_8h.html#a1e829ce2396bf05ab10460bcc37aeeab">apop_rng_get_thread</a></td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">thread_in</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The <code>gsl_rng</code> is not itself thread-safe, in the sense that it can not be used simultaneously by multiple threads. However, if each thread has its own <code>gsl_rng</code>, then each will safely operate independently.</p>
<p>Thus, Apophenia keeps an internal store of RNGs for use by threaded functions. If the input to this function, <code>thread</code>, is greater than any previous input, then the array of <code>gsl_rng</code>s is extended to length <code>thread</code>, and each element extended using <code>++apop_opts.rng_seed</code> (i.e., the seed is incremented before use).</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">thread_in</td><td>The number of the RNG to retrieve, starting at zero (which is how OpenMP numbers its threads). If blank, I'll look up the current thread (via <code>omp_get_thread_num</code>) for you.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The appropriate RNG, initialized if necessary. </dd></dl>

</div>
</div>
<a class="anchor" id="af9032e16affac10d90dd3565e709966d"></a><!-- doxytag: member="apop.h::Apop_row" ref="af9032e16affac10d90dd3565e709966d" args="(d, row, outd)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="apop_8h.html#af9032e16affac10d90dd3565e709966d">Apop_row</a></td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">d, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">row, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">outd&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>A macro to generate a temporary one-row view of <a class="el" href="gentle.html#apop_data">apop_data</a> set <code>d</code>, pulling out only row <code>row</code>. After this call, <code>outd</code> will be a pointer to this temporary view, that you can use as you would any <a class="el" href="gentle.html#apop_data">apop_data</a> set. This macro expands to <code><a class="el" href="apop_8h.html#aad1642d90f82ef1f5870a2de4e807005">Apop_rows(d, row, 1, outd)</a></code>. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="apop_8h.html#aad1642d90f82ef1f5870a2de4e807005">Apop_rows</a>, <a class="el" href="apop_8h.html#a39fd40c5f39795c077716dbaf122d270">Apop_row_v</a>, <a class="el" href="apop_8h.html#a6396c26f1d47cced2be3a761185d3b35">Apop_row_tv</a>, <a class="el" href="apop_8h.html#a7d87af4e65acbf6982a34cf3dc33eae6">Apop_row_t</a>, <a class="el" href="apop_8h.html#a9abee86763f92d505fd4fb792f06fd7c">Apop_matrix_row</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a7d87af4e65acbf6982a34cf3dc33eae6"></a><!-- doxytag: member="apop.h::Apop_row_t" ref="a7d87af4e65acbf6982a34cf3dc33eae6" args="(d, rowname, outd)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="apop_8h.html#a7d87af4e65acbf6982a34cf3dc33eae6">Apop_row_t</a></td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">d, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">rowname, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">outd&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>After this call, <code>v</code> will hold a view of an <a class="el" href="gentle.html#apop_data">apop_data</a> set consisting only of the <code>row</code>th row of the <a class="el" href="gentle.html#apop_data">apop_data</a> set <code>m</code>. Unlike <a class="el" href="apop_8h.html#af9032e16affac10d90dd3565e709966d">Apop_row</a>, the second argument is a row name, that I'll look up using <a class="el" href="apop__name_8c.html#ac1b94277b0055f11d00f6dd26cb70e00">apop_name_find</a>. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="apop_8h.html#aad1642d90f82ef1f5870a2de4e807005">Apop_rows</a>, <a class="el" href="apop_8h.html#af9032e16affac10d90dd3565e709966d">Apop_row</a>, <a class="el" href="apop_8h.html#a39fd40c5f39795c077716dbaf122d270">Apop_row_v</a>, <a class="el" href="apop_8h.html#a6396c26f1d47cced2be3a761185d3b35">Apop_row_tv</a>, <a class="el" href="apop_8h.html#a9abee86763f92d505fd4fb792f06fd7c">Apop_matrix_row</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a6396c26f1d47cced2be3a761185d3b35"></a><!-- doxytag: member="apop.h::Apop_row_tv" ref="a6396c26f1d47cced2be3a761185d3b35" args="(m, row, v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="apop_8h.html#a6396c26f1d47cced2be3a761185d3b35">Apop_row_tv</a></td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">m, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">row, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">v&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>After this call, <code>v</code> will hold a vector view of the <code>row</code>th row of the <a class="el" href="gentle.html#apop_data">apop_data</a> set <code>m</code>. Unlike <a class="el" href="apop_8h.html#a39fd40c5f39795c077716dbaf122d270">Apop_row_v</a>, the second argument is a row name, that I'll look up using <a class="el" href="apop__name_8c.html#ac1b94277b0055f11d00f6dd26cb70e00">apop_name_find</a>. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="apop_8h.html#aad1642d90f82ef1f5870a2de4e807005">Apop_rows</a>, <a class="el" href="apop_8h.html#af9032e16affac10d90dd3565e709966d">Apop_row</a>, <a class="el" href="apop_8h.html#a39fd40c5f39795c077716dbaf122d270">Apop_row_v</a>, <a class="el" href="apop_8h.html#a7d87af4e65acbf6982a34cf3dc33eae6">Apop_row_t</a>, <a class="el" href="apop_8h.html#a9abee86763f92d505fd4fb792f06fd7c">Apop_matrix_row</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a39fd40c5f39795c077716dbaf122d270"></a><!-- doxytag: member="apop.h::Apop_row_v" ref="a39fd40c5f39795c077716dbaf122d270" args="(m, row, v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="apop_8h.html#a39fd40c5f39795c077716dbaf122d270">Apop_row_v</a></td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">m, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">row, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">v&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>After this call, <code>v</code> will hold a vector view of the <code>row</code>th row of the <a class="el" href="gentle.html#apop_data">apop_data</a> set <code>m</code>. This is like <a class="el" href="apop_8h.html#af9032e16affac10d90dd3565e709966d">Apop_row</a>, but the output is a <code>gsl_vector</code>, not a full <a class="el" href="gentle.html#apop_data">apop_data</a> set. It is like <a class="el" href="apop_8h.html#a9abee86763f92d505fd4fb792f06fd7c">Apop_matrix_row</a>, but the input is a <a class="el" href="gentle.html#apop_data">apop_data</a> set, not a <code>gsl_matrix</code>. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="apop_8h.html#aad1642d90f82ef1f5870a2de4e807005">Apop_rows</a>, <a class="el" href="apop_8h.html#af9032e16affac10d90dd3565e709966d">Apop_row</a>, <a class="el" href="apop_8h.html#a6396c26f1d47cced2be3a761185d3b35">Apop_row_tv</a>, <a class="el" href="apop_8h.html#a7d87af4e65acbf6982a34cf3dc33eae6">Apop_row_t</a>, <a class="el" href="apop_8h.html#a9abee86763f92d505fd4fb792f06fd7c">Apop_matrix_row</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aad1642d90f82ef1f5870a2de4e807005"></a><!-- doxytag: member="apop.h::Apop_rows" ref="aad1642d90f82ef1f5870a2de4e807005" args="(d, rownum, len, outd)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="apop_8h.html#aad1642d90f82ef1f5870a2de4e807005">Apop_rows</a></td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">d, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">rownum, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">len, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">outd&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>A macro to generate a temporary view of <a class="el" href="gentle.html#apop_data">apop_data</a> set <code>d</code>, beginning at row <code>row</code> and having length <code>len</code>. After this call, <code>outd</code> will be a pointer to this temporary view, that you can use as you would any <a class="el" href="gentle.html#apop_data">apop_data</a> set. However, it expires as soon as the program leaves the current scope (like with the usual automatically declared vars). </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="apop_8h.html#af9032e16affac10d90dd3565e709966d">Apop_row</a>, <a class="el" href="apop_8h.html#a39fd40c5f39795c077716dbaf122d270">Apop_row_v</a>, <a class="el" href="apop_8h.html#a6396c26f1d47cced2be3a761185d3b35">Apop_row_tv</a>, <a class="el" href="apop_8h.html#a7d87af4e65acbf6982a34cf3dc33eae6">Apop_row_t</a>, <a class="el" href="apop_8h.html#a9abee86763f92d505fd4fb792f06fd7c">Apop_matrix_row</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a47600802191d9ccf5d48fce70e754294"></a><!-- doxytag: member="apop.h::Apop_settings_copy" ref="a47600802191d9ccf5d48fce70e754294" args="(name,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="apop_8h.html#a47600802191d9ccf5d48fce70e754294">Apop_settings_copy</a></td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">name, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment"><span class="keywordtype">void</span> * name##_settings_copy(name##_settings *in) {\
        name##_settings *out = malloc(<span class="keyword">sizeof</span>(name##_settings)); \
        *out = *in; \
        __VA_ARGS__;    \
        return out;     \
    }
</pre></div><p>A convenience macro for declaring the copy function for a new settings group. See the documentation outline -&gt; models -&gt; model settings -&gt; writing new settings group for details.</p>
<p>To just do a direct copy, the default works; let your settings group be named <code>ysg:</code> </p>
<div class="fragment"><pre class="fragment"><a class="code" href="apop_8h.html#a47600802191d9ccf5d48fce70e754294">Apop_settings_copy</a> (ysg, )
</pre></div><p> generates a function that allocates space for a new settings group and copies all elements from the input group to the output group.</p>
<p>The space after the comma indicates that there is no new procedural code. If you want to add some, feel free. E.g., </p>
<div class="fragment"><pre class="fragment"><a class="code" href="apop_8h.html#a47600802191d9ccf5d48fce70e754294">Apop_settings_copy</a> (ysg, 
    <span class="keywordflow">if</span> (!in-&gt;score)
        out-&gt;score = 1;
    out-&gt;data_owner = 0;
)
</pre></div><p> The names <code>in</code> and <code>out</code> are built into the macro. </p>

</div>
</div>
<a class="anchor" id="aae80181842102bf58ba1ffe18391796b"></a><!-- doxytag: member="apop.h::Apop_settings_declarations" ref="aae80181842102bf58ba1ffe18391796b" args="(ysg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="apop_8h.html#aae80181842102bf58ba1ffe18391796b">Apop_settings_declarations</a></td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ysg</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">ysg##_settings * ysg##_settings_init(ysg##_settings); \
   void * ysg##_settings_copy(ysg##_settings *); \
   void ysg##_settings_free(ysg##_settings *);
</pre></div>
</div>
</div>
<a class="anchor" id="a833e962fb042462eeadada7484671f07"></a><!-- doxytag: member="apop.h::Apop_settings_free" ref="a833e962fb042462eeadada7484671f07" args="(name,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="apop_8h.html#a833e962fb042462eeadada7484671f07">Apop_settings_free</a></td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">name, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment"><span class="keywordtype">void</span> name##_settings_free(name##_settings *in) {\
        __VA_ARGS__;    \
        free(in);  \
    }
</pre></div><p>A convenience macro for declaring the delete function for a new settings group. See the documentation outline -&gt; models -&gt; model settings -&gt; writing new settings group for details.</p>
<p>If you don't have internal structure elements to free, let your settings group be named <code>ysg:</code> </p>
<div class="fragment"><pre class="fragment">  <a class="code" href="apop_8h.html#a833e962fb042462eeadada7484671f07">Apop_settings_free</a> (ysg, )
</pre></div><p> generates a function that simply frees the input settings group.</p>
<p>If your structure is pointing to other structures that need to be freed first, then add them after that comma: </p>
<div class="fragment"><pre class="fragment"><a class="code" href="apop_8h.html#a47600802191d9ccf5d48fce70e754294">Apop_settings_copy</a> (ysg, 
    <a class="code" href="apop_8h.html#a459acfde11f2c39f5c32cff377f85b9e">apop_data_free</a>(in-&gt;dataset);
)
</pre></div><p> The name <code>in</code> is built into the macro. </p>

</div>
</div>
<a class="anchor" id="aefe030e4bba4671d8b026e81be70f764"></a><!-- doxytag: member="apop.h::Apop_settings_init" ref="aefe030e4bba4671d8b026e81be70f764" args="(name,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="apop_8h.html#aefe030e4bba4671d8b026e81be70f764">Apop_settings_init</a></td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">name, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">name##_settings *name##_settings_init(name##_settings in) {       \
        name##_settings *out = malloc(<span class="keyword">sizeof</span>(name##_settings));     \
        *out = in; \
        __VA_ARGS__;            \
        return out; \
    }
</pre></div><p>A convenience macro for declaring the initialization function for a new settings group. See the documentation outline -&gt; models -&gt; model settings -&gt; writing new settings group for details.</p>
<p>This sets the defaults for every element in the structure, so you will want a line for every element of your structure (except the ones that default to NULL, which have already been set as such).</p>
<div class="fragment"><pre class="fragment">  <a class="code" href="apop_8h.html#aefe030e4bba4671d8b026e81be70f764">Apop_settings_init</a> (ysg, 
        Apop_varad_set(size1, 99);
        Apop_varad_set(size2, 2.3);
        Apop_varad_set(dataset, <a class="code" href="apop_8h.html#ac39d6a56933b6f084328ec5ecd5090d8">apop_data_alloc</a>(out-&gt;size1, out-&gt;size2));
    )
</pre></div><p> If you need them, the input is a structure named <code>in</code>, and the output a pointer-to-struct named <code>out</code>. </p>

</div>
</div>
<a class="anchor" id="abd17601e642688d033f62d346f3dace6"></a><!-- doxytag: member="apop.h::Apop_stopif" ref="abd17601e642688d033f62d346f3dace6" args="(test, onfail, level,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="apop_8h.html#abd17601e642688d033f62d346f3dace6">Apop_stopif</a></td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">test, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">onfail, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">level, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment"><span class="keywordflow">do</span> {\
     if (test) {  \
        Apop_notify(level,  __VA_ARGS__);   \
        Apop_maybe_abort(level)  \
        onfail;  \
    } } <span class="keywordflow">while</span>(0)
</pre></div><p>Execute an action and print a message to <code>stderr</code> (or the current <code>FILE</code> handle held by <code>apop_opts.log_file</code>). Intended for leaving a function on failure.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">test</td><td>The expression that, if true, triggers all the action. </td></tr>
    <tr><td class="paramname">onfail</td><td>If the assertion fails, do this. E.g., <code>out-&gt;error='x'; return GSL_NAN</code>. Notice that it is OK to include several lines of semicolon-separated code here, but if you have a lot to do, the most readable option may be <code>goto outro</code>, plus an appropriately-labeled section at the end of your function. </td></tr>
    <tr><td class="paramname">level</td><td>Print the warning message only if <a class="el" href="structapop__opts__type.html">apop_opts.verbose</a> is greater than or equal to this. Zero usually works, but for minor infractions use one. </td></tr>
    <tr><td class="paramname">...</td><td>The error message in printf form, plus any arguments to be inserted into the printf string. I'll provide the function name and a carriage return.</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>If <code>apop_opts.stop_on_warning</code> is nonzero and not <code>'v'</code>, then a failed test halts via <code>abort()</code>, even if the <code>apop_opts.verbose</code> level is set so that the warning message doesn't print to screen. Use this when running via debugger. </li>
<li>If <code>apop_opts.stop_on_warning</code> is <code>'v'</code>, then a failed test halts via <code>abort()</code> iff the verbosity level is high enough to print the error. </li>
</ul>

</div>
</div>
<a class="anchor" id="a07588193981c84a4ab7f0370e38b8971"></a><!-- doxytag: member="apop.h::APOP_SUBMATRIX" ref="a07588193981c84a4ab7f0370e38b8971" args="(m, srow, scol, nrows, ncols, o)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define APOP_SUBMATRIX</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">m, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">srow, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">scol, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">nrows, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ncols, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">o&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">gsl_matrix apop_mm_##o = gsl_matrix_submatrix((m), (srow), (scol), (nrows),(ncols)).matrix;\
gsl_matrix * o = &amp;( apop_mm_##o );
</pre></div>
</div>
</div>
<a class="anchor" id="a8c66c0e920b1898f13c58174ef2fbf86"></a><!-- doxytag: member="apop.h::Apop_submatrix" ref="a8c66c0e920b1898f13c58174ef2fbf86" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="apop_8h.html#a8c66c0e920b1898f13c58174ef2fbf86">Apop_submatrix</a>&#160;&#160;&#160;APOP_SUBMATRIX</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Find the mean of the input vector. Generate a subview of a submatrix within a <code>gsl_matrix</code>. Like <a class="el" href="apop_8h.html#a9abee86763f92d505fd4fb792f06fd7c">Apop_matrix_row</a>, <a class="el" href="apop_8h.html#af9032e16affac10d90dd3565e709966d">Apop_row</a>, et al., the view is an automatically-allocated variable that is lost once the program flow leaves the scope in which it is declared.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The root matrix </td></tr>
    <tr><td class="paramname">srow</td><td>the first row (in the root matrix) of the top of the submatrix </td></tr>
    <tr><td class="paramname">scol</td><td>the first column (in the root matrix) of the left edge of the submatrix </td></tr>
    <tr><td class="paramname">nrow</td><td>number of rows in the submatrix </td></tr>
    <tr><td class="paramname">ncol</td><td>number of columns in the submatrix </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a74dca50ea16ed7bf25cb152315642769"></a><!-- doxytag: member="apop.h::apop_text_fill" ref="a74dca50ea16ed7bf25cb152315642769" args="(dataset,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="apop_8h.html#a74dca50ea16ed7bf25cb152315642769">apop_text_fill</a></td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">dataset, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;apop_text_fill_base((dataset), (char* []) {__VA_ARGS__, NULL})</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Fill the text part of an already-allocated <a class="el" href="gentle.html#apop_data">apop_data</a> set with a list of strings.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">dataset</td><td>A data set that you already prepared with <a class="el" href="apop__data_8c.html#a9fba0f07c262a433133f6f3362617da3">apop_text_alloc</a>. </td></tr>
    <tr><td class="paramname">...</td><td>A list of strings. The first row is filled first, then the second, and so on to the end of the text grid.</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>No <code>NULL</code> strings. A blank string, <code>""</code> is OK. </li>
<li>If you provide more or fewer strings than are needed to fill the text grid and <code>apop_opts.verbose &gt;=1</code>, I print a warning and continue to the end of the text grid or data set, whichever is shorter. </li>
<li>If the data set is <code>NULL</code>, I return <code>NULL</code>. If you provide a <code>NULL</code> data set but a non-NULL list of text elements, and <code>apop_opts.verbose &gt;=1</code>, I print a warning and return <code>NULL</code>. </li>
<li>Remember that the C preprocessor concatenates two adjacent strings into one. Here is an attempt to fill a <img class="formulaInl" alt="$ 2\times 3$" src="form_8.png"/> grid: <div class="fragment"><pre class="fragment">  <a class="code" href="structapop__data.html">apop_data</a> *one23 = <a class="code" href="apop_8h.html#a74dca50ea16ed7bf25cb152315642769">apop_text_fill</a>(<a class="code" href="apop_8h.html#a9fba0f07c262a433133f6f3362617da3">apop_text_alloc</a>(NULL, 2, 3),
                                     <span class="stringliteral">&quot;one&quot;</span>, <span class="stringliteral">&quot;two&quot;</span>, <span class="stringliteral">&quot;three&quot;</span>   <span class="comment">//missing comma!</span>
                                     <span class="stringliteral">&quot;two&quot;</span>, <span class="stringliteral">&quot;four&quot;</span>, <span class="stringliteral">&quot;six&quot;</span>);
</pre></div> The preprocessor will join <code>"three" "two"</code> to form <code>"threetwo"</code>, leaving you with only five strings.</li>
</ul>
<ul>
<li>If you have a <code>NULL-delimited</code> array of strings (not just a loose list as above), then use <code>apop_text_fill_base</code>. </li>
</ul>

</div>
</div>
<a class="anchor" id="a86b0e2e1e0218f7ea26f00266fb4b7ba"></a><!-- doxytag: member="apop.h::apop_update_hash" ref="a86b0e2e1e0218f7ea26f00266fb4b7ba" args="(m1, m2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define apop_update_hash</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">m1, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">m2&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">(          \
           ((m1)-&gt;log_likelihood ? (<span class="keywordtype">size_t</span>)(m1)-&gt;log_likelihood : \
            (m1)-&gt;p              ? (size_t)(m1)-&gt;p*33 : \
            (m1)-&gt;draw           ? (<span class="keywordtype">size_t</span>)(m1)-&gt;draw*33*27 \
                                 : 33*27*19) \
          +((m2)-&gt;log_likelihood ? (<span class="keywordtype">size_t</span>)(m2)-&gt;log_likelihood : \
            (m2)-&gt;p              ? (size_t)(m2)-&gt;p*33 : \
            (m2)-&gt;draw           ? (<span class="keywordtype">size_t</span>)(m2)-&gt;draw*33*27 \
                                 : 33*27*19 \
           ) * 37)
</pre></div>
</div>
</div>
<a class="anchor" id="a7c094762ec90f0ddae7682fce9fc1a31"></a><!-- doxytag: member="apop.h::apop_varad_declare" ref="a7c094762ec90f0ddae7682fce9fc1a31" args="(type, name,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define apop_varad_declare</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">type, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">name, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment"><span class="keyword">typedef</span> <span class="keyword">struct </span>{                        \
                __VA_ARGS__ ;               \
            } variadic_type_##name;         \
    apop_varad_head(type, name);
</pre></div>
</div>
</div>
<a class="anchor" id="af9b051e2fbe0e473dddeabfe4932ce0c"></a><!-- doxytag: member="apop.h::apop_vector_fill" ref="af9b051e2fbe0e473dddeabfe4932ce0c" args="(avfin,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="apop_8h.html#af9b051e2fbe0e473dddeabfe4932ce0c">apop_vector_fill</a></td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">avfin, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;apop_vector_fill_base((avfin), (double []) {__VA_ARGS__})</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Fill a pre-allocated <code>gsl_vector</code> with values.</p>
<p>See <code>apop_data_alloc</code> for a relevant example. See also <code>apop_matrix_alloc</code>.</p>
<p>Warning: I need as many arguments as the size of the vector, and can't count them for you. Too many will be ignored; too few will produce unpredictable results, which may include padding your vector with garbage or a simple segfault.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">avfin</td><td>A <code>gsl_vector</code> (that you have already allocated). </td></tr>
    <tr><td class="paramname">...</td><td>A series of exactly as many values as there are spaces in the vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A pointer to the same vector that was input. </dd></dl>

</div>
</div>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="a0c8c2a99fb8c6ec54822aca08591545e"></a><!-- doxytag: member="apop.h::apop_data" ref="a0c8c2a99fb8c6ec54822aca08591545e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structapop__data.html">apop_data</a>  <a class="el" href="structapop__data.html">apop_data</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The <a class="el" href="gentle.html#apop_data">apop_data</a> structure represents a data set. It primarily joins together a gsl_vector, a gsl_matrix, and a table of strings, then gives them all row and column names. It tries to be minimally intrusive, so you can use it everywhere you would use a <code>gsl_matrix</code> or a <code>gsl_vector</code>.</p>
<p>If you are viewing the HTML documentation, here is a diagram showing a sample data set with all of the elements in place. Together, they represet a data set where each row is an observation, which includes both numeric and text values, and where each row/column is named.</p>
<table frame=box>
<tr>
<td>Rowname</td><td>Vector</td><td> Matrix</td><td> Text</td><td>Weights</td>
</tr><tr valign=bottom>
<td align=center>
<table frame=box>
<tr><td> </td></tr>
<tr>
<td>"Steven"</td>
</tr><tr>
<td>"Sandra"</td>
</tr><tr>
<td>"Joe"</td><td>
</tr> 
</table>
</td><td align=center>
<table frame=box>
<tr>
<th>Outcome</th>
</tr> <tr>
<td align=center>1</td>
</tr><tr>
<td align=center>0</td>
</tr><tr>
<td align=center>1</td>
</tr> 
</table>
</td><td align=center>
<table frame=box>
<tr>
<th> Age</th><th> Weight (kg)</th><th> Height (cm)</th>
</tr> <tr>
<td> 32</td><td> 65</td><td> 175</td>
</tr><tr>
<td> 41</td><td> 61</td><td> 165</td>
</tr><tr>
<td> 40</td><td> 73</td><td> 181</td>
</tr> 
</table>
</td><td align=center>
<table frame=box>
<tr>
<th> Sex</th><th> State</th>
</tr>
<tr>
<td> Male</td><td> Alaska</td><td>
</tr><tr>
<td> Female</td><td> Alabama</td>
</tr><tr>
<td> Male</td><td> Alabama</td>
</tr> 
</table>
</td><td align=center>
<table frame=box>
<tr><td> </td></tr>
<tr>
<td>1</td>
</tr><tr>
<td>3.2</td>
</tr><tr>
<td>2.4</td>
</tr> 
</table>
</td></tr>
</table>
<p>Allocate using <code>apop_data_alloc</code>, free via <code>apop_data_free</code>, or more generally, see the <code>apop_data_</code>... section of the index (in the header links) for the many other functions that operate on this struct.</p>
<p>See also the Data Sets section of the outline page (also in the header links) for further notes on getting and manipulating the elements of an <a class="el" href="gentle.html#apop_data">apop_data</a> set. </p>

</div>
</div>
<a class="anchor" id="afe86ae10fc82d219906211e4f88e4cf9"></a><!-- doxytag: member="apop.h::apop_model" ref="afe86ae10fc82d219906211e4f88e4cf9" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structapop__model.html">apop_model</a> <a class="el" href="structapop__model.html">apop_model</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>A statistical model. </p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a1309242dbb7f148916c71a9a70c6b64c"></a><!-- doxytag: member="apop.h::apop_anova" ref="a1309242dbb7f148916c71a9a70c6b64c" args="(char *table, char *data, char *grouping1, char *grouping2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__data.html">apop_data</a>* <a class="el" href="apop__tests_8c.html#a1309242dbb7f148916c71a9a70c6b64c">apop_anova</a> </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>grouping1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>grouping2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function produces a traditional one- or two-way ANOVA table. It works from data in an SQL table, using queries of the form <code>select data from table group by grouping1, grouping2</code>.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>The table to be queried. Anything that can go in an SQL <code>from</code> clause is OK, so this can be a plain table name or a temp table specification like <code>(select ... )</code>, with parens. </td></tr>
    <tr><td class="paramname">data</td><td>The name of the column holding the count or other such data </td></tr>
    <tr><td class="paramname">grouping1</td><td>The name of the first column by which to group data </td></tr>
    <tr><td class="paramname">grouping2</td><td>If this is <code>NULL</code>, then the function will return a one-way ANOVA. Otherwise, the name of the second column by which to group data in a two-way ANOVA. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0492d6f5ae8a73a60b651cadb113d643"></a><!-- doxytag: member="apop.h::apop_arms_draw" ref="a0492d6f5ae8a73a60b651cadb113d643" args="(double *out, gsl_rng *r, apop_model *m)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="apop__arms_8c.html#a0492d6f5ae8a73a60b651cadb113d643">apop_arms_draw</a> </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsl_rng *&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structapop__model.html">apop_model</a> *&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adaptive rejection metropolis sampling. </p>
<p>This is a function to make random draws from any univariate distribution (more or less).</p>
<p>The author, Wally Gilks, explains on <a href="http://www.amsta.leeds.ac.uk/~wally.gilks/adaptive.rejection/web_page/Welcome.html,">http://www.amsta.leeds.ac.uk/~wally.gilks/adaptive.rejection/web_page/Welcome.html,</a> that ``ARS works by constructing an envelope function of the log of the target density, which is then used in rejection sampling (see, for example, Ripley, 1987). Whenever a point is rejected by ARS, the envelope is updated to correspond more closely to the true log density, thereby reducing the chance of rejecting subsequent points. Fewer ARS rejection steps implies fewer point-evaluations of the log density.''</p>
<ul>
<li>It accepts only functions with univariate inputs. I.e., it will put a single value in the vector part of a <a class="el" href="gentle.html#apop_data">apop_data</a> set, and then evaluate the log likelihood at that point.</li>
</ul>
<ul>
<li>It is currently the default for the <a class="el" href="group__models.html#ga87f15cd1923ed7b5b46e52a77ca1dfef">apop_draw</a> function, so you can just call that if you prefer.</li>
</ul>
<ul>
<li>There are a great number of parameters, in the <code><a class="el" href="structapop__arms__settings.html">apop_arms_settings</a></code> structure. The structure also holds a history of the points tested to date. That means that the system will be more accurate as more draws are made. It also means that if the parameters change, or you use <a class="el" href="group__models.html#ga87d3a65f43071b9d61d9edd59249c629">apop_model_copy</a>, you should call <code><a class="el" href="group__settings.html#ga4ff4361f65c1e848fabce24b4b8f44f7">Apop_settings_rm_group(your_model, apop_arms)</a></code> to clear the model of points that are not valid for a different situation.</li>
</ul>
<ul>
<li>See <a class="el" href="structapop__arms__settings.html">apop_arms_settings</a> for the list of parameters that you may want to set, via a form like <code>apop_model_add_group(your_model, apop_arms, .model=your_model, .xl=8, .xr =14);</code>. The <code>model</code> element is mandatory; you'll get a run-time complaint if you forget it. </li>
</ul>

</div>
</div>
<a class="anchor" id="a69adca14afc66100168f585e05b59dcb"></a><!-- doxytag: member="apop.h::apop_beta_from_mean_var" ref="a69adca14afc66100168f585e05b59dcb" args="(double m, double v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__model.html">apop_model</a>* <a class="el" href="apop__asst_8c.html#a69adca14afc66100168f585e05b59dcb">apop_beta_from_mean_var</a> </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The Beta distribution is useful for modeling because it is bounded between zero and one, and can be either unimodal (if the variance is low) or bimodal (if the variance is high), and can have either a slant toward the bottom or top of the range (depending on the mean).</p>
<p>The distribution has two parameters, typically named <img class="formulaInl" alt="$\alpha$" src="form_4.png"/> and <img class="formulaInl" alt="$\beta$" src="form_5.png"/>, which can be difficult to interpret. However, there is a one-to-one mapping between (alpha, beta) pairs and (mean, variance) pairs. Since we have good intuition about the meaning of means and variances, this function takes in a mean and variance, calculates alpha and beta behind the scenes, and returns a random draw from the appropriate Beta distribution.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The mean the Beta distribution should have. Notice that m is in [0,1].</td></tr>
    <tr><td class="paramname">v</td><td>The variance which the Beta distribution should have. It is in (0, 1/12), where (1/12) is the variance of a Uniform(0,1) distribution. Funny things happen with variance near 1/12 and mean far from 1/2.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns an <code>apop_beta</code> model with its parameters appropriately set. </dd></dl>
<dl class="exception"><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">out-&gt;error=='r'</td><td>Range error: mean is not within [0, 1]. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4eb57b1f864c650ed6d7e029550e7bb8"></a><!-- doxytag: member="apop.h::apop_bootstrap_cov" ref="a4eb57b1f864c650ed6d7e029550e7bb8" args="(apop_data *data, apop_model *model, gsl_rng *rng, int iterations, char keep_boots, char ignore_nans)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__data.html">apop_data</a>* <a class="el" href="apop__bootstrap_8c.html#a4eb57b1f864c650ed6d7e029550e7bb8">apop_bootstrap_cov</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structapop__model.html">apop_model</a> *&#160;</td>
          <td class="paramname"><em>model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsl_rng *&#160;</td>
          <td class="paramname"><em>rng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iterations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>keep_boots</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>ignore_nans</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Give me a data set and a model, and I'll give you the bootstrapped covariance matrix of the parameter estimates.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The data set. An <code><a class="el" href="structapop__data.html">apop_data</a></code> set where each row is a single data point. (No default) </td></tr>
    <tr><td class="paramname">model</td><td>An <a class="el" href="structapop__model.html">apop_model</a>, whose <code>estimate</code> method will be used here. (No default) </td></tr>
    <tr><td class="paramname">iterations</td><td>How many bootstrap draws should I make? (default: 1,000) </td></tr>
    <tr><td class="paramname">rng</td><td>An RNG that you have initialized, probably with <code>apop_rng_alloc</code>. (Default: an RNG from <a class="el" href="apop_8h.html#a1e829ce2396bf05ab10460bcc37aeeab">apop_rng_get_thread</a>) </td></tr>
    <tr><td class="paramname">keep_boots</td><td>If 'y', then add a page to the output <a class="el" href="gentle.html#apop_data">apop_data</a> set with the statistics calculated for each bootstrap iteration. They are packed via <a class="el" href="group__conversions.html#ga7e31798ab418cbfc7488eaba27dad2af">apop_data_pack</a>, so use <a class="el" href="group__conversions.html#gae3058b7f39d0442f13284464d1ba235d">apop_data_unpack</a> if needed. (Default: 'n') <div class="fragment"><pre class="fragment"><a class="code" href="structapop__data.html">apop_data</a> *boot_output = <a class="code" href="apop_8h.html#a4eb57b1f864c650ed6d7e029550e7bb8">apop_bootstrap_cov</a>(your_data, your_model, .keep_boots=<span class="charliteral">&#39;y&#39;</span>);
<a class="code" href="structapop__data.html">apop_data</a> *boot_stats = <a class="code" href="apop_8h.html#a044771db76f0afb410a8d4f05ac51ca3">apop_data_get_page</a>(boot_output, <span class="stringliteral">&quot;&lt;bootstrapped statistics&gt;&quot;</span>);

<a class="code" href="apop_8h.html#a9abee86763f92d505fd4fb792f06fd7c">Apop_matrix_row</a>(boot_stats-&gt;matrix, 27, row_27)
<span class="comment">//If the output statistic is not just a vector, you&#39;ll need to use apop_data_unpack to put</span>
<span class="comment">//it into the right shape. Let&#39;s assume for now that it&#39;s just a vector:</span>
printf(&quot;The statistics calculated on the 28th iteration:\n&quot;);
<a class="code" href="group__apop__print.html#ga6e68deb42339cf6068ab6e741237918d">apop_vector_print</a>(row_27);
</pre></div> </td></tr>
    <tr><td class="paramname">ignore_nans</td><td>If <code>'y'</code> and any of the elements in the estimation return <code>NaN</code>, then I will throw out that draw and try again. If <code>'n'</code>, then I will write that set of statistics to the list, <code>NaN</code> and all. I keep count of throw-aways; if there are more than <code>iterations</code> elements thrown out, then I throw an error and return with estimates using data I have so far. That is, I assume that <code>NaNs</code> are rare edge cases; if they are as common as good data, you might want to rethink how you are using the bootstrap mechanism. (Default: 'n') </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>An <code><a class="el" href="structapop__data.html">apop_data</a></code> set whose matrix element is the estimated covariance matrix of the parameters. </dd></dl>
<dl class="exception"><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">out-&gt;error=='n'</td><td><code>NULL</code> input data. </td></tr>
    <tr><td class="paramname">out-&gt;error=='N'</td><td><code>too</code> many Nans. <ul>
<li>This function uses the <a class="el" href="designated.html">Designated initializers</a> syntax for inputs. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="apop__bootstrap_8c.html#a634432014188489d758d7c1acfc9a0a5">apop_jackknife_cov</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aee8c299b83b8500b8b6ecd30817353c8"></a><!-- doxytag: member="apop.h::apop_crosstab_to_db" ref="aee8c299b83b8500b8b6ecd30817353c8" args="(apop_data *in, char *tabname, char *row_col_name, char *col_col_name, char *data_col_name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="apop__conversions_8c.html#aee8c299b83b8500b8b6ecd30817353c8">apop_crosstab_to_db</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>tabname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>row_col_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>col_col_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>data_col_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>See <a class="el" href="apop__conversions_8c.html#aebe17fe6f2b0c49c0c90824b7a68ff90">apop_db_to_crosstab</a> for the storyline; this is the complement, which takes a crosstab and writes its values to the database.</p>
<p>For example, I would take </p>
<table  frame="box">
<tr>
<td></td><td>c0</td><td>c1 </td></tr>
<tr valign="bottom">
<td align="center"></td></tr>
<tr>
<td>r0</td><td>2</td><td>3 </td></tr>
<tr>
<td>r1</td><td>0</td><td>4 </td></tr>
</table>
<p>and do the following writes to the database:</p>
<div class="fragment"><pre class="fragment">insert into your_table values (<span class="stringliteral">&#39;r0&#39;</span>, <span class="stringliteral">&#39;c0&#39;</span>, 2);
insert into your_table values (<span class="stringliteral">&#39;r0&#39;</span>, <span class="stringliteral">&#39;c1&#39;</span>, 3);
insert into your_table values (<span class="stringliteral">&#39;r1&#39;</span>, <span class="stringliteral">&#39;c0&#39;</span>, 3);
insert into your_table values (<span class="stringliteral">&#39;r1&#39;</span>, <span class="stringliteral">&#39;c1&#39;</span>, 4);
</pre></div><ul>
<li>If your data set does not have names (or not enough names), I will use the scheme above, filling in names of the form <code>r0</code>, <code>r1</code>, ... <code>c0</code>, <code>c1</code>, .... Text columns get their own numbering system, <code>t0</code>, <code>t1</code>, ..., which is a little more robust than continuing the column count from the matrix.</li>
</ul>
<ul>
<li>I handle only the matrix and text. </li>
</ul>

</div>
</div>
<a class="anchor" id="a44b767b375fb18f61f939c6869955331"></a><!-- doxytag: member="apop.h::apop_data_add_named_elmt" ref="a44b767b375fb18f61f939c6869955331" args="(apop_data *d, char *name, double val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="apop__data_8c.html#a44b767b375fb18f61f939c6869955331">apop_data_add_named_elmt</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>A convenience function to add a named element to a data set. Many of Apophenia's testing procedures use this to easily produce a column of named parameters. It is public as a convenience.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>The <a class="el" href="gentle.html#apop_data">apop_data</a> structure. Must not be <code>NULL</code>, but may be blank (as per allocation via <a class="el" href="apop__data_8c.html#ac39d6a56933b6f084328ec5ecd5090d8">apop_data_alloc</a> <code>( )</code> ). </td></tr>
    <tr><td class="paramname">name</td><td>The name to add </td></tr>
    <tr><td class="paramname">val</td><td>the value to add to the set.</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>I use the position of the last non-empty row name to know where to put the value. If there are two names in the data set, then I will put the new name in the third name slot and the data in the third slot in the vector. If you use this function from start to finish in building your list, then you'll be fine. </li>
<li>If the vector is too short (or <code>NULL</code>), I will call <a class="el" href="apop__data_8c.html#af4658a3ecc0acfd17f610bc162fa5556">apop_vector_realloc</a> internally to make space. </li>
<li>This fits well with the defaults for <a class="el" href="group__data__set__get.html#ga06107779e4a3eb229715ceca24352b89">apop_data_get</a>. An example:</li>
</ul>
<div class="fragment"><pre class="fragment"><a class="code" href="structapop__data.html">apop_data</a> *list = <a class="code" href="apop_8h.html#ac39d6a56933b6f084328ec5ecd5090d8">apop_data_alloc</a>();
<a class="code" href="apop_8h.html#a44b767b375fb18f61f939c6869955331">apop_data_add_named_elmt</a>(list, <span class="stringliteral">&quot;height&quot;</span>, 165);
<a class="code" href="apop_8h.html#a44b767b375fb18f61f939c6869955331">apop_data_add_named_elmt</a>(list, <span class="stringliteral">&quot;weight&quot;</span>, 60);

<span class="keywordtype">double</span> height = <a class="code" href="group__data__set__get.html#ga06107779e4a3eb229715ceca24352b89">apop_data_get</a>(list, .rowname=<span class="stringliteral">&quot;height&quot;</span>);
</pre></div> 
</div>
</div>
<a class="anchor" id="a7e7e530a692571a403e5837fda5e0f12"></a><!-- doxytag: member="apop.h::apop_data_add_page" ref="a7e7e530a692571a403e5837fda5e0f12" args="(apop_data *dataset, apop_data *newpage, const char *title)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__data.html">apop_data</a>* <a class="el" href="apop__data_8c.html#a7e7e530a692571a403e5837fda5e0f12">apop_data_add_page</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>dataset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>newpage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>title</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Add a page to a <a class="el" href="gentle.html#apop_data">apop_data</a> set. It gets a name so you can find it later.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">dataset</td><td>The input data set, to which a page will be added. </td></tr>
    <tr><td class="paramname">newpage</td><td>The page to append </td></tr>
    <tr><td class="paramname">title</td><td>The name of the new page. Remember, this is truncated at 100 characters.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The new page. I post a warning if I am appending or appending to a <code>NULL</code> data set and <code>apop_opts.verbose &gt;=1 </code>.</dd></dl>
<ul>
<li>Some data is fundamentally multi-page; an optimization search over multi-page parameters would search the space given by all pages, for example. Also, pages may be appended as output or auxiliary information, such as covariances---an MLE would not search over these elements. Generally, any page with a name in XML-ish brackets, such as <code>&lt;Covariance&gt;</code>, will be considered informational and ignored by search routines, missing data routines, et cetera. This is achieved by a rule in <a class="el" href="group__conversions.html#ga7e31798ab418cbfc7488eaba27dad2af">apop_data_pack</a> and <a class="el" href="group__conversions.html#gae3058b7f39d0442f13284464d1ba235d">apop_data_unpack</a>.</li>
</ul>
<p>Here is a toy example that establishes a baseline data set, adds a page, modifies it, and then later retrieves it. </p>
<div class="fragment"><pre class="fragment">  <a class="code" href="structapop__data.html">apop_data</a> *d = <a class="code" href="apop_8h.html#ac39d6a56933b6f084328ec5ecd5090d8">apop_data_alloc</a>(10, 10, 10); <span class="comment">//the base data set.</span>
  <a class="code" href="structapop__data.html">apop_data</a> *a_new_page = <a class="code" href="apop_8h.html#a7e7e530a692571a403e5837fda5e0f12">apop_data_add_page</a>(d, <a class="code" href="apop_8h.html#ac39d6a56933b6f084328ec5ecd5090d8">apop_data_alloc</a>(2,2), <span class="stringliteral">&quot;new 2 x 2 page&quot;</span>);
  gsl_vector_set_all(a_new_page-&gt;matrix, 3);

  <span class="comment">//later:</span>
  <a class="code" href="structapop__data.html">apop_data</a> *retrieved = <a class="code" href="apop_8h.html#a044771db76f0afb410a8d4f05ac51ca3">apop_data_get_page</a>(d, <span class="stringliteral">&quot;new&quot;</span>, <span class="charliteral">&#39;r&#39;</span>); <span class="comment">//use regexes, not literal match.</span>
  <a class="code" href="group__output.html#ga9a30c437ec11a11e37e0db7f82386275">apop_data_show</a>(retrieved); <span class="comment">//print a 2x2 grid of 3s.</span>
</pre></div> 
</div>
</div>
<a class="anchor" id="ac39d6a56933b6f084328ec5ecd5090d8"></a><!-- doxytag: member="apop.h::apop_data_alloc" ref="ac39d6a56933b6f084328ec5ecd5090d8" args="(const size_t size1, const size_t size2, const int size3)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__data.html">apop_data</a>* <a class="el" href="apop__data_8c.html#ac39d6a56933b6f084328ec5ecd5090d8">apop_data_alloc</a> </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>size1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>size2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>size3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Allocate a <a class="el" href="gentle.html#apop_data">apop_data</a> structure, to be filled with data.</p>
<ul>
<li>The typical case is three arguments, like <code>apop_data_alloc(2,3,4)</code>: vector size, matrix rows, matrix cols. If the first argument is zero, you get a <code>NULL</code> vector. </li>
<li>Two arguments, <code>apop_data_alloc(2,3)</code>, would allocate just a matrix, leaving the vector <code>NULL</code>. </li>
<li>One argument, <code>apop_data_alloc(2)</code>, would allocate just a vector, leaving the matrix <code>NULL</code>. </li>
<li>Zero arguments, <code><a class="el" href="apop_8h.html#ac39d6a56933b6f084328ec5ecd5090d8">apop_data_alloc()</a></code>, will produce a basically blank set, with <code>out-&gt;matrix==out-&gt;vector==NULL</code>.</li>
</ul>
<p>For allocating the text part, see <a class="el" href="apop__data_8c.html#a9fba0f07c262a433133f6f3362617da3">apop_text_alloc</a>.</p>
<p>The <code>weights</code> vector is set to <code>NULL</code>. If you need it, allocate it via </p>
<div class="fragment"><pre class="fragment"> d-&gt;weights   = gsl_vector_alloc(row_ct); 
</pre></div><dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="apop__data_8c.html#a0460790f2d21f03856ed4a212a4132ec">apop_data_calloc</a></dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The <a class="el" href="gentle.html#apop_data">apop_data</a> structure, allocated and ready. </dd></dl>
<dl class="exception"><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">out-&gt;error=='a'</td><td>Allocation error. The matrix, vector, or names couldn't be <code>malloc</code>ed, which probably means that you requested a very large data set.</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>An <a class="el" href="gentle.html#apop_data">apop_data</a> struct, by itself, is about 72 bytes. If I can't allocate that much memory, I return <code>NULL</code>. But if even this much fails, your computer may be on fire and you should go put it out.</li>
</ul>
<ul>
<li>This function uses the <a class="el" href="designated.html">Designated initializers</a> syntax for inputs. </li>
</ul>

</div>
</div>
<a class="anchor" id="a0460790f2d21f03856ed4a212a4132ec"></a><!-- doxytag: member="apop.h::apop_data_calloc" ref="a0460790f2d21f03856ed4a212a4132ec" args="(const size_t size1, const size_t size2, const int size3)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__data.html">apop_data</a>* <a class="el" href="apop__data_8c.html#a0460790f2d21f03856ed4a212a4132ec">apop_data_calloc</a> </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>size1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>size2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>size3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Allocate a <a class="el" href="gentle.html#apop_data">apop_data</a> structure, to be filled with data; set everything in the allocated portion to zero. See <a class="el" href="apop__data_8c.html#ac39d6a56933b6f084328ec5ecd5090d8">apop_data_alloc</a> for details.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The <a class="el" href="gentle.html#apop_data">apop_data</a> structure, allocated and zeroed out. </dd></dl>
<dl class="exception"><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">out-&gt;error=='m'</td><td>malloc error; probably out of memory. </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="apop__data_8c.html#ac39d6a56933b6f084328ec5ecd5090d8">apop_data_alloc</a></dd></dl>
<ul>
<li>This function uses the <a class="el" href="designated.html">Designated initializers</a> syntax for inputs. </li>
</ul>

</div>
</div>
<a class="anchor" id="add67e6838ce2521a1d756894dc9b5ccf"></a><!-- doxytag: member="apop.h::apop_data_copy" ref="add67e6838ce2521a1d756894dc9b5ccf" args="(const apop_data *in)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__data.html">apop_data</a>* <a class="el" href="apop__data_8c.html#add67e6838ce2521a1d756894dc9b5ccf">apop_data_copy</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Copy one <a class="el" href="gentle.html#apop_data">apop_data</a> structure to another. That is, all data is duplicated.</p>
<p>Basically a front-end for <a class="el" href="apop__data_8c.html#aa24d396c7fda38bc4ab03a3ba2db4943">apop_data_memcpy</a> for those who prefer this sort of syntax.</p>
<p>Unlike <a class="el" href="apop__data_8c.html#aa24d396c7fda38bc4ab03a3ba2db4943">apop_data_memcpy</a>, I do follow the <code>more</code> pointer.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>the input data </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a structure that this function will allocate and fill. If input is NULL, then this will be NULL.</dd></dl>
<dl class="exception"><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">out.error='a'</td><td>Allocation error. </td></tr>
    <tr><td class="paramname">out.error='c'</td><td>Cyclic link: <code>D-&gt;more == D</code> (may be later in the chain, e.g., <code>D-&gt;more-&gt;more = D-&gt;more</code>) You'll have only a partial copy. </td></tr>
    <tr><td class="paramname">out.error='d'</td><td>Dimension error; should never happen. </td></tr>
    <tr><td class="paramname">out.error='p'</td><td>Missing part error; should never happen. <ul>
<li>If the input data set has an error, then I will copy it anyway, including the error flag (which might be overwritten). I print a warning if the verbosity level is <code>&gt;=1</code>. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afa3ab967f57f8ad3cfb99a4a82cfae02"></a><!-- doxytag: member="apop.h::apop_data_correlation" ref="afa3ab967f57f8ad3cfb99a4a82cfae02" args="(const apop_data *in)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__data.html">apop_data</a>* <a class="el" href="apop__stats_8c.html#afa3ab967f57f8ad3cfb99a4a82cfae02">apop_data_correlation</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the matrix of correlation coefficients <img class="formulaInl" alt="$(\sigma^2_{xy}/(\sigma_x\sigma_y))$" src="form_75.png"/> relating each column with each other.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>A data matrix: rows are observations, columns are variables. If you give me a weights vector, I'll use it.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns the variance/covariance matrix relating each column with each other. This function allocates the matrix for you. </dd></dl>
<dl class="exception"><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">out-&gt;error='a'</td><td>Allocation error. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aeae37a5bf11cddee59e272b083a4efc7"></a><!-- doxytag: member="apop.h::apop_data_covariance" ref="aeae37a5bf11cddee59e272b083a4efc7" args="(const apop_data *in)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__data.html">apop_data</a>* <a class="el" href="apop__stats_8c.html#aeae37a5bf11cddee59e272b083a4efc7">apop_data_covariance</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the sample variance/covariance matrix relating each column of the matrix to each other column.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>An <a class="el" href="gentle.html#apop_data">apop_data</a> set. If the weights vector is set, I'll take it into account.</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>This is the sample covariance---dividing by <img class="formulaInl" alt="$n-1$" src="form_56.png"/>, not <img class="formulaInl" alt="$n$" src="form_10.png"/>.</li>
</ul>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns a <a class="el" href="gentle.html#apop_data">apop_data</a> set the variance/covariance matrix relating each column with each other. </dd></dl>
<dl class="exception"><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">out-&gt;error='a'</td><td>Allocation error. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3e8377359d46c9bd02ea57205e7968d3"></a><!-- doxytag: member="apop.h::apop_data_free_base" ref="a3e8377359d46c9bd02ea57205e7968d3" args="(apop_data *freeme)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char <a class="el" href="apop__data_8c.html#a3e8377359d46c9bd02ea57205e7968d3">apop_data_free_base</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>freeme</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Free the elements of the given <a class="el" href="gentle.html#apop_data">apop_data</a> set and then the <a class="el" href="gentle.html#apop_data">apop_data</a> set itself. Intended to be used by <a class="el" href="apop_8h.html#a459acfde11f2c39f5c32cff377f85b9e">apop_data_free</a>, a macro that calls this to free elements, then sets the value to <code>NULL</code>.</p>
<ul>
<li><a class="el" href="apop_8h.html#a459acfde11f2c39f5c32cff377f85b9e">apop_data_free</a> is a macro that calls this function and, on success, sets the input pointer to <code>NULL</code>. For typical cases, that's slightly more useful than this function.</li>
</ul>
<dl class="exception"><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">freeme.error='c'</td><td>Circular linking is against the rules. If <code>freeme-&gt;more == freeme</code>, then I set <code>freeme.error='c'</code> and return. If you send in a structure like A -&gt; B -&gt; B, then both data sets A and B will be marked.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>0</code> on OK, <code>'c'</code> on error. </dd></dl>

</div>
</div>
<a class="anchor" id="adec9170cf1382f6cd549a5819472eb51"></a><!-- doxytag: member="apop.h::apop_data_get_factor_names" ref="adec9170cf1382f6cd549a5819472eb51" args="(apop_data *data, int col, char type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__data.html">apop_data</a>* <a class="el" href="apop__regression_8c.html#adec9170cf1382f6cd549a5819472eb51">apop_data_get_factor_names</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Factor names are stored in an auxiliary table with a name like <code>"&lt;categories for your_var&gt;"</code>. Producing this name is annoying (and prevents us from eventually making it human-language independent), so use this function to get the list of factor names.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The data set. (No default, must not be <code>NULL</code>) </td></tr>
    <tr><td class="paramname">col</td><td>The column in the main data set whose name I'll use to check for the factor name list. Vector==-1. (default=0) </td></tr>
    <tr><td class="paramname">type</td><td>If you are referring to a text column, use 't'. (default='d')</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A pointer to the page in the data set with the given factor names.</dd></dl>
<ul>
<li>This function uses the <a class="el" href="designated.html">Designated initializers</a> syntax for inputs. </li>
</ul>

</div>
</div>
<a class="anchor" id="a044771db76f0afb410a8d4f05ac51ca3"></a><!-- doxytag: member="apop.h::apop_data_get_page" ref="a044771db76f0afb410a8d4f05ac51ca3" args="(const apop_data *data, const char *title, const char match)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__data.html">apop_data</a>* <a class="el" href="apop__data_8c.html#a044771db76f0afb410a8d4f05ac51ca3">apop_data_get_page</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>title</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>match</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>It's good form to get a page from your data set by name, because you may not know the order for the pages, and the stepping through makes for dull code anyway (<code><a class="el" href="structapop__data.html">apop_data</a> *page = dataset; while (page-&gt;more) page= page-&gt;more;</code>).</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The <a class="el" href="gentle.html#apop_data">apop_data</a> set to use. No default; if <code>NULL</code>, gives a warning if <code>apop_opts.verbose &gt;=1</code> and returns <code>NULL</code>.</td></tr>
    <tr><td class="paramname">title</td><td>The name of the page to retrieve. Default=<code>"Info"</code>, which is the name of the page of additional estimation information returned by estimation routines (log likelihood, status, AIC, BIC, confidence intervals, ...).</td></tr>
    <tr><td class="paramname">match</td><td>If <code>'c'</code>, case-insensitive match (via <code>strcasecmp</code>); if <code>'e'</code>, exact match, if <code>'r'</code> regular expression substring search (via <a class="el" href="apop__asst_8c.html#aa9ec5e7ed223c09bec044ced54f24fad">apop_regex</a>). Default=<code>'c'</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The page whose title matches what you gave me. If I don't find a match, return <code>NULL</code>.</dd></dl>
<ul>
<li>This function uses the <a class="el" href="designated.html">Designated initializers</a> syntax for inputs. </li>
</ul>

</div>
</div>
<a class="anchor" id="a0316d98bbeb6ae13532a8c071019dbe6"></a><!-- doxytag: member="apop.h::apop_data_listwise_delete" ref="a0316d98bbeb6ae13532a8c071019dbe6" args="(apop_data *d, char inplace)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__data.html">apop_data</a>* <a class="el" href="apop__missing__data_8c.html#a0316d98bbeb6ae13532a8c071019dbe6">apop_data_listwise_delete</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>inplace</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>If there is an NaN anywhere in the row of data (including the matrix, the vector, the weights, and the text) then delete the row from the data set.</p>
<ul>
<li>If every row has an NaN, then this returns <code>NULL</code>. </li>
<li>If <code>apop_opts.nan_string</code> is not <code>NULL</code>, then I will make case-insensitive comparisons to the text elements to check for bad data as well. </li>
<li>If <code>inplace</code> = 'y', then I'll free each element of the input data set and refill it with the pruned elements. I'll still take up (up to) twice the size of the data set in memory during the function. If every row has an NaN, then your <code><a class="el" href="structapop__data.html">apop_data</a></code> set will end up with <code>NULL</code> vector, matrix, .... if <code>inplace</code> = 'n', then the original data set is left unmolested. </li>
<li>I only look at the first page of data (i.e. the <code>more</code> element is ignored). </li>
<li>This function uses the <a class="el" href="designated.html">Designated initializers</a> syntax for inputs.</li>
</ul>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>The data, with NaNs </td></tr>
    <tr><td class="paramname">inplace</td><td>If <code>'y'</code>, clear out the pointer-to-<a class="el" href="gentle.html#apop_data">apop_data</a> that you sent in and refill with the pruned data. If <code>'n'</code>, leave the set alone and return a new data set. Default=<code>'n'</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A (potentially shorter) copy of the data set, without NaNs. If <code>inplace=='y'</code>, a pointer to the input, which was shortened in place. If the entire data set is cleared out, then this will be <code>NULL</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="aa24d396c7fda38bc4ab03a3ba2db4943"></a><!-- doxytag: member="apop.h::apop_data_memcpy" ref="aa24d396c7fda38bc4ab03a3ba2db4943" args="(apop_data *out, const apop_data *in)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="apop__data_8c.html#aa24d396c7fda38bc4ab03a3ba2db4943">apop_data_memcpy</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>in</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Copy one <a class="el" href="gentle.html#apop_data">apop_data</a> structure to another. That is, all data on the first page is duplicated. [To do multiple pages, call this via a <code>for</code> loop over the data set's pages.]</p>
<p>This function does not allocate the output structure or the vector, matrix, text, or weights elements---I assume you have already done this and got the dimensions right. I will assert that there is at least enough room in the destination for your data, and fail if the copy would write more elements than there are bins.</p>
<ul>
<li>If you want space allocated, use <a class="el" href="apop__data_8c.html#add67e6838ce2521a1d756894dc9b5ccf">apop_data_copy</a>. </li>
<li>I don't follow the <code>more</code> pointer, though <a class="el" href="apop__data_8c.html#add67e6838ce2521a1d756894dc9b5ccf">apop_data_copy</a> does. </li>
<li>You can use the subsetting macros, <a class="el" href="apop_8h.html#af9032e16affac10d90dd3565e709966d">Apop_row</a> or <a class="el" href="apop_8h.html#aad1642d90f82ef1f5870a2de4e807005">Apop_rows</a>, to copy within a data set:</li>
</ul>
<div class="fragment"><pre class="fragment"><span class="comment">//Copy the contents of row i of mydata to row j.</span>
<a class="code" href="apop_8h.html#af9032e16affac10d90dd3565e709966d">Apop_row</a>(mydata, i, fromrow);
<a class="code" href="apop_8h.html#af9032e16affac10d90dd3565e709966d">Apop_row</a>(mydata, j, torow);
<a class="code" href="apop_8h.html#aa24d396c7fda38bc4ab03a3ba2db4943">apop_data_memcpy</a>(torow, fromrow);
</pre></div><dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>a structure that this function will fill. Must be preallocated with the appropriate sizes. </td></tr>
    <tr><td class="paramname">in</td><td>the input data</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">out.error='d'</td><td>Dimension error; couldn't copy. </td></tr>
    <tr><td class="paramname">out.error='p'</td><td>Part missing; e.g., in-&gt;matrix exists but out-&gt;matrix doesn't; couldn't copy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acc90578a8086a2e6f7b1575300260f08"></a><!-- doxytag: member="apop.h::apop_data_pmf_compress" ref="acc90578a8086a2e6f7b1575300260f08" args="(apop_data *in)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__data.html">apop_data</a>* <a class="el" href="apop_8h.html#acc90578a8086a2e6f7b1575300260f08">apop_data_pmf_compress</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Say that you have added a long list of observations to a single <a class="el" href="gentle.html#apop_data">apop_data</a> set, meaning that each row has weight one. There are a huge number of duplicates, perhaps because there are a handful of types that keep repeating:</p>
<table  frame="box">
<tr>
<td>Vector value</td><td>Text name</td><td>Weights </td></tr>
<tr valign="bottom">
<td align="center"></td></tr>
<tr>
<td>12</td><td>Dozen</td><td>1 </td></tr>
<tr>
<td>1</td><td>Single</td><td>1 </td></tr>
<tr>
<td>2</td><td>Pair</td><td>1 </td></tr>
<tr>
<td>2</td><td>Pair</td><td>1 </td></tr>
<tr>
<td>1</td><td>Single</td><td>1 </td></tr>
<tr>
<td>1</td><td>Single</td><td>1 </td></tr>
<tr>
<td>2</td><td>Pair</td><td>1 </td></tr>
<tr>
<td>2</td><td>Pair</td><td>1 </td></tr>
</table>
<p>You would like to reduce this to a set of distinct values, with their weights adjusted accordingly:</p>
<table  frame="box">
<tr>
<td>Vector value</td><td>Text name</td><td>Weights </td></tr>
<tr valign="bottom">
<td align="center"></td></tr>
<tr>
<td>12</td><td>Dozen</td><td>1 </td></tr>
<tr>
<td>1</td><td>Single</td><td>3 </td></tr>
<tr>
<td>2</td><td>Pair</td><td>4 </td></tr>
</table>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>An <a class="el" href="gentle.html#apop_data">apop_data</a> set that may have duplicate rows. As above, the data may be in text and/or numeric formats. If there is a <code>weights</code> vector, I will add those weights together as duplicates are merged. If there is no <code>weights</code> vector, I will create one, which is initially set to one for all values, and then aggregated as above.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Your input is changed in place, via <a class="el" href="apop__data_8c.html#ad6b6774d5ec4b12f0023e3afff7ccb65">apop_data_rm_rows</a>, so use <a class="el" href="apop__data_8c.html#add67e6838ce2521a1d756894dc9b5ccf">apop_data_copy</a> before calling this function if you need to retain the original format. For your convenience, this function returns a pointer to your original data, which has now been pruned. </dd></dl>

</div>
</div>
<a class="anchor" id="ad1efbe058d6ca85ece023eb471c66e58"></a><!-- doxytag: member="apop.h::apop_data_prune_columns_base" ref="ad1efbe058d6ca85ece023eb471c66e58" args="(apop_data *d, char **colnames)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__data.html">apop_data</a>* <a class="el" href="apop__data_8c.html#ad1efbe058d6ca85ece023eb471c66e58">apop_data_prune_columns_base</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>colnames</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Keep only the columns of a data set that you name. This is the function called internally by the <a class="el" href="apop_8h.html#a5ea849ee3c044e95eafb7b79124ce844">apop_data_prune_columns</a> macro. In most cases, you'll want to use that macro. An example of the two uses demonstrating the difference:</p>
<div class="fragment"><pre class="fragment">    <a class="code" href="apop_8h.html#a5ea849ee3c044e95eafb7b79124ce844">apop_data_prune_columns</a>(d, <span class="stringliteral">&quot;mean&quot;</span>, <span class="stringliteral">&quot;median&quot;</span>);

    <span class="keywordtype">char</span> *list[] = {<span class="stringliteral">&quot;mean&quot;</span>, <span class="stringliteral">&quot;median&quot;</span>, NULL};
    <a class="code" href="apop_8h.html#ad1efbe058d6ca85ece023eb471c66e58">apop_data_prune_columns_base</a>(d, list);
</pre></div><dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>The data set to prune. </td></tr>
    <tr><td class="paramname">colnames</td><td>A null-terminated list of names to retain (i.e. the columns that shouldn't be pruned out). </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A pointer to the input data set, now pruned. </dd></dl>

</div>
</div>
<a class="anchor" id="a8c4bb25171301f09a35c36306a7b9783"></a><!-- doxytag: member="apop.h::apop_data_rank_compress" ref="a8c4bb25171301f09a35c36306a7b9783" args="(apop_data *in)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__data.html">apop_data</a>* <a class="el" href="apop__conversions_8c.html#a8c4bb25171301f09a35c36306a7b9783">apop_data_rank_compress</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>One often finds data where the column indicates the value of the data point. There may be two columns, and a mark in the first indicates a miss while a mark in the second is a hit. Or say that we have the following list of observations:</p>
<div class="fragment"><pre class="fragment">2 3 3 2 1 1 2 1 1 2 1 1
</pre></div><p> Then we could write this as: </p>
<div class="fragment"><pre class="fragment">0  1  2  3
----------
0  6  4  2
</pre></div><p> because there are six 1s observed, four 2s observed, and two 3s observed. We call this rank format, because 1 (or zero) is typically the most common, 2 is second most common, et cetera.</p>
<p>This function takes in a list of observations, and aggregates them into a single row in rank format.</p>
<ul>
<li>For the complement, see <a class="el" href="apop__conversions_8c.html#a2feb17743f8b07b8ddcf457362cabefc">apop_data_rank_expand</a>.</li>
</ul>
<ul>
<li>You may be interested in <a class="el" href="apop__regression_8c.html#a27405bd5fdf48d93c8918ca4c07ee260">apop_data_to_factors</a> to convert real numbers or text into a matrix of categories.</li>
</ul>
<ul>
<li>The number of bins is simply the largest number found. So if there are bins {0, 1, 2} and your data set happens to consist of <code>0 0 1 1 0</code>, then I won't know to generate results with three bins where the last bin has probability zero.</li>
</ul>
<div class="fragment"><pre class="fragment"><span class="comment">/* A round trip: generate Zipf-distributed draws, summarize them to a single list of</span>
<span class="comment">rankings, then expand the rankings to a list of single entries. The sorted list at the end</span>
<span class="comment">of this should be identical to the (sorted) original list. */</span>
<span class="preprocessor">#include &lt;<a class="code" href="apop_8h.html">apop.h</a>&gt;</span>

<span class="keywordtype">int</span> main(){
    gsl_rng *r = <a class="code" href="group__convenience__fns.html#gada044cf02135422a9f9292b6054c86dd">apop_rng_alloc</a>(2342);
    <span class="keywordtype">int</span> i, length = 1e4;
    <a class="code" href="structapop__model.html">apop_model</a> *a_zipf = <a class="code" href="group__models.html#ga36cae46a2950eb6cfb65794cdd5dac7e">apop_model_set_parameters</a>(<a class="code" href="group__models.html#ga32e7ca1164025cbb53a9e0ecee9d4cea">apop_zipf</a>, 3.2);
    <a class="code" href="structapop__data.html">apop_data</a> *draws = <a class="code" href="apop_8h.html#ac39d6a56933b6f084328ec5ecd5090d8">apop_data_alloc</a>(length);
    <span class="keywordflow">for</span> (i=0; i&lt; length; i++)
        <a class="code" href="group__models.html#ga87f15cd1923ed7b5b46e52a77ca1dfef">apop_draw</a>(<a class="code" href="group__data__set__get.html#ga59d1c0299c7eb87224bc6c60555784fe">apop_data_ptr</a>(draws, i, -1), r, a_zipf);
    <a class="code" href="structapop__data.html">apop_data</a> *by_rankings = <a class="code" href="apop_8h.html#a8c4bb25171301f09a35c36306a7b9783">apop_data_rank_compress</a>(draws);
    <span class="comment">//The first row of the matrix is suitable for plotting.</span>
    <span class="comment">//apop_data_show(by_rankings);</span>
    assert(<a class="code" href="group__convenience__fns.html#ga369c774aac917e56d8e32f9c66d9c2a0">apop_matrix_sum</a>(by_rankings-&gt;matrix) == length);

    <a class="code" href="structapop__data.html">apop_data</a> *re_expanded = <a class="code" href="apop_8h.html#a2feb17743f8b07b8ddcf457362cabefc">apop_data_rank_expand</a>(by_rankings);
    gsl_sort_vector(draws-&gt;vector);
    gsl_sort_vector(re_expanded-&gt;vector);
    assert(<a class="code" href="group__convenience__fns.html#ga44a77f5e6867c627fd313f3f6e252ff8">apop_vector_distance</a>(draws-&gt;vector, re_expanded-&gt;vector) &lt; 1e-5);
}
</pre></div> 
</div>
</div>
<a class="anchor" id="a2feb17743f8b07b8ddcf457362cabefc"></a><!-- doxytag: member="apop.h::apop_data_rank_expand" ref="a2feb17743f8b07b8ddcf457362cabefc" args="(apop_data *in)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__data.html">apop_data</a>* <a class="el" href="apop__conversions_8c.html#a2feb17743f8b07b8ddcf457362cabefc">apop_data_rank_expand</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The complement to this is <a class="el" href="apop__conversions_8c.html#a8c4bb25171301f09a35c36306a7b9783">apop_data_rank_compress</a>; see that function's documentation for the story and an example.</p>
<p>This function takes in a data set where the zeroth column includes the count(s) of times that zero was observed, the first gives the count(s) of times that one was observed, et cetera. It outputs a data set whose vector element includes a list that has exactly the given frequency of zeros, ones, et cetera. </p>

</div>
</div>
<a class="anchor" id="a1312f6568cfe832f1e35f7f44482ffb4"></a><!-- doxytag: member="apop.h::apop_data_rm_columns" ref="a1312f6568cfe832f1e35f7f44482ffb4" args="(apop_data *d, int *drop)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="apop__data_8c.html#a1312f6568cfe832f1e35f7f44482ffb4">apop_data_rm_columns</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>drop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Remove the columns set to one in the <code>drop</code> vector. The returned data structure looks like it was modified in place, but the data matrix and the names are duplicated before being pared down, so if your data is taking up more than half of your memory, this may not work.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>the <a class="el" href="gentle.html#apop_data">apop_data</a> structure to be pared down. </td></tr>
    <tr><td class="paramname">drop</td><td>an array of ints. If use[7]==1, then column seven will be cut from the output. A reminder: <code>calloc(in-&gt;size2 , sizeof(int))</code> will fill your array with zeros on allocation, and <code>memset(use, 1, in-&gt;size2 * sizeof(int))</code> will quickly fill an array of ints with nonzero values. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac434c9d08b6a8304107d9c93afb81914"></a><!-- doxytag: member="apop.h::apop_data_rm_page" ref="ac434c9d08b6a8304107d9c93afb81914" args="(apop_data *data, const char *title, const char free_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__data.html">apop_data</a>* <a class="el" href="apop__data_8c.html#ac434c9d08b6a8304107d9c93afb81914">apop_data_rm_page</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>title</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>free_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Remove the first page from an <a class="el" href="gentle.html#apop_data">apop_data</a> set that matches a given name.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The input data set, to which a page will be added. No default. If <code>NULL</code>, I return silently if <code> apop_opts.verbose &lt; 1 </code>; print an error otherwise. </td></tr>
    <tr><td class="paramname">title</td><td>The case-insensitive name of the page to remove. Default: <code>"Info"</code> </td></tr>
    <tr><td class="paramname">free_p</td><td>If <code>'y'</code>, then <a class="el" href="apop_8h.html#a459acfde11f2c39f5c32cff377f85b9e">apop_data_free</a> the page. Default: <code>'y'</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>If not freed, a pointer to the <code><a class="el" href="structapop__data.html">apop_data</a></code> page that I just pulled out. Thus, you can use this to pull a single page from a data set. I set that page's <code>more</code> pointer to <code>NULL</code>, to minimize any confusion about more-than-linear linked list topologies. If <code>free_p=='y'</code> (the default) or the page is not found, return <code>NULL</code>.</dd></dl>
<ul>
<li>I don't check the first page, so there's no concern that the head of your list of pages will move. Again, the intent of the <code>-&gt;more</code> pointer in the <a class="el" href="gentle.html#apop_data">apop_data</a> set is not to fully implement a linked list, but primarily to allow you to staple auxiliary information to a main data set.</li>
</ul>
<ul>
<li>If I don't find the page you want, I return NULL, and print a message if <code>apop_opts.verbose &gt;= 1</code>. </li>
</ul>

</div>
</div>
<a class="anchor" id="ae2ab3a4f332adb368fe970619a8c0252"></a><!-- doxytag: member="apop.h::apop_data_rm_rows" ref="ae2ab3a4f332adb368fe970619a8c0252" args="(apop_data *in, int *drop, int(*do_drop)(apop_data *, void *), void *drop_parameter)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__data.html">apop_data</a>* <a class="el" href="apop__data_8c.html#ad6b6774d5ec4b12f0023e3afff7ccb65">apop_data_rm_rows</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>drop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apop_fn_ir&#160;</td>
          <td class="paramname"><em>do_drop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drop_parameter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Remove the rows set to one in the <code>drop</code> vector or for which the <code>do_drop</code> function returns one. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>the <a class="el" href="gentle.html#apop_data">apop_data</a> structure to be pared down </td></tr>
    <tr><td class="paramname">drop</td><td>a vector with as many elements as the max of the vector, matrix, or text parts of <code>in</code>, with a one marking those columns to be removed. </td></tr>
    <tr><td class="paramname">do_drop</td><td>A function that returns one for rows to drop and zero for rows to not drop. A sample function: <div class="fragment"><pre class="fragment">  <span class="keywordtype">int</span> your_drop_function(<a class="code" href="structapop__data.html">apop_data</a> *onerow, <span class="keywordtype">void</span> *extra_param){
    <span class="keywordflow">return</span> gsl_isnan(<a class="code" href="group__data__set__get.html#ga06107779e4a3eb229715ceca24352b89">apop_data_get</a>(onerow)) || !strcmp(onerow-&gt;text[0][0], <span class="stringliteral">&quot;Uninteresting data point&quot;</span>);
  }
</pre></div> <a class="el" href="apop__data_8c.html#ad6b6774d5ec4b12f0023e3afff7ccb65">apop_data_rm_rows</a> uses <a class="el" href="apop_8h.html#af9032e16affac10d90dd3565e709966d">Apop_row</a> to get a subview of the input data set of height one (and since all the default arguments default to zero, you don't have to write out things like <a class="el" href="group__data__set__get.html#ga06107779e4a3eb229715ceca24352b89">apop_data_get</a> <code>(onerow, .row=0, .col=0)</code>, which can help to keep things readable). </td></tr>
    <tr><td class="paramname">drop_parameter</td><td>If your <code>do_drop</code> function requires additional input, put it here and it will be passed through.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns a pointer to the input data set, now pruned.</dd></dl>
<ul>
<li>If all the rows are to be removed, then you will wind up with the same <a class="el" href="gentle.html#apop_data">apop_data</a> set, with <code>NULL</code> <code>vector</code>, <code>matrix</code>, <code>weight</code>, and text. Therefore, you may wish to check for <code>NULL</code> elements after use. I remove rownames, but leave the other names, in case you want to add new data rows.</li>
</ul>
<ul>
<li>The typical use is to provide only a list or only a function. If both are <code>NULL</code>, I return without doing anything, and print a warning if <code>apop_opts.verbose &gt;=1</code>. If you provide both, I will drop the row if either the vector has a one in that row's position, or if the function returns a nonzero value. </li>
<li>This function uses the <a class="el" href="designated.html">Designated initializers</a> syntax for inputs. </li>
</ul>

</div>
</div>
<a class="anchor" id="a47313d1f22af539e43f5ff02dd0e8f90"></a><!-- doxytag: member="apop.h::apop_data_set_row" ref="a47313d1f22af539e43f5ff02dd0e8f90" args="(apop_data *row, apop_data *d, int row_number)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="apop__data_8c.html#a5acc9328f9c043be4cd6c12f57509df1">apop_data_set_row</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>row_number</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Now that you've used <a class="el" href="apop_8h.html#af9032e16affac10d90dd3565e709966d">Apop_row</a> to pull a row from an <a class="el" href="gentle.html#apop_data">apop_data</a> set, this function lets you write that row to another position in the same data set or a different data set entirely.</p>
<p>The set written to must have the same form as the original: </p>
<ul>
<li>a vector element has to be present if one existed in the original, </li>
<li>same for the weights vector, </li>
<li>the matrix in the destination has to have as many columns as in the original, and </li>
<li>the text has to have a row long enough to hold the original </li>
<li>If the row to be written to already has a rowname, it is overwritten. If <code>d-&gt;names-&gt;rowct == row_number</code> (all rows up to <code>row_number</code> have row names), then extend the list of row names by one to add the new name. Else, don't add the row name. </li>
<li>Column names (of all types) aren't touched. Maybe use <code>apop_data_copy</code> or <code>apop_name_copy</code> if you need to copy these names.</li>
</ul>
<p>If any of the source elements are <code>NULL</code>, I won't bother to check that element in the destination.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>0=OK, -1=error (probably a source/destination size mismatch).</dd></dl>
<ul>
<li>The error codes for out-of-bounds errors are thread-safe iff you are have a C11-compliant compiler (thanks to the <code>_Thread_local</code> keyword) or a version of GCC with the <code>__thread</code> extension enabled. </li>
</ul>

</div>
</div>
<a class="anchor" id="acefe4dee819c090e57ac69d4d8bdcfd0"></a><!-- doxytag: member="apop.h::apop_data_sort" ref="acefe4dee819c090e57ac69d4d8bdcfd0" args="(apop_data *data, apop_data *sort_order, char asc, char inplace, double *col_order)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__data.html">apop_data</a>* <a class="el" href="apop__sort_8c.html#acefe4dee819c090e57ac69d4d8bdcfd0">apop_data_sort</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>sort_order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>asc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>inplace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>col_order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sort an <a class="el" href="gentle.html#apop_data">apop_data</a> set on an arbitrary sequence of columns.</p>
<p>The <code>sort_order</code> set is a one-row data set that should look like the data set being sorted. The easiest way to generate it is to use <a class="el" href="apop_8h.html#af9032e16affac10d90dd3565e709966d">Apop_row</a> to pull one row of the table, then copy and fill it. For each column you want used in the sort, assign a ranking giving whether the column should be sorted first, second, .... Columns you don't want used in the sorting should be set to <code>NAN</code>. Ties are broken by the earlier element in the default order (see below).</p>
<p>E.g., to sort by the last column of a five-column matrix first, then the next-to-last column, then the next-to-next-to-last, then by the first text column, then by the second text column:</p>
<div class="fragment"><pre class="fragment"><a class="code" href="apop_8h.html#af9032e16affac10d90dd3565e709966d">Apop_row</a>(data, 0, so)
<a class="code" href="structapop__data.html">apop_data</a> *sort_order = <a class="code" href="apop_8h.html#add67e6838ce2521a1d756894dc9b5ccf">apop_data_copy</a>(so);
sort_order-&gt;vector = NULL; <span class="comment">//so it will be skipped.</span>
Apop_data_fill(sort_order, NAN, NAN, 3, 2, 1);
<a class="code" href="apop_8h.html#ac9c6f645acce82319fb85eb9d75112ba">apop_text_add</a>(sort_order, 0, 0, &quot;4&quot;);
<a class="code" href="apop_8h.html#ac9c6f645acce82319fb85eb9d75112ba">apop_text_add</a>(sort_order, 0, 1, &quot;5&quot;);
<a class="code" href="apop_8h.html#acefe4dee819c090e57ac69d4d8bdcfd0">apop_data_sort</a>(data, sort_order);
</pre></div><p>I use only comparisons, not the actual numeric values, so you can use any sequence of numbers: (1, 2, 3) and (-1.32, 0, 27) work identically.</p>
<ul>
<li>Strings are sorted case-insensitively, using <code>strcasecmp</code>. [exercise for the reader: modify the source to use Glib's locale-correct string sorting.]</li>
</ul>
<ul>
<li>The setup generates a lexicographic sort using the columns you specify. If you would like a different sort order, such as Euclidian distance to the origin, you can generate a new column expressing your preferred metric, and then sorting on that. See the example below.</li>
</ul>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The data set to be sorted. If <code>NULL</code>, this function is a no-op that returns <code>NULL</code>. </td></tr>
    <tr><td class="paramname">sort_order</td><td>A <a class="el" href="gentle.html#apop_data">apop_data</a> set describing the order in which columns are used for sorting, as above. If <code>NULL</code>, then sort by the vector, then each matrix column, then text, then weights, then row names. </td></tr>
    <tr><td class="paramname">inplace</td><td>If 'n', make a copy, else sort in place. (default: 'y'). </td></tr>
    <tr><td class="paramname">asc</td><td>If 'a', ascending; if 'd', descending. This is applied to all columns; column-by-column application is to do. (default: 'a'). </td></tr>
    <tr><td class="paramname">col_order</td><td>For internal use only. In your call, it should be <code>NULL</code>; the <a class="el" href="designated.html">Designated initializers</a> syntax will takes care of it for you.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A pointer to the sorted data set. If <code>inplace=='y'</code> (the default), then this is the same as the input set.</dd></dl>
<p>A few examples:</p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &lt;<a class="code" href="apop_8h.html">apop.h</a>&gt;</span>
<span class="preprocessor">#include &lt;unistd.h&gt;</span>
<span class="preprocessor">#ifdef Testing</span>
<span class="preprocessor"></span><span class="preprocessor">#include &quot;sort_tests.c&quot;</span> <span class="comment">//For Apophenia&#39;s test suite, some tedious checks that the sorts worked</span>
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>
<span class="preprocessor">#ifndef Datadir  //In the test suite, this is defined via Automake</span>
<span class="preprocessor"></span><span class="preprocessor">#define Datadir &quot;.&quot;</span>
<span class="preprocessor"></span><span class="preprocessor">#endif</span>
<span class="preprocessor"></span>
<span class="comment">//get_distance is for the sort-by-Euclidian distance example below.</span>
<span class="keywordtype">double</span> get_distance(gsl_vector *v) {<span class="keywordflow">return</span> <a class="code" href="group__convenience__fns.html#ga44a77f5e6867c627fd313f3f6e252ff8">apop_vector_distance</a>(v);}

<span class="keywordtype">int</span> main(){
    chdir(Datadir); <span class="comment">//Datadir is defined via autoconf.</span>
    <a class="code" href="group__conversions.html#gabd00e16791a970631c3ed4ac3487da46">apop_text_to_db</a>(<span class="stringliteral">&quot;amash_vote_analysis.csv&quot;</span>, .tabname=<span class="stringliteral">&quot;amash_vote_analysis&quot;</span>);
    <a class="code" href="structapop__data.html">apop_data</a> *d = <a class="code" href="group__queries.html#ga1f06db34e05b5afb63112f83ad2317b8">apop_query_to_mixed_data</a>(<span class="stringliteral">&quot;mntmtm&quot;</span>, <span class="stringliteral">&quot;select 1,id,party,contribs/1000.0,vote,ideology from amash_vote_analysis &quot;</span>);

    <span class="comment">//use the default order of columns for sorting</span>
    <a class="code" href="structapop__data.html">apop_data</a> *sorted = <a class="code" href="apop_8h.html#acefe4dee819c090e57ac69d4d8bdcfd0">apop_data_sort</a>(d, .inplace=<span class="charliteral">&#39;n&#39;</span>);
<span class="preprocessor">#ifndef Testing</span>
<span class="preprocessor"></span>    <a class="code" href="group__apop__print.html#gab45a848e5dbcaf82b5b95cd03f7b396a">apop_data_print</a>(sorted);
<span class="preprocessor">#else</span>
<span class="preprocessor"></span>    check_sorting1(sorted);
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>
    <span class="comment">//set up a specific column order</span>
    <a class="code" href="apop_8h.html#af9032e16affac10d90dd3565e709966d">Apop_row</a>(d, 0, onerow);
    <a class="code" href="structapop__data.html">apop_data</a> *perm = <a class="code" href="apop_8h.html#add67e6838ce2521a1d756894dc9b5ccf">apop_data_copy</a>(onerow);
    perm-&gt;vector = NULL;
    <a class="code" href="apop_8h.html#ad6be56d710a63aa1ceadf2242c553905">apop_data_fill</a>(perm, 5, 3, 4);
    <a class="code" href="apop_8h.html#ac9c6f645acce82319fb85eb9d75112ba">apop_text_add</a>(perm, 0, 0, <span class="stringliteral">&quot;2&quot;</span>);
    <a class="code" href="apop_8h.html#ac9c6f645acce82319fb85eb9d75112ba">apop_text_add</a>(perm, 0, 1, <span class="stringliteral">&quot;1&quot;</span>);

    <a class="code" href="apop_8h.html#acefe4dee819c090e57ac69d4d8bdcfd0">apop_data_sort</a>(d, perm);
<span class="preprocessor">#ifndef Testing</span>
<span class="preprocessor"></span>    <a class="code" href="group__apop__print.html#gab45a848e5dbcaf82b5b95cd03f7b396a">apop_data_print</a>(d);
<span class="preprocessor">#else</span>
<span class="preprocessor"></span>    check_sorting2(d);
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>
    <span class="comment">//sort a list of names</span>
    <a class="code" href="structapop__data.html">apop_data</a> *blank = <a class="code" href="apop_8h.html#ac39d6a56933b6f084328ec5ecd5090d8">apop_data_alloc</a>();
    <a class="code" href="apop_8h.html#aeca6159c82c21da0db82ae9ed0582dc6">apop_data_add_names</a>(blank, <span class="charliteral">&#39;r&#39;</span>, <span class="stringliteral">&quot;C&quot;</span>, <span class="stringliteral">&quot;E&quot;</span>, <span class="stringliteral">&quot;A&quot;</span>);
    <a class="code" href="apop_8h.html#acefe4dee819c090e57ac69d4d8bdcfd0">apop_data_sort</a>(blank);
    assert(*blank-&gt;names-&gt;row[0] == <span class="charliteral">&#39;A&#39;</span>);
    assert(*blank-&gt;names-&gt;row[1] == <span class="charliteral">&#39;C&#39;</span>);
    assert(*blank-&gt;names-&gt;row[2] == <span class="charliteral">&#39;E&#39;</span>);

    <span class="comment">//take each row of the matrix as a vector; store the Euclidian distance to the origin in the vector;</span>
    <span class="comment">//sort in descending order.</span>
    <a class="code" href="structapop__data.html">apop_data</a> *rowvectors = <a class="code" href="group__conversions.html#ga630de5d4fcbe9ef13373029f5d813a97">apop_text_to_data</a>(<span class="stringliteral">&quot;test_data&quot;</span>);
    <a class="code" href="group__mapply.html#gaacff3707e418a067104c77c410b43f69">apop_map</a>(rowvectors, .fn_v=get_distance, .part=<span class="charliteral">&#39;r&#39;</span>, .inplace=<span class="charliteral">&#39;y&#39;</span>);
    <a class="code" href="apop_8h.html#af9032e16affac10d90dd3565e709966d">Apop_row</a>(rowvectors, 0, arow);
    arow-&gt;matrix=NULL; <span class="comment">//sort only by the distance vector</span>
    <a class="code" href="apop_8h.html#acefe4dee819c090e57ac69d4d8bdcfd0">apop_data_sort</a>(rowvectors, arow, .asc=<span class="charliteral">&#39;d&#39;</span>);
<span class="preprocessor">#ifndef Testing</span>
<span class="preprocessor"></span>    <a class="code" href="group__output.html#ga9a30c437ec11a11e37e0db7f82386275">apop_data_show</a>(rowvectors);
<span class="preprocessor">#else</span>
<span class="preprocessor"></span>    <span class="keywordtype">double</span> prev = INFINITY;
    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt; rowvectors-&gt;vector-&gt;size; i++){
        <span class="keywordtype">double</span> <span class="keyword">this</span> = <a class="code" href="group__data__set__get.html#ga06107779e4a3eb229715ceca24352b89">apop_data_get</a>(rowvectors, i, -1);
        assert(<span class="keyword">this</span> &lt; prev);
        prev = <span class="keyword">this</span>;
    }
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>}
</pre></div><ul>
<li>This function uses the <a class="el" href="designated.html">Designated initializers</a> syntax for inputs. </li>
</ul>

</div>
</div>
<a class="anchor" id="aef0284036801cb75d465a1738f65397e"></a><!-- doxytag: member="apop.h::apop_data_split" ref="aef0284036801cb75d465a1738f65397e" args="(apop_data *in, int splitpoint, char r_or_c)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__data.html">apop_data</a>** <a class="el" href="apop__data_8c.html#aef0284036801cb75d465a1738f65397e">apop_data_split</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>splitpoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>r_or_c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Split one input <a class="el" href="gentle.html#apop_data">apop_data</a> structure into two.</p>
<p>For the opposite operation, see <a class="el" href="apop__data_8c.html#a0f2ffb5c5ba2bb240e930be08fc4fd56">apop_data_stack</a>.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>The <a class="el" href="gentle.html#apop_data">apop_data</a> structure to split </td></tr>
    <tr><td class="paramname">splitpoint</td><td>The index of what will be the first row/column of the second data set. E.g., if this is -1 and <code>r_or_c=='c'</code>, then the whole data set will be in the second data set; if this is the length of the matrix then the whole data set will be in the first data set. Another way to put it is that <code>splitpoint</code> will equal the number of rows/columns in the first matrix (unless it is -1, in which case the first matrix will have zero rows, or it is greater than the matrix's size, in which case it will have as many rows as the original). </td></tr>
    <tr><td class="paramname">r_or_c</td><td>If this is 'r' or 'R', then put some rows in the first data set and some in the second; of 'c' or 'C', split columns into first and second data sets.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>An array of two <a class="el" href="gentle.html#apop_data">apop_data</a> sets. If one is empty then a <code>NULL</code> pointer will be returned in that position. For example, for a data set of 50 rows, <code><a class="el" href="structapop__data.html">apop_data</a> **out = apop_data_split(data, 100, 'r')</code> sets <code>out[0] = apop_data_copy(data)</code> and <code>out[1] = NULL</code>.</dd></dl>
<ul>
<li>When splitting at a row, the text is also split. </li>
<li><code>more</code> pointer is ignored. </li>
<li>The <code>apop_data-&gt;vector</code> is taken to be the -1st element of the matrix. </li>
<li>Weights will be preserved. If splitting by rows, then the top and bottom parts of the weights vector will be assigned to the top and bottom parts of the main data set. If splitting by columns, identical copies of the weights vector will be assigned to both parts. </li>
<li>Data is copied, so you may want to call <code><a class="el" href="apop_8h.html#a459acfde11f2c39f5c32cff377f85b9e">apop_data_free(in)</a></code> after this. </li>
</ul>

</div>
</div>
<a class="anchor" id="a0f2ffb5c5ba2bb240e930be08fc4fd56"></a><!-- doxytag: member="apop.h::apop_data_stack" ref="a0f2ffb5c5ba2bb240e930be08fc4fd56" args="(apop_data *m1, apop_data *m2, char posn, char inplace)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__data.html">apop_data</a>* <a class="el" href="apop__data_8c.html#a0f2ffb5c5ba2bb240e930be08fc4fd56">apop_data_stack</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>m2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>posn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>inplace</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Put the first data set either on top of or to the left of the second data set.</p>
<p>The fn returns a new data set, meaning that at the end of this function, until you <a class="el" href="apop_8h.html#a459acfde11f2c39f5c32cff377f85b9e">apop_data_free()</a> the original data sets, you will be taking up twice as much memory. Plan accordingly.</p>
<p>For the opposite operation, see <a class="el" href="apop__data_8c.html#aef0284036801cb75d465a1738f65397e">apop_data_split</a>.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">m1</td><td>the upper/rightmost data set (default = <code>NULL</code>) </td></tr>
    <tr><td class="paramname">m2</td><td>the second data set (default = <code>NULL</code>) </td></tr>
    <tr><td class="paramname">posn</td><td>If 'r', stack rows of m1's matrix above rows of m2's<br/>
 if 'c', stack columns of m1's matrix to left of m2's<br/>
 (default = 'r') </td></tr>
    <tr><td class="paramname">inplace</td><td>If <code>'y'</code>, use <a class="el" href="apop__data_8c.html#aa06b6ab6ec9f78f305b1dacc8ec2efd3">apop_matrix_realloc</a> and <a class="el" href="apop__data_8c.html#af4658a3ecc0acfd17f610bc162fa5556">apop_vector_realloc</a> to modify <code>m1</code> in place; see the caveats on those function. Otherwise, allocate a new vector, leaving <code>m1</code> unmolested. (default='n') </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The stacked data, either in a new <a class="el" href="gentle.html#apop_data">apop_data</a> set or <code>m1</code> </dd></dl>
<dl class="exception"><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">out-&gt;error=='a'</td><td>Allocation error. </td></tr>
    <tr><td class="paramname">out-&gt;error=='d'</td><td>Dimension error; couldn't make a complete copy.</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>If m1 or m2 are NULL, this returns a copy of the other element, and if both are NULL, you get NULL back (except if <code>m2</code> is <code>NULL</code> and <code>inplace</code> is <code>'y'</code>, where you'll get the original <code>m1</code> pointer back) </li>
<li>Text is handled as you'd expect: If 'r', one set of text is stacked on top of the other [number of columns must match]; if 'c', one set of text is set next to the other [number of rows must match]. </li>
<li><code>more</code> is ignored. </li>
<li>If stacking rows on rows, the output vector is the input vectors stacked accordingly. If stacking columns by columns, the output vector is just a copy of the vector of m1 and m2-&gt;vector doesn't appear in the output at all. </li>
<li>The same rules for dealing with the vector(s) hold for the vector(s) of weights. </li>
<li>Names are a copy of the names for <code>m1</code>, with the names for <code>m2</code> appended to the row or column list, as appropriate. </li>
<li>This function uses the <a class="el" href="designated.html">Designated initializers</a> syntax for inputs. </li>
</ul>

</div>
</div>
<a class="anchor" id="a02cef4243593cf905fa54cb48d8b04c2"></a><!-- doxytag: member="apop.h::apop_data_to_bins" ref="a02cef4243593cf905fa54cb48d8b04c2" args="(apop_data *indata, apop_data *binspec, int bin_count, char close_top_bin)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__data.html">apop_data</a>* <a class="el" href="apop__hist_8c.html#a02cef4243593cf905fa54cb48d8b04c2">apop_data_to_bins</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>indata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>binspec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bin_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>close_top_bin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a histogram from data by putting data into bins of fixed width.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">indata</td><td>The input data that will be binned. This is copied and the copy will be modified. </td></tr>
    <tr><td class="paramname">close_top_bin</td><td>Normally, a bin covers the range from the point equal to its minimum to points strictly less than the minimum plus the width. if <code>'y'</code>, then the top bin includes points less than or equal to the upper bound. This solves the problem of displaying histograms where the top bin is just one point. </td></tr>
    <tr><td class="paramname">binspec</td><td>This is an <a class="el" href="gentle.html#apop_data">apop_data</a> set with the same number of columns as <code>indata</code>. If you want a fixed size for the bins, then the first row of the bin spec is the bin width for each column. This allows you to specify a width for each dimension, or specify the same size for all with something like:</td></tr>
    <tr><td class="paramname">bin_count</td><td>If you don't provide a bin spec, I'll provide this many evenly-sized bins. Default: <img class="formulaInl" alt="$\sqrt(N)$" src="form_18.png"/>. <div class="fragment"><pre class="fragment"><a class="code" href="apop_8h.html#af9032e16affac10d90dd3565e709966d">Apop_row</a>(indata, 0, firstrow);
<a class="code" href="structapop__data.html">apop_data</a> *binspec = <a class="code" href="apop_8h.html#add67e6838ce2521a1d756894dc9b5ccf">apop_data_copy</a>(firstrow);
gsl_matrix_set_all(binspec-&gt;matrix, 10); <span class="comment">//bins of size 10 for all dim.s</span>
<a class="code" href="apop_8h.html#a02cef4243593cf905fa54cb48d8b04c2">apop_data_to_bins</a>(indata, binspec);
</pre></div> The presumption is that the first bin starts at zero in all cases. You can add a second row to the spec to give the offset for each dimension. Default: NULL. if no binspec and no binlist, then a grid with offset equal to the min of the column, and bin size such that it takes <img class="formulaInl" alt="$\sqrt{N}$" src="form_21.png"/> bins to cover the range to the max element.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A pointer to a binned <a class="el" href="gentle.html#apop_data">apop_data</a> set. If you didn't give me a binspec, then I attach one to the output set as a page named <code>&lt;binspec&gt;</code>, so you can snap a second data set to the same grid using <div class="fragment"><pre class="fragment"><a class="code" href="apop_8h.html#a02cef4243593cf905fa54cb48d8b04c2">apop_data_to_bins</a>(first_set, NULL);
<a class="code" href="apop_8h.html#a02cef4243593cf905fa54cb48d8b04c2">apop_data_to_bins</a>(second_set, <a class="code" href="apop_8h.html#a044771db76f0afb410a8d4f05ac51ca3">apop_data_get_page</a>(first_set, <span class="stringliteral">&quot;&lt;binspec&gt;&quot;</span>));
</pre></div></dd></dl>
<p>The text segment, if any, is not binned. I use <a class="el" href="apop_8h.html#acc90578a8086a2e6f7b1575300260f08">apop_data_pmf_compress</a> as the final step in the binning, and that does respect the text segment.</p>
<p>Here is a sample program highlighting the difference between <a class="el" href="apop__hist_8c.html#a02cef4243593cf905fa54cb48d8b04c2">apop_data_to_bins</a> and <a class="el" href="apop_8h.html#acc90578a8086a2e6f7b1575300260f08">apop_data_pmf_compress</a> .</p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#define _GNU_SOURCE</span>
<span class="preprocessor"></span><span class="preprocessor">#include &lt;<a class="code" href="apop_8h.html">apop.h</a>&gt;</span>

<span class="preprocessor">#ifdef Testing</span>
<span class="preprocessor"></span><span class="preprocessor">    #define printdata(dataset)  ;</span>
<span class="preprocessor"></span><span class="preprocessor">#else</span>
<span class="preprocessor"></span><span class="preprocessor">    #define printdata(dataset)           \</span>
<span class="preprocessor">            printf(&quot;\n-----------\n\n&quot;); \</span>
<span class="preprocessor">            apop_data_print(dataset);   </span>
<span class="preprocessor"></span><span class="preprocessor">#endif</span>
<span class="preprocessor"></span>
<span class="keywordtype">int</span> main(){
    <a class="code" href="structapop__data.html">apop_data</a> *d = <a class="code" href="apop_8h.html#a9fba0f07c262a433133f6f3362617da3">apop_text_alloc</a>(<a class="code" href="apop_8h.html#ac39d6a56933b6f084328ec5ecd5090d8">apop_data_alloc</a>(6), 6, 1);
    <a class="code" href="apop_8h.html#ad6be56d710a63aa1ceadf2242c553905">apop_data_fill</a>(d,   1,   2,   3,   3,   1,   2);
    <a class="code" href="apop_8h.html#a74dca50ea16ed7bf25cb152315642769">apop_text_fill</a>(d,  <span class="stringliteral">&quot;A&quot;</span>, <span class="stringliteral">&quot;A&quot;</span>, <span class="stringliteral">&quot;A&quot;</span>, <span class="stringliteral">&quot;A&quot;</span>, <span class="stringliteral">&quot;A&quot;</span>, <span class="stringliteral">&quot;B&quot;</span>);

    asprintf(&amp;d-&gt;names-&gt;title, <span class="stringliteral">&quot;Original data set&quot;</span>);
    printdata(d);

        <span class="comment">//binned, where bin ends are equidistant but not necessarily in the data</span>
    <a class="code" href="structapop__data.html">apop_data</a> *binned = <a class="code" href="apop_8h.html#a02cef4243593cf905fa54cb48d8b04c2">apop_data_to_bins</a>(d, NULL);
    asprintf(&amp;binned-&gt;names-&gt;title, <span class="stringliteral">&quot;Post binning&quot;</span>);
    printdata(binned);
    assert(<a class="code" href="group__convenience__fns.html#ga7f85a98b61078ba3dc273f17eddd34a7">apop_sum</a>(binned-&gt;weights)==6);
    assert(fabs(<span class="comment">//equal distance between bins</span>
              (<a class="code" href="group__data__set__get.html#ga06107779e4a3eb229715ceca24352b89">apop_data_get</a>(binned, 1, -1) - <a class="code" href="group__data__set__get.html#ga06107779e4a3eb229715ceca24352b89">apop_data_get</a>(binned, 0, -1))
            - (<a class="code" href="group__data__set__get.html#ga06107779e4a3eb229715ceca24352b89">apop_data_get</a>(binned, 2, -1) - <a class="code" href="group__data__set__get.html#ga06107779e4a3eb229715ceca24352b89">apop_data_get</a>(binned, 1, -1))) &lt; 1e-5);

        <span class="comment">//compressed, where the data is as in the original, but weights </span>
        <span class="comment">//are redome to accommodate repeated observations.</span>
    <a class="code" href="apop_8h.html#acc90578a8086a2e6f7b1575300260f08">apop_data_pmf_compress</a>(d);
    asprintf(&amp;d-&gt;names-&gt;title, <span class="stringliteral">&quot;Post compression&quot;</span>);
    printdata(d);
    assert(<a class="code" href="group__convenience__fns.html#ga7f85a98b61078ba3dc273f17eddd34a7">apop_sum</a>(d-&gt;weights)==6);

    <a class="code" href="structapop__model.html">apop_model</a> *d_as_pmf = <a class="code" href="group__models.html#ga2c0598e5aca68949939a189bd4ce24ca">apop_estimate</a>(d, <a class="code" href="group__models.html#gaca8f3323c57e0223a9f3c0f991c9760e">apop_pmf</a>);
    <a class="code" href="apop_8h.html#af9032e16affac10d90dd3565e709966d">Apop_row</a>(d, 0, firstrow); <span class="comment">//1A</span>
    assert(fabs(<a class="code" href="group__models.html#ga2510c7df8ccd834732ee208005738b0f">apop_p</a>(firstrow, d_as_pmf) - 2./6 &lt; 1e-5));
}
</pre></div> 
</div>
</div>
<a class="anchor" id="ae0c28224e10f8aacdaa2d130f96f6ba2"></a><!-- doxytag: member="apop.h::apop_data_to_dummies" ref="ae0c28224e10f8aacdaa2d130f96f6ba2" args="(apop_data *d, int col, char type, int keep_first, char append, char remove)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__data.html">apop_data</a>* <a class="el" href="apop__regression_8c.html#ae0c28224e10f8aacdaa2d130f96f6ba2">apop_data_to_dummies</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>keep_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>append</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>remove</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>A utility to make a matrix of dummy variables. You give me a single vector that lists the category number for each item, and I'll produce a matrix with a single one in each row in the column specified.</p>
<p>After that, you have to decide what to do with the new matrix and the original data column.</p>
<ul>
<li>You can manually join the dummy data set with your main data, e.g.: <div class="fragment"><pre class="fragment"><a class="code" href="structapop__data.html">apop_data</a> *dummies  = <a class="code" href="apop_8h.html#ae0c28224e10f8aacdaa2d130f96f6ba2">apop_data_to_dummies</a>(main_regression_vars, .col=8, .type=<span class="charliteral">&#39;t&#39;</span>);
<a class="code" href="apop_8h.html#a0f2ffb5c5ba2bb240e930be08fc4fd56">apop_data_stack</a>(main_regression_vars, dummies, <span class="charliteral">&#39;c&#39;</span>, .inplace=<span class="charliteral">&#39;y&#39;</span>);
</pre></div></li>
</ul>
<ul>
<li>The <code>.remove='y'</code> option specifies that I should use <a class="el" href="apop__data_8c.html#a1312f6568cfe832f1e35f7f44482ffb4">apop_data_rm_columns</a> to remove the column used to generate the dummies. Implemented only for <code>type=='d'</code>.</li>
</ul>
<ul>
<li>By specifying <code>.append='y'</code> or <code>.append='e'</code> I will run the above two lines for you. Your <a class="el" href="gentle.html#apop_data">apop_data</a> pointer will not change, but its <code>matrix</code> element will be reallocated (via <a class="el" href="apop__data_8c.html#a0f2ffb5c5ba2bb240e930be08fc4fd56">apop_data_stack</a>).</li>
</ul>
<ul>
<li>By specifying <code>.append='i'</code>, I will place the matrix of dummies in place, immediately after the data column you had specified. You will probably use this with <code>.remove='y'</code> to replace the single column with the new set of dummy columns. Bear in mind that if there are two or more dummy columns (which there probably are if you are bothering to use this function), subsequent column numbers will change.</li>
</ul>
<ul>
<li>If <code>.append='i'</code> and you asked for a text column, I will append to the end of the table, which is equivalent to <code>append='e'</code>.</li>
</ul>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>The data set with the column to be dummified (No default.) </td></tr>
    <tr><td class="paramname">col</td><td>The column number to be transformed; -1==vector (default = 0) </td></tr>
    <tr><td class="paramname">type</td><td>'d'==data column, 't'==text column. (default = 't') </td></tr>
    <tr><td class="paramname">keep_first</td><td>if zero, return a matrix where each row has a one in the (column specified MINUS ONE). That is, the zeroth category is dropped, the first category has an entry in column zero, et cetera. If you don't know why this is useful, then this is what you need. If you know what you're doing and need something special, set this to one and the first category won't be dropped. (default = 0) </td></tr>
    <tr><td class="paramname">append</td><td>If <code>'e'</code> or <code>'y'</code>, append the dummy grid to the end of the original data matrix. If <code>'i'</code>, insert in place, immediately after the original data column. (default = <code>'n'</code>) </td></tr>
    <tr><td class="paramname">remove</td><td>If <code>'y'</code>, remove the original data or text column. (default = <code>'n'</code>)</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>An <a class="el" href="gentle.html#apop_data">apop_data</a> set whose <code>matrix</code> element is the one-zero matrix of dummies. If you used <code>.append</code>, then this is the main matrix. Also, I add a page named <code>"\&lt;categories for your_var\&gt;"</code> giving a reference table of names and column numbers (where <code>your_var</code> is the appropriate column heading). </dd></dl>
<dl class="exception"><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">out-&gt;error=='a'</td><td>allocation error </td></tr>
    <tr><td class="paramname">out-&gt;error=='d'</td><td>dimension error <ul>
<li>NaNs appear at the end of the sort order. </li>
<li>This function uses the <a class="el" href="designated.html">Designated initializers</a> syntax for inputs. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a27405bd5fdf48d93c8918ca4c07ee260"></a><!-- doxytag: member="apop.h::apop_data_to_factors" ref="a27405bd5fdf48d93c8918ca4c07ee260" args="(apop_data *data, char intype, int incol, int outcol)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__data.html">apop_data</a>* <a class="el" href="apop__regression_8c.html#a27405bd5fdf48d93c8918ca4c07ee260">apop_data_to_factors</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>intype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>incol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>outcol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Convert a column of text or numbers into a column of numeric factors, which you can use for a multinomial probit/logit, for example.</p>
<p>If you don't run this on your data first, <a class="el" href="group__models.html#ga319b8e3d5025a6fc94829a978273eb8b">apop_probit</a> and <a class="el" href="group__models.html#gaa88a402cf7d02c25c4613a74ace1b0c1">apop_logit</a> default to running it on the vector or (if no vector) zeroth column of the matrix of the input <a class="el" href="gentle.html#apop_data">apop_data</a> set, because those models need a list of the unique values of the dependent variable.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The data set to be modified in place. (No default. If <code>NULL</code>, returns <code>NULL</code> and a warning) </td></tr>
    <tr><td class="paramname">intype</td><td>If <code>'t'</code>, then <code>incol</code> refers to text, otherwise (<code>'d'</code> is a good choice) refers to the vector or matrix. Default = <code>'t'</code>. </td></tr>
    <tr><td class="paramname">incol</td><td>The column in the text that will be converted. -1 is the vector. Default = 0. </td></tr>
    <tr><td class="paramname">outcol</td><td>The column in the data set where the numeric factors will be written (-1 means the vector). Default = 0.</td></tr>
  </table>
  </dd>
</dl>
<p>For example: </p>
<div class="fragment"><pre class="fragment"><a class="code" href="structapop__data.html">apop_data</a> *d  = <a class="code" href="group__queries.html#ga1f06db34e05b5afb63112f83ad2317b8">apop_query_to_mixed_data</a>(<span class="stringliteral">&quot;mmt&quot;</span>, <span class="stringliteral">&quot;select 1, year, color from data&quot;</span>);
<a class="code" href="apop_8h.html#a27405bd5fdf48d93c8918ca4c07ee260">apop_data_to_factors</a>(d);
</pre></div><p> Notice that the query pulled a column of ones for the sake of saving room for the factors. It reads column zero of the text, and writes it to column zero of the matrix.</p>
<p>Another example: </p>
<div class="fragment"><pre class="fragment"><a class="code" href="structapop__data.html">apop_data</a> *d  = <a class="code" href="group__queries.html#gade862993166c6482f53562fb77721db9">apop_query_to_data</a>(<span class="stringliteral">&quot;mmt&quot;</span>, <span class="stringliteral">&quot;select type, year from data&quot;</span>);
<a class="code" href="apop_8h.html#a27405bd5fdf48d93c8918ca4c07ee260">apop_data_to_factors</a>(d, .intype=<span class="charliteral">&#39;d&#39;</span>, .incol=0, .outcol=0);
</pre></div><p> Here, the <code>type</code> column is converted to sequential integer factors and those factors overwrite the original data. Since a reference table is added as a second page of the <a class="el" href="gentle.html#apop_data">apop_data</a> set, you can recover the original values as needed.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A table of the factors used in the code. This is an <code><a class="el" href="structapop__data.html">apop_data</a></code> set with only one column of text. Also, I add a page named <code>"&lt;categories for your_var&gt;"</code> giving a reference table of names and column numbers (where <code>your_var</code> is the appropriate column heading) use <a class="el" href="apop__regression_8c.html#adec9170cf1382f6cd549a5819472eb51">apop_data_get_factor_names</a> to retrieve that table.</dd></dl>
<dl class="exception"><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">out-&gt;error=='a'</td><td>allocation error. </td></tr>
    <tr><td class="paramname">out-&gt;error=='d'</td><td>dimension error. <ul>
<li>If the vector or matrix you wanted to write to is <code>NULL</code>, I will allocate it for you. </li>
<li>This function uses the <a class="el" href="designated.html">Designated initializers</a> syntax for inputs. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a82281b8673cda3645054d7e061bb1167"></a><!-- doxytag: member="apop.h::apop_data_transpose" ref="a82281b8673cda3645054d7e061bb1167" args="(apop_data *in, char transpose_text, char inplace)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__data.html">apop_data</a>* <a class="el" href="apop__data_8c.html#a82281b8673cda3645054d7e061bb1167">apop_data_transpose</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>transpose_text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>inplace</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Transpose the matrix and text elements of the input data set, including the row/column names.</p>
<p>The vector and weights elements of the input data set are completely ignored (but see also <a class="el" href="group__conversions.html#ga604388dc6d7d08d95bbaa4422085db9c">apop_vector_to_matrix</a>, which can convert a vector to a 1 X N matrix.) If copying, these other elements won't be present; if <code>.inplace='y'</code>, it is up to you to handle these not-transposed elements correctly.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>The input <a class="el" href="gentle.html#apop_data">apop_data</a> set. If <code>NULL</code>, I return <code>NULL</code>. Default is <code>NULL</code>. </td></tr>
    <tr><td class="paramname">transpose_text</td><td>If <code>'y'</code>, then also transpose the text element. Default is <code>'y'</code>. </td></tr>
    <tr><td class="paramname">inplace</td><td>If <code>'y'</code>, transpose the input in place; if <code>'n'</code>, produce a transposed copy, leaving the original untouched. Due to how <code>gsl_matrix_transpose_memcpy</code> works, a copy will still be made, then copied to the original location. Default is <code>'y'</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>If <code>inplace=='n'</code>, a newly alloced <a class="el" href="gentle.html#apop_data">apop_data</a> set, with the appropriately transposed matrix and/or text. The vector and weights elements will be <code>NULL</code>. If <code>transpose_text='n'</code>, then the text element of the output set will also be <code>NULL</code>.<br/>
 if <code>inplace=='y'</code>, a pointer to the original data set, with matrix and (if <code>transpose_text='y'</code>) text transposed and vector and weights left in place untouched.</dd></dl>
<ul>
<li>Row names are written to column names of the output matrix, text, or both (whichever is not empty in the input). </li>
<li>If only the matrix or only the text have names, then the one set of names is written to the row names of the output. </li>
<li>If both matrix column names and text column names are present, text column names are lost. </li>
<li>if you have a <code>gsl_matrix</code> with no names or text, you may prefer to use <code>gsl_matrix_transpose_memcpy</code>.</li>
</ul>
<ul>
<li>This function uses the <a class="el" href="designated.html">Designated initializers</a> syntax for inputs. </li>
</ul>

</div>
</div>
<a class="anchor" id="acf205f62e9432fe293b05c077d1b61d4"></a><!-- doxytag: member="apop.h::apop_db_close" ref="acf205f62e9432fe293b05c077d1b61d4" args="(char vacuum)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="apop__db_8c.html#acf205f62e9432fe293b05c077d1b61d4">apop_db_close</a> </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>vacuum</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Closes the database on disk. If you opened the database with <code>apop_db_open(NULL)</code>, then this is basically optional.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">vacuum</td><td>'v': vacuum---do clean-up to minimize the size of the database on disk.<br/>
 'q': Don't bother; just close the database. (default = 'q')</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on OK, nonzero on error. <ul>
<li>This function uses the <a class="el" href="designated.html">Designated initializers</a> syntax for inputs. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a4d81aff912df2982697038c51795e358"></a><!-- doxytag: member="apop.h::apop_db_open" ref="a4d81aff912df2982697038c51795e358" args="(char const *filename)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="apop__db_8c.html#a4d81aff912df2982697038c51795e358">apop_db_open</a> </td>
          <td>(</td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>If you want to use a database on the hard drive instead of memory, then call this once and only once before using any other database utilities.</p>
<p>If you want a disposable database which you won't use after the program ends, don't bother with this function.</p>
<p>The trade-offs between an on-disk database and an in-memory db are as one would expect: memory is faster, but is destroyed when the program exits. SQLite includes a command line utility (<code>sqlite3</code>) which let you ask queries of a database on disk, which may be useful for debugging. There are also some graphical front-ends; just ask your favorite search engine for <a href="http://www.google.com/search?&amp;q=sqlite+gui">SQLite GUI</a>.</p>
<p>MySQL users: either set the environment variable APOP_DB_ENGINE=mysql or set <code>apop_opts.db_engine</code> = 'm'.</p>
<p>The Apophenia package assumes you are only using a single SQLite database at a time. You can use the SQL <code>attach</code> function to load other databases, or see <a href="http://modelingwithdata.org/arch/00000142.htm">this blog post</a> for further suggestions and sample code.</p>
<p>When you are done doing your database manipulations, be sure to call <a class="el" href="apop__db_8c.html#acf205f62e9432fe293b05c077d1b61d4">apop_db_close</a> if writing to disk.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>The name of a file on the hard drive on which to store the database. If <code>NULL</code>, then the database will be kept in memory (in which case, the other database functions will call this function for you and you don't need to bother).</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0: everything OK<br/>
 1: database did not open. </dd></dl>

</div>
</div>
<a class="anchor" id="aebe17fe6f2b0c49c0c90824b7a68ff90"></a><!-- doxytag: member="apop.h::apop_db_to_crosstab" ref="aebe17fe6f2b0c49c0c90824b7a68ff90" args="(char *tabname, char *r1, char *r2, char *datacol)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__data.html">apop_data</a>* <a class="el" href="apop__conversions_8c.html#aebe17fe6f2b0c49c0c90824b7a68ff90">apop_db_to_crosstab</a> </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>tabname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>r1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>r2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>datacol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Give the name of a table in the database, and names of three of its columns: the x-dimension, the y-dimension, and the data. the output is a 2D matrix with rows indexed by r1 and cols by r2.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">tabname</td><td>The database table I'm querying. Anything that will work inside a <code>from</code> clause is OK, such as a subquery in parens. </td></tr>
    <tr><td class="paramname">r1</td><td>The column of the data set that will indicate the rows of the output crosstab </td></tr>
    <tr><td class="paramname">r2</td><td>The column of the data set that will indicate the columns of the output crosstab </td></tr>
    <tr><td class="paramname">datacol</td><td>The column of the data set holding the data for the cells of the crosstab</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>If the query to get data to fill the table (select r1, r2, datacol from tabname) returns an empty data set, then I will return a <code>NULL</code> data set and if <code>apop_opts.verbosity &gt;= 1</code> print a warning.</li>
</ul>
<ul>
<li>This setup presumes that there is one value for each (row, col) coordinate in the data. You may want an aggregate instead. There are two ways to do this, both of which hack the fact that this function runs a simple <code>select</code> query to generate the data. One is to specify an ad hoc table to pull from:</li>
</ul>
<div class="fragment"><pre class="fragment"><a class="code" href="structapop__data.html">apop_data</a> * out = <a class="code" href="apop_8h.html#aebe17fe6f2b0c49c0c90824b7a68ff90">apop_db_to_crosstab</a>(<span class="stringliteral">&quot;(select row, col, count(*) ct from base_data group by row, col)&quot;</span>, <span class="stringliteral">&quot;row&quot;</span>, <span class="stringliteral">&quot;col&quot;</span>,  <span class="stringliteral">&quot;ct&quot;</span>);
</pre></div><p>The other is to use the fact that the table name will be at the end of the query, so you can add conditions to the table:</p>
<div class="fragment"><pre class="fragment"><a class="code" href="structapop__data.html">apop_data</a> * out = <a class="code" href="apop_8h.html#aebe17fe6f2b0c49c0c90824b7a68ff90">apop_db_to_crosstab</a>(<span class="stringliteral">&quot;base_data group by row, col&quot;</span>, <span class="stringliteral">&quot;row&quot;</span>, <span class="stringliteral">&quot;col&quot;</span>, <span class="stringliteral">&quot;count(*)&quot;</span>);
<span class="comment">//which will expand to &quot;select row, col, count(*) from base_data group by row, col&quot;</span>
</pre></div><dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="apop__conversions_8c.html#aee8c299b83b8500b8b6ecd30817353c8">apop_crosstab_to_db</a></dd></dl>
<dl class="exception"><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">out-&gt;error='n'</td><td>Name not found error. </td></tr>
    <tr><td class="paramname">out-&gt;error='q'</td><td>Query returned an empty table (which might mean that it just failed). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae165633525c5272ab83794b60076eddc"></a><!-- doxytag: member="apop.h::apop_estimate_parameter_tests" ref="ae165633525c5272ab83794b60076eddc" args="(apop_model *est)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="apop__regression_8c.html#ae165633525c5272ab83794b60076eddc">apop_estimate_parameter_tests</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__model.html">apop_model</a> *&#160;</td>
          <td class="paramname"><em>est</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>For many, it is a knee-jerk reaction to a parameter estimation to test whether each individual parameter differs from zero. This function does that.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">est</td><td>The <a class="el" href="structapop__model.html">apop_model</a>, which includes pre-calculated parameter estimates, var-covar matrix, and the original data set.</td></tr>
  </table>
  </dd>
</dl>
<p>Returns nothing. At the end of the routine, <code>est-&gt;info-&gt;more</code> includes a set of t-test values: p value, confidence (=1-pval), t statistic, standard deviation, one-tailed Pval, one-tailed confidence. </p>

</div>
</div>
<a class="anchor" id="a1902b3fd6a6682d1453a80b788e44ebb"></a><!-- doxytag: member="apop.h::apop_f_test" ref="a1902b3fd6a6682d1453a80b788e44ebb" args="(apop_model *est, apop_data *contrast)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__data.html">apop_data</a>* <a class="el" href="apop__tests_8c.html#a1902b3fd6a6682d1453a80b788e44ebb">apop_f_test</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__model.html">apop_model</a> *&#160;</td>
          <td class="paramname"><em>est</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>contrast</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Runs an F-test specified by <code>q</code> and <code>c</code>. Your best bet is to see the chapter on hypothesis testing in <a href="http://modelingwithdata.org">Modeling With Data</a>, p 309. It will tell you that: </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[{N-K\over q} {({\bf Q}'\hat\beta - {\bf c})' [{\bf Q}' ({\bf X}'{\bf X})^{-1} {\bf Q}]^{-1} ({\bf Q}' \hat\beta - {\bf c}) \over {\bf u}' {\bf u} } \sim F_{q,N-K},\]" src="form_88.png"/>
</p>
<p> and that's what this function is based on.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">est</td><td>an <a class="el" href="structapop__model.html">apop_model</a> that you have already calculated. (No default) </td></tr>
    <tr><td class="paramname">contrast</td><td>The matrix <img class="formulaInl" alt="${\bf Q}$" src="form_89.png"/> and the vector <img class="formulaInl" alt="${\bf c}$" src="form_90.png"/>, where each row represents a hypothesis. (Defaults: if matrix is <code>NULL</code>, it is set to the identity matrix with the top row missing. If the vector is <code>NULL</code>, it is set to a zero matrix of length equal to the height of the contrast matrix. Thus, if the entire <code><a class="el" href="structapop__data.html">apop_data</a></code> set is NULL or omitted, we are testing the hypothesis that all but <img class="formulaInl" alt="$\beta_1$" src="form_91.png"/> are zero.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>An <code><a class="el" href="structapop__data.html">apop_data</a></code> set with a few variants on the confidence with which we can reject the joint hypothesis. </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000002">Todo:</a></b></dt><dd>There should be a way to get OLS and GLS to store <img class="formulaInl" alt="$(X'X)^{-1}$" src="form_92.png"/>. In fact, if you did GLS, this is invalid, because you need <img class="formulaInl" alt="$(X'\Sigma X)^{-1}$" src="form_93.png"/>, and I didn't ask for <img class="formulaInl" alt="$\Sigma$" src="form_94.png"/>.</dd></dl>
<ul>
<li>There are two approaches to an <img class="formulaInl" alt="$F$" src="form_82.png"/>-test: the ANOVA approach, which is typically built around the claim that all effects but the mean are zero; and the more general regression form, which allows for any set of linear claims about the data. If you send a <code>NULL</code> contrast set, I will generate the set of linear contrasts that are equivalent to the ANOVA-type approach. Readers of {<em>Modeling</em> with Data}, note that there's a bug in the book that claims that the traditional ANOVA approach also checks that the coefficient for the constant term is also zero; this is not the custom and doesn't produce the equivalence presented in that and other textbooks.</li>
</ul>
<dl class="exception"><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">out-&gt;error='a'</td><td>Allocation error. </td></tr>
    <tr><td class="paramname">out-&gt;error='d'</td><td>dimension-matching error. </td></tr>
    <tr><td class="paramname">out-&gt;error='i'</td><td>matrix inversion error. </td></tr>
    <tr><td class="paramname">out-&gt;error='m'</td><td>GSL math error. <ul>
<li>This function uses the <a class="el" href="designated.html">Designated initializers</a> syntax for inputs. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a757dd4278aac9967f9e62c3ef3c8fc69"></a><!-- doxytag: member="apop.h::apop_generalized_harmonic" ref="a757dd4278aac9967f9e62c3ef3c8fc69" args="(int N, double s) __attribute__((__pure__))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="apop__asst_8c.html#aeae8cdce5cd08d8ea29006c51b697ca5">apop_generalized_harmonic</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Calculate <img class="formulaInl" alt="$\sum_{n=1}^N {1\over n^s}$" src="form_3.png"/></p>
<ul>
<li>There are no doubt efficient shortcuts do doing this, but I use brute force. [Though Knuth's Art of Programming v1 doesn't offer anything, which is strong indication of nonexistence.] To speed things along, I save the results so that they can just be looked up should you request the same calculation.</li>
</ul>
<ul>
<li>If <code>N</code> is zero or negative, return NaN. Notify the user if <code>apop_opts.verbosity &gt;=1</code></li>
</ul>
<p>For example:</p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &lt;<a class="code" href="apop_8h.html">apop.h</a>&gt;</span>

<span class="keywordtype">int</span> main(){
    <span class="keywordtype">double</span> out = <a class="code" href="apop_8h.html#a757dd4278aac9967f9e62c3ef3c8fc69">apop_generalized_harmonic</a>(270, 0.0);
     assert (out == 270);
     out  = <a class="code" href="apop_8h.html#a757dd4278aac9967f9e62c3ef3c8fc69">apop_generalized_harmonic</a>(370, -1.0);
     assert (out == 370*371/2);
     out  = <a class="code" href="apop_8h.html#a757dd4278aac9967f9e62c3ef3c8fc69">apop_generalized_harmonic</a>(12, -1.0);
     assert (out == 12*13/2);
}
</pre></div> 
</div>
</div>
<a class="anchor" id="a8a85afbb18d256bcc8942d2eca7470ed"></a><!-- doxytag: member="apop.h::apop_jackknife_cov" ref="a8a85afbb18d256bcc8942d2eca7470ed" args="(apop_data *data, apop_model *model)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__data.html">apop_data</a>* <a class="el" href="apop__bootstrap_8c.html#a634432014188489d758d7c1acfc9a0a5">apop_jackknife_cov</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structapop__model.html">apop_model</a> *&#160;</td>
          <td class="paramname"><em>model</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Give me a data set and a model, and I'll give you the jackknifed covariance matrix of the model parameters.</p>
<p>The basic algorithm for the jackknife (with many details glossed over): create a sequence of data sets, each with exactly one observation removed, and then produce a new set of parameter estimates using that slightly shortened data set. Then, find the covariance matrix of the derived parameters.</p>
<p>Jackknife or bootstrap? As a broad rule of thumb, the jackknife works best on models that are closer to linear. The worse a linear approximation does (at the given data), the worse the jackknife approximates the variance.</p>
<p>Sample usage: </p>
<div class="fragment"><pre class="fragment"><a class="code" href="group__output.html#ga9a30c437ec11a11e37e0db7f82386275">apop_data_show</a>(<a class="code" href="apop_8h.html#a8a85afbb18d256bcc8942d2eca7470ed">apop_jackknife_cov</a>(your_data, your_model));
</pre></div><dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>The data set. An <a class="el" href="gentle.html#apop_data">apop_data</a> set where each row is a single data point. </td></tr>
    <tr><td class="paramname">model</td><td>An <a class="el" href="structapop__model.html">apop_model</a>, that will be used internally by <a class="el" href="group__models.html#ga2c0598e5aca68949939a189bd4ce24ca">apop_estimate</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">out-&gt;error=='n'</td><td><code>NULL</code> input data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>An <code><a class="el" href="structapop__data.html">apop_data</a></code> set whose matrix element is the estimated covariance matrix of the parameters. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="apop__bootstrap_8c.html#a4eb57b1f864c650ed6d7e029550e7bb8">apop_bootstrap_cov</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a10b4b9735a1475cfa5ebe2dd33686686"></a><!-- doxytag: member="apop.h::apop_kl_divergence" ref="a10b4b9735a1475cfa5ebe2dd33686686" args="(apop_model *from, apop_model *to, int draw_ct, gsl_rng *rng, apop_model *top, apop_model *bottom)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="apop__stats_8c.html#a10b4b9735a1475cfa5ebe2dd33686686">apop_kl_divergence</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__model.html">apop_model</a> *&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structapop__model.html">apop_model</a> *&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>draw_ct</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsl_rng *&#160;</td>
          <td class="paramname"><em>rng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structapop__model.html">apop_model</a> *&#160;</td>
          <td class="paramname"><em>top</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structapop__model.html">apop_model</a> *&#160;</td>
          <td class="paramname"><em>bottom</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Kullback-Leibler divergence.</p>
<p>This measure of the divergence of one distribution from another has the form <img class="formulaInl" alt="$ D(p,q) = \sum_i \ln(p_i/q_i) p_i $" src="form_76.png"/>. Notice that it is not a distance, because there is an asymmetry between <img class="formulaInl" alt="$p$" src="form_20.png"/> and <img class="formulaInl" alt="$q$" src="form_77.png"/>, so one can expect that <img class="formulaInl" alt="$D(p, q) \neq D(q, p)$" src="form_78.png"/>.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>the <img class="formulaInl" alt="$p$" src="form_20.png"/> in the above formula. (No default; must not be <code>NULL</code>) </td></tr>
    <tr><td class="paramname">to</td><td>the <img class="formulaInl" alt="$q$" src="form_77.png"/> in the above formula. (No default; must not be <code>NULL</code>) </td></tr>
    <tr><td class="paramname">draw_ct</td><td>If I do the calculation via random draws, how many? (Default = 1e5) </td></tr>
    <tr><td class="paramname">rng</td><td>A <code>gsl_rng</code>. If NULL, I'll take care of the RNG; see <a class="el" href="apop_8h.html#a1e829ce2396bf05ab10460bcc37aeeab">apop_rng_get_thread</a>. (Default = <code>NULL</code>) </td></tr>
    <tr><td class="paramname">top</td><td>deprecated synonym for <code>from</code>. </td></tr>
    <tr><td class="paramname">bottom</td><td>deprecated synonym for <code>to</code>.</td></tr>
  </table>
  </dd>
</dl>
<p>This function can take empirical histogram-type models (<a class="el" href="group__models.html#gaca8f3323c57e0223a9f3c0f991c9760e">apop_pmf</a>) or continuous models like <a class="el" href="group__models.html#gaf7d01cc4076c9319036a0cce882dac62">apop_loess</a> or <a class="el" href="group__models.html#ga297c2dc8dbdf4ae93fc7e10860400466">apop_normal</a>.</p>
<p>If there is a PMF (I'll try <code>from</code> first, under the presumption that you are measuring the divergence of data from an observed data distribution), then I'll step through it for the points in the summation.</p>
<ul>
<li>If you have two empirical distributions, that they must be synced: if <img class="formulaInl" alt="$p_i>0$" src="form_79.png"/> but <img class="formulaInl" alt="$q_i=0$" src="form_80.png"/>, then the function returns <code>GSL_NEGINF</code>. If <code>apop_opts.verbose &gt;=1</code> I print a message as well.</li>
</ul>
<p>If neither distribution is a PMF, then I'll take <code>draw_ct</code> random draws from <code>to</code> and evaluate at those points.</p>
<ul>
<li>Set <code>apop_opts.verbose = 3</code> for observation-by-observation info.</li>
</ul>
<ul>
<li>This function uses the <a class="el" href="designated.html">Designated initializers</a> syntax for inputs. </li>
</ul>

</div>
</div>
<a class="anchor" id="ad490e5b31d1bbc99223c2cbfac7c1782"></a><!-- doxytag: member="apop.h::apop_linear_constraint" ref="ad490e5b31d1bbc99223c2cbfac7c1782" args="(gsl_vector *beta, apop_data *constraint, double margin)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long double <a class="el" href="apop__linear__constraint_8c.html#ad490e5b31d1bbc99223c2cbfac7c1782">apop_linear_constraint</a> </td>
          <td>(</td>
          <td class="paramtype">gsl_vector *&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>constraint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>margin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This is designed to be called from within the constraint method of your <a class="el" href="structapop__model.html">apop_model</a>. Just write the constraint vector+matrix and this will do the rest. See the outline page for detailed discussion on setting contrasts.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">beta</td><td>The proposed vector about to be tested. No default, must not be <code>NULL</code>.</td></tr>
    <tr><td class="paramname">constraint</td><td>A vector/matrix pair [v | m1 m2 ... mn] where each row is interpreted as a less-than inequality: <img class="formulaInl" alt="$v < m1x1+ m2x2 + ... + mnxn$" src="form_37.png"/>. For example, say your constraints are <img class="formulaInl" alt="$3 < 2x + 4y - 7z$" src="form_38.png"/> and <img class="formulaInl" alt="$y$" src="form_39.png"/> is positive, i.e. <img class="formulaInl" alt="$0 < y$" src="form_40.png"/>. Allocate and fill the matrix representing these two constraints via: <div class="fragment"><pre class="fragment"><a class="code" href="structapop__data.html">apop_data</a> *constr = <a class="code" href="apop_8h.html#acb6b2c53478f9db902ba0340ba499819">apop_data_falloc</a>((2,2,3), 3,  2, 4, 7,
                                              0,  0, 1, 0);
</pre></div> . Default: each elements is greater than zero. E.g., for three parameters: <div class="fragment"><pre class="fragment"><a class="code" href="structapop__data.html">apop_data</a> *constr = <a class="code" href="apop_8h.html#acb6b2c53478f9db902ba0340ba499819">apop_data_falloc</a>((3,3,3), 0,  1, 0, 0,
                                              0,  0, 1, 0,
                                              0,  0, 0, 1);
</pre></div></td></tr>
    <tr><td class="paramname">margin</td><td>If zero, then this is a &gt;= constraint, otherwise I will return a point this amount within the borders. You could try <code>GSL_DBL_EPSILON</code>, which is the smallest value a <code>double</code> can hold, or something like 1e-3. Default = 0.</td></tr>
  </table>
  </dd>
</dl>
<p>return The penalty = the distance between beta and the closest point that meets the constraints. If the constraint is not met, this <code>beta</code> is shifted by <code>margin</code> (Euclidean distance) to meet the constraints.</p>
<ul>
<li>If your <a class="el" href="gentle.html#apop_data">apop_data</a> is not just a vector, try <a class="el" href="group__conversions.html#ga7e31798ab418cbfc7488eaba27dad2af">apop_data_pack</a> to pack it into a vector. This is what <a class="el" href="group__mle.html#gae9f092d1786034dd2ab22c63de5c955c">apop_maximum_likelihood</a> does.</li>
</ul>
<ul>
<li>This function uses the <a class="el" href="designated.html">Designated initializers</a> syntax for inputs. todo The apop_linear_constraint function doesn't check for odd cases like coplanar constraints. </li>
</ul>

</div>
</div>
<a class="anchor" id="afc7707d44884aa63c298510a0662956a"></a><!-- doxytag: member="apop.h::apop_matrix_is_positive_semidefinite" ref="afc7707d44884aa63c298510a0662956a" args="(gsl_matrix *m, char semi)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="apop__stats_8c.html#afc7707d44884aa63c298510a0662956a">apop_matrix_is_positive_semidefinite</a> </td>
          <td>(</td>
          <td class="paramtype">gsl_matrix *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>semi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Test whether the input matrix is positive semidefinite.</p>
<p>A covariance matrix will always be PSD, so this function can tell you whether your matrix is a valid covariance matrix.</p>
<p>Consider the 1x1 matrix in the upper left of the input, then the 2x2 matrix in the upper left, on up to the full matrix. If the matrix is PSD, then each of these has a positive determinant. This function thus calculates <img class="formulaInl" alt="$N$" src="form_6.png"/> determinants for an <img class="formulaInl" alt="$N$" src="form_6.png"/>x <img class="formulaInl" alt="$N$" src="form_6.png"/> matrix.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The matrix to test. If <code>NULL</code>, I will return zero---not PSD. </td></tr>
    <tr><td class="paramname">semi</td><td>If anything but 's', check for positive definite, not semidefinite. (default 's')</td></tr>
  </table>
  </dd>
</dl>
<p>See also <a class="el" href="apop__stats_8c.html#af1fc93322ffcb4e20cfc0b9af9e2aea0">apop_matrix_to_positive_semidefinite</a>, which will change the input to something PSD.</p>
<ul>
<li>This function uses the <a class="el" href="designated.html">Designated initializers</a> syntax for inputs. </li>
</ul>

</div>
</div>
<a class="anchor" id="af6290c453c3012c1d0a6987688ebe795"></a><!-- doxytag: member="apop.h::apop_matrix_normalize" ref="af6290c453c3012c1d0a6987688ebe795" args="(gsl_matrix *data, const char row_or_col, const char normalization)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="apop__stats_8c.html#af6290c453c3012c1d0a6987688ebe795">apop_matrix_normalize</a> </td>
          <td>(</td>
          <td class="paramtype">gsl_matrix *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>row_or_col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>normalization</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Normalize each row or column in the given matrix, one by one.</p>
<p>Basically just a convenience fn to iterate through the columns or rows and run <a class="el" href="apop__stats_8c.html#a194ad92b1bc632ba1d13d9958c7b5b4d">apop_vector_normalize</a> for you.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The data set to normalize. </td></tr>
    <tr><td class="paramname">row_or_col</td><td>Either 'r' or 'c'. </td></tr>
    <tr><td class="paramname">normalization</td><td>see <a class="el" href="apop__stats_8c.html#a194ad92b1bc632ba1d13d9958c7b5b4d">apop_vector_normalize</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa06b6ab6ec9f78f305b1dacc8ec2efd3"></a><!-- doxytag: member="apop.h::apop_matrix_realloc" ref="aa06b6ab6ec9f78f305b1dacc8ec2efd3" args="(gsl_matrix *m, size_t newheight, size_t newwidth)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gsl_matrix* <a class="el" href="apop__data_8c.html#aa06b6ab6ec9f78f305b1dacc8ec2efd3">apop_matrix_realloc</a> </td>
          <td>(</td>
          <td class="paramtype">gsl_matrix *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>newheight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>newwidth</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function will resize a <code>gsl_matrix</code> to a new height or width.</p>
<p>Data in the matrix will be retained. If the new height or width is smaller than the old, then data in the later rows/columns will be cropped away (in a non--memory-leaking manner). If the new height or width is larger than the old, then new cells will be filled with garbage; it is your responsibility to zero out or otherwise fill new rows/columns before use.</p>
<p><b>Warning I</b>: Using this function is basically bad form---especially when used in a <code>for</code> loop that adds a column each time. A large number of <code>realloc</code>s can take a noticeable amount of time. You are thus encouraged to make an effort to determine the size of your data beforehand.</p>
<p><b>Warning II</b>: The <code>gsl_matrix</code> is a versatile struct that can represent submatrices and other cuts from parent data. I can't deal with those, and check for such situations beforehand. [Besides, resizing a portion of a parent matrix makes no sense.]</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The already-allocated matrix to resize. If you give me <code>NULL</code>, this becomes equivalent to <code>gsl_matrix_alloc</code> </td></tr>
    <tr><td class="paramname">newheight,newwidth</td><td>The height and width you'd like the matrix to be. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>m, now resized </dd></dl>

</div>
</div>
<a class="anchor" id="a5402b8254a90f2ac68770d6867502e5a"></a><!-- doxytag: member="apop.h::apop_matrix_rm_columns" ref="a5402b8254a90f2ac68770d6867502e5a" args="(gsl_matrix *in, int *drop)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gsl_matrix* <a class="el" href="apop__linear__algebra_8c.html#a5402b8254a90f2ac68770d6867502e5a">apop_matrix_rm_columns</a> </td>
          <td>(</td>
          <td class="paramtype">gsl_matrix *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>drop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Delete columns from a matrix.</p>
<p>This is done via copying, so if you have an exceptionally large data set, you're better off producing the matrix in the perfect form directly.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>the <code>gsl_matrix</code> to be subsetted </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a <code>gsl_matrix</code> with the specified columns removed. If you ask me to remove no columns, I'll return a copy of the original. If you ask me to remove all columns, I'll return <code>NULL</code>. </dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">drop</td><td>an array of <code>int</code>s. If use[7]==1, then column seven will be cut from the output. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac0674dcc81232e37c27f612499495bd4"></a><!-- doxytag: member="apop.h::apop_matrix_to_data" ref="ac0674dcc81232e37c27f612499495bd4" args="(gsl_matrix *m)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__data.html">apop_data</a>* <a class="el" href="apop__data_8c.html#ac0674dcc81232e37c27f612499495bd4">apop_matrix_to_data</a> </td>
          <td>(</td>
          <td class="paramtype">gsl_matrix *&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Wrap an <a class="el" href="gentle.html#apop_data">apop_data</a> structure around an existing <code>gsl_matrix</code>. The matrix is not copied, but is pointed to by the new <a class="el" href="gentle.html#apop_data">apop_data</a> struct.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The existing matrix you'd like to turn into an <a class="el" href="gentle.html#apop_data">apop_data</a> structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The <a class="el" href="gentle.html#apop_data">apop_data</a> structure whose <code>matrix</code> pointer points to the input matrix. The rest of the struct is basically blank. <ul>
<li>If you give me a <code>NULL</code> matrix, I return a blank <a class="el" href="gentle.html#apop_data">apop_data</a> set, equivalent to <code><a class="el" href="apop_8h.html#ac39d6a56933b6f084328ec5ecd5090d8">apop_data_alloc()</a></code>, and print a warning if <code>apop_opts.verbosity &gt;=1</code> </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="af1fc93322ffcb4e20cfc0b9af9e2aea0"></a><!-- doxytag: member="apop.h::apop_matrix_to_positive_semidefinite" ref="af1fc93322ffcb4e20cfc0b9af9e2aea0" args="(gsl_matrix *m)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="apop__stats_8c.html#af1fc93322ffcb4e20cfc0b9af9e2aea0">apop_matrix_to_positive_semidefinite</a> </td>
          <td>(</td>
          <td class="paramtype">gsl_matrix *&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>First, this function passes tests, but is under development.</p>
<p>It takes in a matrix and converts it to the `closest' positive semidefinite matrix.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>On input, any matrix; on output, a positive semidefinite matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the distance between the original and new matrices.</dd></dl>
<ul>
<li>See also the test function <a class="el" href="apop__stats_8c.html#afc7707d44884aa63c298510a0662956a">apop_matrix_is_positive_semidefinite</a>. </li>
<li>This function can be used as (the core of) a model constraint.</li>
</ul>
<p>Adapted from the R Matrix package's nearPD, which is Copyright (2007) Jens Oehlschlgel [and is GPL]. </p>

</div>
</div>
<a class="anchor" id="a2a184259c139f1fdd970ef6b43f6274e"></a><!-- doxytag: member="apop.h::apop_ml_impute" ref="a2a184259c139f1fdd970ef6b43f6274e" args="(apop_data *d, apop_model *meanvar)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__model.html">apop_model</a>* <a class="el" href="apop__missing__data_8c.html#a985955429db179a45eb5936ebd324760">apop_ml_impute</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structapop__model.html">apop_model</a> *&#160;</td>
          <td class="paramname"><em>mvn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Impute the most likely data points to replace NaNs in the data, and insert them into the given data. That is, the data set is modified in place.</p>
<p>How it works: this uses the machinery for <a class="el" href="apop__fix__params_8c.html#ab4f6ca7e042ac7c09c3c01d29702a739">apop_model_fix_params</a>. The only difference is that this searches over the data space and takes the parameter space as fixed, while basic fix params model searches parameters and takes data as fixed. So this function just does the necessary data-parameter switching to make that happen.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>The data set. It comes in with NaNs and leaves entirely filled in. </td></tr>
    <tr><td class="paramname">mvn</td><td>A parametrized <a class="el" href="structapop__model.html">apop_model</a> from which you expect the data was derived. if <code>NULL</code>, then I'll use the Multivariate Normal that best fits the data after listwise deletion.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>An estimated <code>apop_ml_impute_model</code>. Also, the data input will be filled in and ready to use. </dd></dl>

</div>
</div>
<a class="anchor" id="a4e204cdc7429bef3ca2efb83453fe77a"></a><!-- doxytag: member="apop.h::apop_model_draws" ref="a4e204cdc7429bef3ca2efb83453fe77a" args="(apop_model *model, int count, apop_data *draws)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__data.html">apop_data</a>* <a class="el" href="apop__asst_8c.html#a4e204cdc7429bef3ca2efb83453fe77a">apop_model_draws</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__model.html">apop_model</a> *&#160;</td>
          <td class="paramname"><em>model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>draws</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Make a set of random draws from a model and write them to an <a class="el" href="gentle.html#apop_data">apop_data</a> set.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">model</td><td>The model from which draws will be made. Must already be prepared and/or estimated.</td></tr>
    <tr><td class="paramname">count</td><td>The number of draws to make. If <code>draw_matrix</code> is not <code>NULL</code>, then this is ignored and <code>count=draw_matrix-&gt;matrix-&gt;size1</code>. default=1000.</td></tr>
    <tr><td class="paramname">draws</td><td>If not <code>NULL</code>, a pre-allocated data set whose <code>matrix</code> element will be filled with draws.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>An <a class="el" href="gentle.html#apop_data">apop_data</a> set with the matrix filled with <code>size</code> draws. If <code>draw_matrix!=NULL</code>, then return a pointer to it.</dd></dl>
<dl class="exception"><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">out-&gt;error=='m'</td><td>Input model isn't good for making draws: it is <code>NULL</code>, or <code>m-&gt;dsize=0</code>.</td></tr>
    <tr><td class="paramname">out-&gt;error=='s'</td><td>You gave me a <code>draws</code> matrix, but its size is less than the size of a single draw from the data, <code>model-&gt;dsize</code>.</td></tr>
    <tr><td class="paramname">out-&gt;error=='d'</td><td>Trouble drawing from the distribution for at least one row. That row is set to all <code>NAN</code>.</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>Prints a warning if you send in a non-<code>NULL <a class="el" href="structapop__data.html">apop_data</a></code> set, but its <code>matrix</code> element is <code>NULL</code>, when <code>apop_opts.verbose&gt;=1</code>.</li>
</ul>
<ul>
<li>See also <a class="el" href="group__models.html#ga87f15cd1923ed7b5b46e52a77ca1dfef">apop_draw</a>, which makes a single draw.</li>
</ul>
<ul>
<li>Random numbers are generated using RNGs from <a class="el" href="apop_8h.html#a1e829ce2396bf05ab10460bcc37aeeab">apop_rng_get_thread</a>, qv.</li>
</ul>
<p>Here is a two-line program to draw a different set of ten Standard Normals on every run (provided runs are more than a second apart):</p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &lt;<a class="code" href="apop_8h.html">apop.h</a>&gt;</span>
<span class="preprocessor">#include &lt;time.h&gt;</span>

<span class="keywordtype">int</span> main(){
    <a class="code" href="apop_8h.html#a7975faa07196cf463ec261ff0ddc3ccc">apop_opts</a>.rng_seed = time(NULL);
    <a class="code" href="group__apop__print.html#gab45a848e5dbcaf82b5b95cd03f7b396a">apop_data_print</a>(
            <a class="code" href="apop_8h.html#a4e204cdc7429bef3ca2efb83453fe77a">apop_model_draws</a>(
                <a class="code" href="group__models.html#ga36cae46a2950eb6cfb65794cdd5dac7e">apop_model_set_parameters</a>(<a class="code" href="group__models.html#ga297c2dc8dbdf4ae93fc7e10860400466">apop_normal</a>, 0, 1), 
                .count=10, 
            )
    );
}
</pre></div> 
</div>
</div>
<a class="anchor" id="ab4f6ca7e042ac7c09c3c01d29702a739"></a><!-- doxytag: member="apop.h::apop_model_fix_params" ref="ab4f6ca7e042ac7c09c3c01d29702a739" args="(apop_model *model_in)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__model.html">apop_model</a>* <a class="el" href="apop__fix__params_8c.html#ab4f6ca7e042ac7c09c3c01d29702a739">apop_model_fix_params</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__model.html">apop_model</a> *&#160;</td>
          <td class="paramname"><em>model_in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Produce a model based on another model, but with some of the parameters fixed at a given value.</p>
<p>You will send me the model whose parameters you want fixed, with the <code>parameters</code> element set as follows. For the fixed parameters, simply give the values to which they will be fixed. Set the free parameters to <code>NaN</code>.</p>
<p>For example, here is a Binomial distribution with a fixed <img class="formulaInl" alt="$n=30$" src="form_168.png"/> but <img class="formulaInl" alt="$p_1$" src="form_164.png"/> allowed to float freely:</p>
<div class="fragment"><pre class="fragment"><a class="code" href="structapop__model.html">apop_model</a> *bi30 = <a class="code" href="apop_8h.html#ab4f6ca7e042ac7c09c3c01d29702a739">apop_model_fix_params</a>(<a class="code" href="group__models.html#ga36cae46a2950eb6cfb65794cdd5dac7e">apop_model_set_parameters</a>(<a class="code" href="group__models.html#ga20017e88fda3695f093279c8191f48e3">apop_binomial</a>, 30, GSL_NAN));
Apop_model_add_group(bi30, apop_mle, .starting_pt=(<span class="keywordtype">double</span>[]){.5}); <span class="comment">// The Binomial doesn&#39;t like the default </span>
                                                                   <span class="comment">// starting point of 1.</span>
<a class="code" href="structapop__model.html">apop_model</a> *out = <a class="code" href="group__models.html#ga2c0598e5aca68949939a189bd4ce24ca">apop_estimate</a>(your_data, bi30);
</pre></div><p>The output is an <code><a class="el" href="structapop__model.html">apop_model</a></code> that can be estimated, Bayesian updated, et cetera.</p>
<ul>
<li>Rather than using this model, you may simply want a now-filled-in copy of the original model. Use <a class="el" href="apop__fix__params_8c.html#ae70ae98621cd8ee628d1a5d9c8e82111">apop_model_fix_params_get_base</a> to retrieve the original model's parameters.</li>
</ul>
<ul>
<li>The <code>estimate</code> method always uses an MLE, and it never calls the base model's <code>estimate</code> method.</li>
</ul>
<ul>
<li>If the input model has MLE-style settings attached, I'll use them for the <code>estimate</code> method. Otherwise, I'll set my own.</li>
</ul>
<ul>
<li>If the parameter input has non-NaN values at the free parameters, then I'll use those as the starting point for any MLE search; the defaults for the variables without fixed values starts from <b>1</b> as usual.</li>
</ul>
<ul>
<li>I do check the <code>more</code> pointer of the <code>parameters</code> for additional pages and <code>NaN</code>s on those pages.</li>
</ul>
<p>Here is a sample program. It produces a few thousand draws from a Multivariate Normal distribution, and then tries to recover the means given a var/covar matrix fixed at the correct variance.</p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &lt;<a class="code" href="apop_8h.html">apop.h</a>&gt;</span>

<span class="keywordtype">int</span> main(){
    <span class="keywordtype">size_t</span> ct = 5e4;

    <span class="comment">//set up the model &amp; params</span>
    <a class="code" href="structapop__data.html">apop_data</a> *params = <a class="code" href="apop_8h.html#ac39d6a56933b6f084328ec5ecd5090d8">apop_data_alloc</a>(2,2,2);
    <a class="code" href="apop_8h.html#ad6be56d710a63aa1ceadf2242c553905">apop_data_fill</a>(params, 8,  1, 0.5,
                           2,  0.5, 1);
    <a class="code" href="structapop__model.html">apop_model</a> *pvm = <a class="code" href="group__models.html#ga87d3a65f43071b9d61d9edd59249c629">apop_model_copy</a>(<a class="code" href="group__models.html#ga3a4389e6e2a1a2ea606f89d55ec558d3">apop_multivariate_normal</a>);
    pvm-&gt;<a class="code" href="structapop__model.html#ae016a9e13725e84a1188bc81c8f09e45">parameters</a> = <a class="code" href="apop_8h.html#add67e6838ce2521a1d756894dc9b5ccf">apop_data_copy</a>(params);
    pvm-&gt;<a class="code" href="structapop__model.html#a5e31343782fe36a70e60e6d0808c64b5">dsize</a> = 2;
    <a class="code" href="structapop__data.html">apop_data</a> *d = <a class="code" href="apop_8h.html#a4e204cdc7429bef3ca2efb83453fe77a">apop_model_draws</a>(pvm, ct);

    <span class="comment">//set up and estimate a model with fixed covariance matrix but free means</span>
    gsl_vector_set_all(pvm-&gt;<a class="code" href="structapop__model.html#ae016a9e13725e84a1188bc81c8f09e45">parameters</a>-&gt;vector, GSL_NAN);
    <a class="code" href="structapop__model.html">apop_model</a> *mep1 = <a class="code" href="apop_8h.html#ab4f6ca7e042ac7c09c3c01d29702a739">apop_model_fix_params</a>(pvm);
    <a class="code" href="structapop__model.html">apop_model</a> *e1 = <a class="code" href="group__models.html#ga2c0598e5aca68949939a189bd4ce24ca">apop_estimate</a>(d, mep1);
    
    <span class="comment">//compare results, via assert for the test suite, or on-screen for human use.</span>
<span class="preprocessor">#ifdef Testing</span>
<span class="preprocessor"></span>    assert(<a class="code" href="group__convenience__fns.html#ga44a77f5e6867c627fd313f3f6e252ff8">apop_vector_distance</a>(params-&gt;vector, e1-&gt;<a class="code" href="structapop__model.html#ae016a9e13725e84a1188bc81c8f09e45">parameters</a>-&gt;vector)&lt;1e-2);
<span class="preprocessor">#else</span>
<span class="preprocessor"></span>    printf(<span class="stringliteral">&quot;original params: &quot;</span>);
    <a class="code" href="group__apop__print.html#ga8eafc3727869f5ec195809ad6686ba7b">apop_vector_show</a>(params-&gt;vector);
    printf(<span class="stringliteral">&quot;estimated params: &quot;</span>);
    <a class="code" href="group__apop__print.html#ga8eafc3727869f5ec195809ad6686ba7b">apop_vector_show</a>(e1-&gt;<a class="code" href="structapop__model.html#ae016a9e13725e84a1188bc81c8f09e45">parameters</a>-&gt;vector);
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>}
</pre></div><dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">model_in</td><td>The base model </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a model that can be used like any other, with the given params fixed or free. </dd></dl>

</div>
</div>
<a class="anchor" id="af676505faea1c7e30ffbd8690a092ed8"></a><!-- doxytag: member="apop.h::apop_model_fix_params_get_base" ref="af676505faea1c7e30ffbd8690a092ed8" args="(apop_model *model_in)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__model.html">apop_model</a>* <a class="el" href="apop__fix__params_8c.html#ae70ae98621cd8ee628d1a5d9c8e82111">apop_model_fix_params_get_base</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__model.html">apop_model</a> *&#160;</td>
          <td class="paramname"><em>fixed_model</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The <a class="el" href="apop__fix__params_8c.html#ab4f6ca7e042ac7c09c3c01d29702a739">apop_model_fix_params</a> function produces a model that has only the non-fixed parameters of the model. After estimation of the fixed-parameter model, this function fills the <code>parameters</code> element of the base model and returns a pointer to the base model. </p>

</div>
</div>
<a class="anchor" id="a1a55a20880947e289767aad6e5b0117c"></a><!-- doxytag: member="apop.h::apop_model_hessian" ref="a1a55a20880947e289767aad6e5b0117c" args="(apop_data *data, apop_model *model, double delta)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__data.html">apop_data</a>* <a class="el" href="apop__mle_8c.html#a1a55a20880947e289767aad6e5b0117c">apop_model_hessian</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structapop__model.html">apop_model</a> *&#160;</td>
          <td class="paramname"><em>model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>delta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Numerically estimate the matrix of second derivatives of the parameter values. The math is simply a series of re-evaluations at small differential steps. [Therefore, it may be expensive to do this for a very computationally-intensive model.]</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The data at which the model was estimated </td></tr>
    <tr><td class="paramname">model</td><td>The model, with parameters already estimated </td></tr>
    <tr><td class="paramname">delta</td><td>the step size for the differentials. The current default is around 1e-3. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The matrix of estimated second derivatives at the given data and parameter values.</dd></dl>
<ul>
<li>This function uses the <a class="el" href="designated.html">Designated initializers</a> syntax for inputs. </li>
</ul>

</div>
</div>
<a class="anchor" id="a1a6180e8caa773e287c1fce1bd78c061"></a><!-- doxytag: member="apop.h::apop_model_metropolis" ref="a1a6180e8caa773e287c1fce1bd78c061" args="(apop_data *d, apop_model *m, gsl_rng *rng)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__model.html">apop_model</a>* <a class="el" href="apop__update_8c.html#a1a6180e8caa773e287c1fce1bd78c061">apop_model_metropolis</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structapop__model.html">apop_model</a> *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsl_rng *&#160;</td>
          <td class="paramname"><em>rng</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Use <a href="https://en.wikipedia.org/wiki/Metropolis-Hastings">Metropolis-Hastings Markov chain Monte Carlo</a> to make draws from the given model.</p>
<p>Attach a <a class="el" href="structapop__mcmc__settings.html">apop_mcmc_settings</a> group to your model to specify the proposal distribution, burnin, and other details of the search. See the <a class="el" href="structapop__mcmc__settings.html">apop_mcmc_settings</a> documentation for details.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>The <a class="el" href="gentle.html#apop_data">apop_data</a> set used for evaluating the likelihood of a proposed parameter set.</td></tr>
    <tr><td class="paramname">m</td><td>The <a class="el" href="structapop__model.html">apop_model</a> from which parameters are being drawn. (No default; must not be <code>NULL</code>)</td></tr>
    <tr><td class="paramname">rng</td><td>A <code>gsl_rng</code>, probably allocated via <a class="el" href="group__convenience__fns.html#gada044cf02135422a9f9292b6054c86dd">apop_rng_alloc</a>. (Default: an RNG from <a class="el" href="apop_8h.html#a1e829ce2396bf05ab10460bcc37aeeab">apop_rng_get_thread</a>)</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>If the likelihood model no parameters, I will allocate them. That means you can use one of the stock models that ship with Apophenia. If I need to run the model's prep routine to get the size of the parameters, then I'll make a copy of the likelihood model, run prep, and then allocate parameters for that copy of a model.</li>
</ul>
<ul>
<li>Consider the state of the <code>parameters</code> element of your likelihood model to be undefined when this exits. This may be settled at a later date.</li>
</ul>
<ul>
<li>If you set <code>apop_opts.verbose=2</code> or greater, I will report the accept rate of the M-H sampler. It is a common rule of thumb to select a proposal so that this is between 20% and 50%. Set <code>apop_opts.verbose=3</code> to see the proposal points, their likelihoods, and the acceptance odds.</li>
</ul>
<dl class="return"><dt><b>Returns:</b></dt><dd>A modified <a class="el" href="group__models.html#gaca8f3323c57e0223a9f3c0f991c9760e">apop_pmf</a> model representing the results of the search. It has a specialized <code>draw</code> method that returns another step from the Markov chain with each draw. Each draw is also recorded internally.</dd></dl>
<ul>
<li>This function uses the <a class="el" href="designated.html">Designated initializers</a> syntax for inputs. </li>
</ul>

</div>
</div>
<a class="anchor" id="a0f2784b69175d1ecd3833d228d2294e7"></a><!-- doxytag: member="apop.h::apop_model_numerical_covariance" ref="a0f2784b69175d1ecd3833d228d2294e7" args="(apop_data *data, apop_model *model, double delta)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__data.html">apop_data</a>* <a class="el" href="apop__mle_8c.html#a0f2784b69175d1ecd3833d228d2294e7">apop_model_numerical_covariance</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structapop__model.html">apop_model</a> *&#160;</td>
          <td class="paramname"><em>model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>delta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Produce the covariance matrix for the parameters of an estimated model via the derivative of the score function at the parameter. I.e., I find the second derivative via <a class="el" href="apop__mle_8c.html#a1a55a20880947e289767aad6e5b0117c">apop_model_hessian</a> , and take the negation of the inverse.</p>
<p>I follow Efron and Hinkley in using the estimated information matrix---the value of the information matrix at the estimated value of the score---not the expected information matrix that is the integral over all possible data. See Pawitan 2001 (who cribbed a little off of Efron and Hinkley) or Klemens 2008 (who directly cribbed off of both) for further details.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The data by which your model was estimated </td></tr>
    <tr><td class="paramname">model</td><td>A model whose parameters have been estimated. </td></tr>
    <tr><td class="paramname">delta</td><td>The differential by which to step for sampling changes. (default currently = 1e-3) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A covariance matrix for the data. Also, if the data does not have a <code>"Covariance"</code> page, I'll set it to the result as well [i.e., I won't overwrite an existing covar].</dd></dl>
<p>This function uses the <a class="el" href="designated.html">Designated initializers</a> syntax for inputs. </p>

</div>
</div>
<a class="anchor" id="a2c76ad8792959b6605402a1d71a1b6c9"></a><!-- doxytag: member="apop.h::apop_multivariate_gamma" ref="a2c76ad8792959b6605402a1d71a1b6c9" args="(double a, int p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long double <a class="el" href="apop__stats_8c.html#a2c76ad8792959b6605402a1d71a1b6c9">apop_multivariate_gamma</a> </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The multivariate generalization of the Gamma distribution. </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \Gamma_p(a)= \pi^{p(p-1)/4}\prod_{j=1}^p \Gamma\left[ a+(1-j)/2\right]. \]" src="form_83.png"/>
</p>
<p>Because <img class="formulaInl" alt="$\Gamma(x)$" src="form_84.png"/> is undefined for <img class="formulaInl" alt="$x\in\{0, -1, -2, ...\}$" src="form_85.png"/>, this function returns <code>NAN</code> when <img class="formulaInl" alt="$a+(1-j)/2$" src="form_86.png"/> takes on one of those values.</p>
<p>See also <a class="el" href="apop__stats_8c.html#a180b231acc3c64d07664ed2b1a8ad0e1">apop_multivariate_lngamma</a>, which is more numerically stable in most cases. </p>

</div>
</div>
<a class="anchor" id="a180b231acc3c64d07664ed2b1a8ad0e1"></a><!-- doxytag: member="apop.h::apop_multivariate_lngamma" ref="a180b231acc3c64d07664ed2b1a8ad0e1" args="(double a, int p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long double <a class="el" href="apop__stats_8c.html#a180b231acc3c64d07664ed2b1a8ad0e1">apop_multivariate_lngamma</a> </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The log of the multivariate generalization of the Gamma; see also <a class="el" href="apop__stats_8c.html#a2c76ad8792959b6605402a1d71a1b6c9">apop_multivariate_gamma</a>. </p>

</div>
</div>
<a class="anchor" id="ae32d4f48cff7788b617d40155703ae64"></a><!-- doxytag: member="apop.h::apop_name_add" ref="ae32d4f48cff7788b617d40155703ae64" args="(apop_name *n, char const *add_me, char type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="apop__name_8c.html#ae32d4f48cff7788b617d40155703ae64">apop_name_add</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__name.html">apop_name</a> *&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>add_me</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Adds a name to the <a class="el" href="structapop__name.html">apop_name</a> structure. Puts it at the end of the given list.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>An existing, allocated <a class="el" href="structapop__name.html">apop_name</a> structure. </td></tr>
    <tr><td class="paramname">add_me</td><td>A string. If <code>NULL</code>, do nothing; return -1. </td></tr>
    <tr><td class="paramname">type</td><td>'r': add a row name<br/>
 'c': add a column name<br/>
 't': add a text category name<br/>
 'h': add a title (or a header. 't' is taken).<br/>
 'v': add (or overwrite) the vector name<br/>
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns the number of rows/cols/depvars after you have added the new one. But if <code>add_me</code> is <code>NULL</code>, return -1. </dd></dl>

</div>
</div>
<a class="anchor" id="a29ff289eb3d86e1ba5b06e5064a3286f"></a><!-- doxytag: member="apop.h::apop_name_alloc" ref="a29ff289eb3d86e1ba5b06e5064a3286f" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__name.html">apop_name</a>* <a class="el" href="apop__name_8c.html#a29ff289eb3d86e1ba5b06e5064a3286f">apop_name_alloc</a> </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Allocates a name structure </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>An allocated, empty name structure. In the very unlikely event that <code>malloc</code> fails, return <code>NULL</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="ad865208febeeb8cfce2f1d90e13db07a"></a><!-- doxytag: member="apop.h::apop_name_copy" ref="ad865208febeeb8cfce2f1d90e13db07a" args="(apop_name *in)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__name.html">apop_name</a>* <a class="el" href="apop__name_8c.html#ad865208febeeb8cfce2f1d90e13db07a">apop_name_copy</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__name.html">apop_name</a> *&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Copy one <a class="el" href="structapop__name.html">apop_name</a> structure to another. That is, all data is duplicated. Usage:</p>
<div class="fragment"><pre class="fragment"><a class="code" href="structapop__name.html">apop_name</a> *out  = <a class="code" href="apop_8h.html#ad865208febeeb8cfce2f1d90e13db07a">apop_name_copy</a>(in);
</pre></div><dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>the input names </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a structure that this function will allocate and fill </dd></dl>

</div>
</div>
<a class="anchor" id="adb1398925a93b7c2c502af8fb2abc49e"></a><!-- doxytag: member="apop.h::apop_name_find" ref="adb1398925a93b7c2c502af8fb2abc49e" args="(const apop_name *n, const char *findme, const char type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="apop__name_8c.html#ac1b94277b0055f11d00f6dd26cb70e00">apop_name_find</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structapop__name.html">apop_name</a> *&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Finds the position of an element in a list of names.</p>
<p>The function uses case-insensitive search (POSIX's <code>strcasecmp</code>).</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the <a class="el" href="structapop__name.html">apop_name</a> object to search. </td></tr>
    <tr><td class="paramname">name</td><td>the name you seek; see above. </td></tr>
    <tr><td class="paramname">type</td><td><code>'c'</code>, <code>'r'</code>, or <code>'t'</code>. Default is <code>'c'</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The position of <code>findme</code>. If <code>'c'</code>, then this may be -1, meaning the vector name. If not found, returns -2. On error, e.g. <code>name==NULL</code>, returns -2. </dd></dl>

</div>
</div>
<a class="anchor" id="a62a9c548fc646f28518bb1edb84dafc6"></a><!-- doxytag: member="apop.h::apop_name_free" ref="a62a9c548fc646f28518bb1edb84dafc6" args="(apop_name *free_me)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="apop__name_8c.html#a62a9c548fc646f28518bb1edb84dafc6">apop_name_free</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__name.html">apop_name</a> *&#160;</td>
          <td class="paramname"><em>free_me</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Erases an <a class="el" href="structapop__name.html">apop_name</a> structure. </p>

</div>
</div>
<a class="anchor" id="af7220e4b2fe43c56593af0ceb2c7001a"></a><!-- doxytag: member="apop.h::apop_name_print" ref="af7220e4b2fe43c56593af0ceb2c7001a" args="(apop_name *n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="apop__name_8c.html#af7220e4b2fe43c56593af0ceb2c7001a">apop_name_print</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__name.html">apop_name</a> *&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Prints the given list of names to STDOUT. Useful for debugging, and not much else. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The <a class="el" href="structapop__name.html">apop_name</a> structure </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab4fd369dba75ec4782400cf7378e56ec"></a><!-- doxytag: member="apop.h::apop_name_stack" ref="ab4fd369dba75ec4782400cf7378e56ec" args="(apop_name *n1, apop_name *nadd, char type1, char typeadd)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="apop__name_8c.html#ab4fd369dba75ec4782400cf7378e56ec">apop_name_stack</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__name.html">apop_name</a> *&#160;</td>
          <td class="paramname"><em>n1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structapop__name.html">apop_name</a> *&#160;</td>
          <td class="paramname"><em>nadd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>type1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>typeadd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Append one list of names to another.</p>
<p>Notice that if the first list is empty, then this is a copy function. If the second is <code>NULL</code>, it is a no-op.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">n1</td><td>The first set of names (no default, must not be <code>NULL</code>) </td></tr>
    <tr><td class="paramname">nadd</td><td>The second set of names, which will be appended after the first. (no default, if <code>NULL</code>, a no-op) </td></tr>
    <tr><td class="paramname">type1</td><td>Either 'c', 'r', 't', or 'v' stating whether you are merging the columns, rows, or text. If 'v', then ignore <code>typeadd</code> and just overwrite the target vector name with the source name. (default = 'r') </td></tr>
    <tr><td class="paramname">typeadd</td><td>Either 'c', 'r', 't', or 'v' stating whether you are merging the columns, rows, or text. If 'v', then overwrite the target with the source vector name. (default = type1) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac1bae5dffbbd4bc82c7369211c36f934"></a><!-- doxytag: member="apop.h::apop_rake" ref="ac1bae5dffbbd4bc82c7369211c36f934" args="(char const *margin_table, char *const *var_list, int var_ct, char const *all_vars, char *const *contrasts, int contrast_ct, char const *structural_zeros, int max_iterations, double tolerance, char const *count_col, int run_number, char const *init_table, char const *init_count_col, double nudge, char const *table_name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__data.html">apop_data</a>* <a class="el" href="apop_8h.html#ac1bae5dffbbd4bc82c7369211c36f934">apop_rake</a> </td>
          <td>(</td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>margin_table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *const *&#160;</td>
          <td class="paramname"><em>var_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>var_ct</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>all_vars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *const *&#160;</td>
          <td class="paramname"><em>contrasts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>contrast_ct</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>structural_zeros</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max_iterations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tolerance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>count_col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>run_number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>init_table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>init_count_col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>nudge</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>table_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Fit a log-linear model via iterative proportional fitting, aka raking.</p>
<p>Raking has many uses. The <a href="http://modelingwithdata.org/arch/00000138.htm">Modeling with Data blog</a> presents a series of discussions of uses of raking, including some worked examples.</p>
<p>Or see Wikipedia for an overview of Log linear models, aka <a href="http://en.wikipedia.org/wiki/Poisson_regression">Poisson regressions</a>. One approach toward log-linear modeling is a regression form; let there be four categories, A, B, C, and D, from which we can produce a model positing, for example, that cell count is a function of a form like <img class="formulaInl" alt="$g_1(A) + g_2(BC) + g_3(CD)$" src="form_45.png"/>. In this case, we would assign a separate coefficient to every possible value of A, every possible value of (B, C), and every value of (C, D). Raking is the technique that searches for that large set of parameters.</p>
<p>The combinations of categories that are considered to be relevant are called <em>contrasts</em>, after ANOVA terminology of the 1940s.</p>
<p>The other constraint on the search are structural zeros, which are values that you know can never be non-zero, due to field-specific facts about the variables. For example, U.S. Social Security payments are available only to those age 65 or older, so "age &lt;65 and
gets_soc_security=1" is a structural zero.</p>
<p>Because there is one parameter for every combination, there may be millions of parameters to estimate, so the search to find the most likely value requires some attention to technique. For over half a century, the consensus method for searching has been raking, which iteratively draws each category closer to the mean in a somewhat simple manner (this was first developed circa 1940 and had to be feasible by hand), but which is guaranteed to eventually arrive at the maximum likelihood estimate for all cells.</p>
<p>Another complication is that the table is invariably sparse. One can easily construct tables with millions of cells, but the corresponding data set may have only a few thousand observations.</p>
<p>This function uses the database to resolve the sparseness problem. It constructs a query requesting all combinations of categories the could possibly be non-zero after raking, given all of the above constraints. Then, raking is done using only that subset. This means that the work is done on a number of cells proportional to the number of data points, not to the full cross of all categories. Set <code>apop_opts.verbose</code> to 2 or greater to show the query on <code>stderr</code>.</p>
<ul>
<li>One could use raking to generate `fully synthetic' data: start with observation-level data in a margin table. Begin the raking with a starting data set of all-ones. Then rake until the all-ones set transforms into something that conforms to the margins and (if any) structural zeros. You now have a data set which matches the marginal totals but does not use any other information from the observation-level data. If you do not specify an <code>.init_table</code>, then an all-ones default table will be used.</li>
</ul>
<ul>
<li>Set <code>apop_opts.verbose=3</code> to see the intermediate tables at the end of each round of raking.</li>
</ul>
<ul>
<li>If you want all cells to have nonzero value, then you can do that via pre-processing: <div class="fragment"><pre class="fragment"><a class="code" href="group__queries.html#ga236452b3305ea7b791c781d91a819e3b">apop_query</a>(<span class="stringliteral">&quot;update data_table set count_col = 1e-3 where count_col = 0&quot;</span>);
</pre></div></li>
</ul>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">margin_table</td><td>The name of the table in the database to use for calculating the margins. The table should have one observation per row. No default. (This used to be called <code>table_name</code>; that name is now deprecated.)</td></tr>
    <tr><td class="paramname">var_list</td><td>The full list of variables to search. A list of strings, e.g., <code>(char *[]){"var1", "var2", ..., "var15"}</code></td></tr>
    <tr><td class="paramname">var_ct</td><td>The count of the full list of variables to search.</td></tr>
    <tr><td class="paramname">all_vars</td><td>deprecated.</td></tr>
    <tr><td class="paramname">contrasts</td><td>The contrasts describing your model. Like the <code>all_vars</code> input, each contrast is a pipe-delimited list of variable names. No default.</td></tr>
    <tr><td class="paramname">contrast_ct</td><td>The number of contrasts in the list of contrasts. No default.</td></tr>
    <tr><td class="paramname">structural_zeros</td><td>a SQL clause indicating combinations that can never take a nonzero value. This will go into a <code>where</code> clause, so anything you could put there is OK, e.g. "age &lt;65 and gets_soc_security=1 or age &lt;15 and married=1". Your margin data is not checked for structural zeros. Default: no structural zeros.</td></tr>
    <tr><td class="paramname">max_iterations</td><td>Number of rounds of raking at which the algorithm halts. Default: 1000.</td></tr>
    <tr><td class="paramname">tolerance</td><td>I calculate the change for each cell from round to round; if the largest cell change is smaller than this, I stop. Default: 1e-5.</td></tr>
    <tr><td class="paramname">count_col</td><td>This column gives the count of how many observations are represented by each row. If <code>NULL</code>, ech row represents one person. Default: <code>NULL</code>.</td></tr>
    <tr><td class="paramname">run_number</td><td>Because I write intermediate tables to the database, I need a way to distinguish distinct runs should you be threading several runs at once. If you aren't running several instances simultaneously, don't worry about this; if you are, do supply a value, since it's hard for the function to supply one in a race-proof manner. Default: internally-maintained values.</td></tr>
    <tr><td class="paramname">init_table</td><td>The default is to initially set all table elements to one and then rake from there. This is effectively the `fully synthetic' approach, which uses only the information in the margins and derives the data set closest to the all-ones data set that is consistent with the margins. Care is taken to maintan sparsity in this case. If you specify an <code>init_table</code>, then I will get the initial cell counts from it. Default: the fully-synthetic approach, using a starting point of an all-ones grid.</td></tr>
    <tr><td class="paramname">init_count_col</td><td>The column in <code>init_table</code> with the cell counts.</td></tr>
    <tr><td class="paramname">nudge</td><td>There is a common hack of adding a small value to every zero entry, because a zero entry will always scale to zero, while a small value could eventually scale to anything. Recall that this function works on sparse sets, so I first filter out those cells that could possibly have a nonzero value given the observations, then I add <code>nudge</code> to any zero cells within that subset.</td></tr>
    <tr><td class="paramname">table_name</td><td>Deprecated; replaced with <code>margin_table</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>An <a class="el" href="gentle.html#apop_data">apop_data</a> set where every row is a single combination of variable values and the <code>weights</code> vector gives the most likely value for each cell. </dd></dl>
<dl class="exception"><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">out-&gt;error='i'</td><td>Input was somehow wrong. </td></tr>
    <tr><td class="paramname">out-&gt;error='c'</td><td>Raking did not converge, reached max. iteration count. <ul>
<li>This function uses the <a class="el" href="designated.html">Designated initializers</a> syntax for inputs.</li>
</ul>
<ul>
<li>The interface is still beta, and subject to change---notably, handling of text categories will soon be added. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa9ec5e7ed223c09bec044ced54f24fad"></a><!-- doxytag: member="apop.h::apop_regex" ref="aa9ec5e7ed223c09bec044ced54f24fad" args="(const char *string, const char *regex, apop_data **substrings, const char use_case)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="apop__asst_8c.html#aa9ec5e7ed223c09bec044ced54f24fad">apop_regex</a> </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>regex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structapop__data.html">apop_data</a> **&#160;</td>
          <td class="paramname"><em>substrings</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>use_case</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>A convenience function for regular expression searching</p>
<ul>
<li>There are three common flavors of regular expression: Basic, Extended, and Perl-compatible (BRE, ERE, PCRE). I use EREs, as per the specs of your C library, which should match POSIX's ERE specification.</li>
</ul>
<p>For example, "p.val" will match "P value", "p.value", "p values" (and even "tempeval", so be careful).</p>
<p>If you give a non-<code>NULL</code> address in which to place a table of paren-delimited substrings, I'll return them as a row in the text element of the returned <a class="el" href="gentle.html#apop_data">apop_data</a> set. I'll return <em>all</em> the matches, filling the first row with substrings from the first application of your regex, then filling the next row with another set of matches (if any), and so on to the end of the string. Useful when parsing a list of items, for example.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">string</td><td>The string to search (no default) </td></tr>
    <tr><td class="paramname">regex</td><td>The regular expression (no default) </td></tr>
    <tr><td class="paramname">substrings</td><td>Parens in the regex indicate that I should return matching substrings. Give me the _address_ of an <a class="el" href="gentle.html#apop_data">apop_data</a>* set, and I will allocate and fill the text portion with matches. Default= <code>NULL</code>, meaning do not return substrings (even if parens exist in the regex). If no match, return an empty <a class="el" href="gentle.html#apop_data">apop_data</a> set, so <code>output-&gt;textsize[0]==0</code>. </td></tr>
    <tr><td class="paramname">use_case</td><td>Should I be case sensitive, <code>'y'</code> or <code>'n'</code>? (default = <code>'n'</code>, which is not the POSIX default.)</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Count of matches found. 0 == no match. <code>substrings</code> may be allocated and filled if needed.</dd></dl>
<ul>
<li>If <code>apop_opts.stop_on_warning='n'</code> returns -1 on error (e.g., regex <code>NULL</code> or didn't compile). </li>
<li>If <code>strings==NULL</code>, I return 0---no match---and if <code>substrings</code> is provided, set it to <code>NULL</code>.</li>
</ul>
<ul>
<li>Here is the test function. Notice that the substring-pulling function call passes <code>&amp;subs</code>, not plain <code>subs</code>. Also, the non-match has a zero-length blank in <code>subs-&gt;text[0][1]</code>.</li>
</ul>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &lt;<a class="code" href="apop_8h.html">apop.h</a>&gt;</span>
<span class="keywordtype">int</span> main(){
    <span class="keywordtype">char</span> string1[] = <span class="stringliteral">&quot;Hello. I am a string.&quot;</span>;
    assert(<a class="code" href="apop_8h.html#aa9ec5e7ed223c09bec044ced54f24fad">apop_regex</a>(string1, <span class="stringliteral">&quot;hell&quot;</span>));
    <a class="code" href="structapop__data.html">apop_data</a> *subs;
    <a class="code" href="apop_8h.html#aa9ec5e7ed223c09bec044ced54f24fad">apop_regex</a>(string1, <span class="stringliteral">&quot;(e).*I.*(xxx)*(am)&quot;</span>, .substrings = &amp;subs);
    <span class="comment">//apop_data_show(subs);</span>
    assert(!strcmp(subs-&gt;text[0][0], <span class="stringliteral">&quot;e&quot;</span>));
    assert(!strlen(subs-&gt;text[0][1]));
    assert(!strcmp(subs-&gt;text[0][2], <span class="stringliteral">&quot;am&quot;</span>));
    <a class="code" href="apop_8h.html#a459acfde11f2c39f5c32cff377f85b9e">apop_data_free</a>(subs);

    <span class="comment">//Split a comma-delimited list, throwing out white space.</span>
    <span class="comment">//Notice that the regex includes only one instance of a non-comma blob </span>
    <span class="comment">//ending in a non-space followed by a comma, but the function keeps </span>
    <span class="comment">//applying it until the end of string.</span>
    <span class="keywordtype">char</span> string2[] = <span class="stringliteral">&quot; one, two , three ,four&quot;</span>;
    <a class="code" href="apop_8h.html#aa9ec5e7ed223c09bec044ced54f24fad">apop_regex</a>(string2, <span class="stringliteral">&quot; *([^,]*[^ ]) *(,|$) *&quot;</span>, &amp;subs);
    assert(!strcmp(*subs-&gt;text[0], <span class="stringliteral">&quot;one&quot;</span>));
    assert(!strcmp(*subs-&gt;text[1], <span class="stringliteral">&quot;two&quot;</span>));
    assert(!strcmp(*subs-&gt;text[2], <span class="stringliteral">&quot;three&quot;</span>));
    assert(!strcmp(*subs-&gt;text[3], <span class="stringliteral">&quot;four&quot;</span>));
    <a class="code" href="apop_8h.html#a459acfde11f2c39f5c32cff377f85b9e">apop_data_free</a>(subs);

    <span class="comment">//Get a parenthetical. For EREs, \( \) match plain parens in the text.</span>
    <span class="keywordtype">char</span> string3[] = <span class="stringliteral">&quot; one (but secretly, two)&quot;</span>;
    <a class="code" href="apop_8h.html#aa9ec5e7ed223c09bec044ced54f24fad">apop_regex</a>(string3, <span class="stringliteral">&quot;(\\([^)]*\\))&quot;</span>, &amp;subs);
    assert(!strcmp(*subs-&gt;text[0], <span class="stringliteral">&quot;(but secretly, two)&quot;</span>));
    <a class="code" href="apop_8h.html#a459acfde11f2c39f5c32cff377f85b9e">apop_data_free</a>(subs);

    <span class="comment">//NULL input string ==&gt; no-op.</span>
    <span class="keywordtype">int</span> match_count = <a class="code" href="apop_8h.html#aa9ec5e7ed223c09bec044ced54f24fad">apop_regex</a>(NULL, <span class="stringliteral">&quot; *([^,]*[^ ]) *(,|$) *&quot;</span>, &amp;subs);
    assert(!match_count);
    assert(!subs);
}
</pre></div><ul>
<li>Each set of matches will be one row of the output data. E.g., given the regex <code>([A-Za-z])([0-9])</code>, the column zero of <code>outdata</code> will hold letters, and column one will hold numbers. Use <a class="el" href="apop__data_8c.html#a82281b8673cda3645054d7e061bb1167">apop_data_transpose</a> to reverse this so that the letters are in <code>outdata-&gt;text[0]</code> and numbers in <code>outdata-&gt;text[1]</code>. </li>
</ul>

</div>
</div>
<a class="anchor" id="aaf0d5d65f514d9894a4ca5b0e8755873"></a><!-- doxytag: member="apop.h::apop_rng_GHgB3" ref="aaf0d5d65f514d9894a4ca5b0e8755873" args="(gsl_rng *r, double *a)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="apop__asst_8c.html#aaf0d5d65f514d9894a4ca5b0e8755873">apop_rng_GHgB3</a> </td>
          <td>(</td>
          <td class="paramtype">gsl_rng *&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>RNG from a Generalized Hypergeometric type B3.</p>
<p>Devroye uses this as the base for many of his distribution-generators, including the Waring.</p>
<ul>
<li>If one of the inputs is &lt;=0, error. Returns <code>GSL_NAN</code> if the function doesn't stop. </li>
</ul>

</div>
</div>
<a class="anchor" id="a0dc44b7dfc3c125d19c1db3bef3a80a1"></a><!-- doxytag: member="apop.h::apop_settings_copy_group" ref="a0dc44b7dfc3c125d19c1db3bef3a80a1" args="(apop_model *outm, apop_model *inm, char *copyme)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="apop__settings_8c.html#a0dc44b7dfc3c125d19c1db3bef3a80a1">apop_settings_copy_group</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__model.html">apop_model</a> *&#160;</td>
          <td class="paramname"><em>outm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structapop__model.html">apop_model</a> *&#160;</td>
          <td class="paramname"><em>inm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>copyme</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Copy a settings group with the given name from the second model to the first. (i.e., the arguments are in memcpy order).</p>
<p>You probably won't need this often---just use <a class="el" href="group__models.html#ga87d3a65f43071b9d61d9edd59249c629">apop_model_copy</a>.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">outm</td><td>The model that will receive a copy of the settings group. </td></tr>
    <tr><td class="paramname">inm</td><td>The model that will provide the original. </td></tr>
    <tr><td class="paramname">copyme</td><td>The string naming the group. For example, for an <a class="el" href="structapop__mcmc__settings.html">apop_mcmc_settings</a> group, this would be <code>"apop_mcmc"</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">outm-&gt;error=='s'</td><td>Error copying settings group. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a01d501ca84ade92bc72fd4f67a617f64"></a><!-- doxytag: member="apop.h::apop_table_exists" ref="a01d501ca84ade92bc72fd4f67a617f64" args="(char const *name, char remove)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="apop__db_8c.html#a01d501ca84ade92bc72fd4f67a617f64">apop_table_exists</a> </td>
          <td>(</td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>remove</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Check for the existence of a table, and maybe delete it.</p>
<p>Recreating a table which already exists can cause errors, so it is good practice to check for existence first. Also, this is the stylish way to delete a table, since just calling <code>"drop table"</code> will give you an error if the table doesn't exist.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>the table name (no default) </td></tr>
    <tr><td class="paramname">remove</td><td>'d' ==&gt;delete table so it can be recreated in main.<br/>
 'n' ==&gt;no action. Return result so program can continue. (default) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 = table does not exist<br/>
 1 = table was found, and if remove=='d', has been deleted</dd></dl>
<ul>
<li>In the SQLite engine, this function considers table views to be tables.</li>
</ul>
<ul>
<li>If <code>apop_opts.stop_on_warn='n'</code>, returns -1 on errors.</li>
</ul>
<ul>
<li>This function uses the <a class="el" href="designated.html">Designated initializers</a> syntax for inputs. </li>
</ul>

</div>
</div>
<a class="anchor" id="a650d1ecf6f78c3bdb85c8fce71dfae05"></a><!-- doxytag: member="apop.h::apop_test" ref="a650d1ecf6f78c3bdb85c8fce71dfae05" args="(double statistic, char *distribution, double p1, double p2, char tail)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="apop__tests_8c.html#a650d1ecf6f78c3bdb85c8fce71dfae05">apop_test</a> </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>statistic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>distribution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>p2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>tail</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This is a convenience function to do the lookup of a given statistic along a given distribution. You give me a statistic, its (hypothesized) distribution, and whether to use the upper tail, lower tail, or both. I will return the odds of a Type I error given the model---in statistician jargon, the <img class="formulaInl" alt="$p$" src="form_20.png"/>-value. [Type I error: odds of rejecting the null hypothesis when it is true.]</p>
<p>For example, </p>
<div class="fragment"><pre class="fragment">   <a class="code" href="apop_8h.html#a650d1ecf6f78c3bdb85c8fce71dfae05">apop_test</a>(1.3);
</pre></div><p>will return the density of the standard Normal distribution that is more than 1.3 from zero. If this function returns a small value, we can be confident that the statistic is significant. Or, </p>
<div class="fragment"><pre class="fragment">   <a class="code" href="apop_8h.html#a650d1ecf6f78c3bdb85c8fce71dfae05">apop_test</a>(1.3, <span class="stringliteral">&quot;t&quot;</span>, 10, tail=<span class="charliteral">&#39;u&#39;</span>);
</pre></div><p>will give the appropriate odds for an upper-tailed test using the <img class="formulaInl" alt="$t$" src="form_11.png"/>-distribution with 10 degrees of freedom (e.g., a <img class="formulaInl" alt="$t$" src="form_11.png"/>-test of the null hypothesis that the statistic is less than or equal to zero).</p>
<p>Several more distributions are supported; see below.</p>
<ul>
<li>For a two-tailed test (the default), this returns the density outside the range. I'll only do this for symmetric distributions. </li>
<li>For an upper-tail test ('u'), this returns the density above the cutoff </li>
<li>For a lower-tail test ('l'), this returns the density below the cutoff</li>
</ul>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">statistic</td><td>The scalar value to be tested. </td></tr>
    <tr><td class="paramname">distribution</td><td>The name of the distribution; see below. </td></tr>
    <tr><td class="paramname">p1</td><td>The first parameter for the distribution; see below. </td></tr>
    <tr><td class="paramname">p2</td><td>The second parameter for the distribution; see below. </td></tr>
    <tr><td class="paramname">tail</td><td>'u' = upper tail; 'l' = lower tail; anything else = two-tailed. (default = two-tailed)</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The odds of a Type I error given the model (the <img class="formulaInl" alt="$p$" src="form_20.png"/>-value).</dd></dl>
<p>Here is a list of distributions you can use, and their parameters.</p>
<p><code>"normal"</code> or <code>"gaussian"</code> </p>
<ul>
<li>p1=mu, p2=sigma </li>
<li>default (0, 1)</li>
</ul>
<p><code>"lognormal"</code> </p>
<ul>
<li>p1=mu, p2=sigma </li>
<li>default (0, 1) </li>
<li>Remember, mu and sigma refer to the Normal one would get after exponentiation </li>
<li>One-tailed tests only</li>
</ul>
<p><code>"uniform"</code> </p>
<ul>
<li>p1=lower edge, p2=upper edge </li>
<li>default (0, 1) </li>
<li>two-tailed tests are run relative to the center, (p1+p2)/2.</li>
</ul>
<p><code>"t"</code> </p>
<ul>
<li>p1=df </li>
<li>no default</li>
</ul>
<p><code>"chi squared"</code>, <code>"chi"</code>, <code>"chisq"</code>: </p>
<ul>
<li>p1=df </li>
<li>no default </li>
<li>One-tailed tests only; default='u' ( <img class="formulaInl" alt="$p$" src="form_20.png"/>-value for typical cases)</li>
</ul>
<p><code>"f"</code> </p>
<ul>
<li>p1=df1, p2=df2 </li>
<li>no default </li>
<li>One-tailed tests only</li>
</ul>
<ul>
<li>This function uses the <a class="el" href="designated.html">Designated initializers</a> syntax for inputs. </li>
</ul>

</div>
</div>
<a class="anchor" id="a8627a1eebf904699e90e66adc8b4b021"></a><!-- doxytag: member="apop.h::apop_test_fisher_exact" ref="a8627a1eebf904699e90e66adc8b4b021" args="(apop_data *intab)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__data.html">apop_data</a>* <a class="el" href="apop__fexact_8c.html#a8627a1eebf904699e90e66adc8b4b021">apop_test_fisher_exact</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>intab</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Run the Fisher exact test on an input contingency table.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>An <a class="el" href="gentle.html#apop_data">apop_data</a> set with two rows:<br/>
 "probability of table": Probability of the observed table for fixed marginal totals. <br/>
 "p value": Table p-value. The probability of a more extreme table, where `extreme' is in a probabilistic sense. </dd></dl>
<dl class="exception"><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">out-&gt;error=='p'</td><td>Processing error in the test.</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>If there are processing errors, these values will be NaN. For example:</li>
</ul>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &lt;<a class="code" href="apop_8h.html">apop.h</a>&gt;</span>

<span class="keywordtype">int</span> main() {
    <span class="comment">/* This test is thanks to Nick Eriksson, who sent it to me in the form of a bug report. */</span>
    <a class="code" href="structapop__data.html">apop_data</a> * testdata = <a class="code" href="apop_8h.html#acb6b2c53478f9db902ba0340ba499819">apop_data_falloc</a>((2, 3),
                              30, 50, 45, 
                              34, 12, 17 );
    <a class="code" href="structapop__data.html">apop_data</a> * t2 = <a class="code" href="apop_8h.html#a8627a1eebf904699e90e66adc8b4b021">apop_test_fisher_exact</a>(testdata);
    assert(fabs(<a class="code" href="group__data__set__get.html#ga06107779e4a3eb229715ceca24352b89">apop_data_get</a>(t2,1) - 0.0001761) &lt; 1e-6);
}
</pre></div> 
</div>
</div>
<a class="anchor" id="ac9c6f645acce82319fb85eb9d75112ba"></a><!-- doxytag: member="apop.h::apop_text_add" ref="ac9c6f645acce82319fb85eb9d75112ba" args="(apop_data *in, const size_t row, const size_t col, const char *fmt,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="apop__data_8c.html#ac9c6f645acce82319fb85eb9d75112ba">apop_text_add</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Add a string to the text element of an <a class="el" href="gentle.html#apop_data">apop_data</a> set. If you send me a <code>NULL</code> string, I will write the value of <code>apop_opts.nan_string</code> in the given slot. If there is already something in that slot, that string is freed, preventing memory leaks.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>The <a class="el" href="gentle.html#apop_data">apop_data</a> set, that already has an allocated <code>text</code> element. </td></tr>
    <tr><td class="paramname">row</td><td>The row </td></tr>
    <tr><td class="paramname">col</td><td>The col </td></tr>
    <tr><td class="paramname">fmt</td><td>The text to write. </td></tr>
    <tr><td class="paramname">...</td><td>You can use a printf-style fmt and follow it with the usual variables to fill in.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0=OK, -1=error (probably out-of-bounds)</dd></dl>
<ul>
<li>UTF-8 or ASCII text is correctly handled. </li>
<li>Apophenia follows a general rule of not reallocating behind your back: if your text matrix is currently of size (3,3) and you try to put an item in slot (4,4), then I display an error rather than reallocating the text matrix. </li>
<li>Resizing a text matrix is annoying in C, so note that <a class="el" href="apop__data_8c.html#a9fba0f07c262a433133f6f3362617da3">apop_text_alloc</a> will reallocate to a new size if you need. For example, this code will fill the diagonals of the text array with a message, resizing as it goes: </li>
<li>The string added is a copy (via <code>asprintf</code>), not a pointer to the input(s). </li>
<li>If there had been a string at the grid point you are writing to, the old one is effectively lost when the new one is placed. So, I free the old string to prevent leaks if necessary. Remember this if you had other pointers aliasing that string, in which case you may as well avoid this function and just use <code> asprintf(&amp;(your_dataset-&gt;text[row][col]), "your string")</code>.</li>
</ul>
<div class="fragment"><pre class="fragment"><a class="code" href="structapop__data.html">apop_data</a> *list = (something already allocated.);
<span class="keywordflow">for</span> (<span class="keywordtype">int</span> n=0; n &lt; 10; n++){
    <a class="code" href="apop_8h.html#a9fba0f07c262a433133f6f3362617da3">apop_text_alloc</a>(list, n+1, n+1);
    <a class="code" href="apop_8h.html#ac9c6f645acce82319fb85eb9d75112ba">apop_text_add</a>(list, n, n, <span class="stringliteral">&quot;This is cell (%i, %i)&quot;</span>, n, n);
}
</pre></div> 
</div>
</div>
<a class="anchor" id="a9fba0f07c262a433133f6f3362617da3"></a><!-- doxytag: member="apop.h::apop_text_alloc" ref="a9fba0f07c262a433133f6f3362617da3" args="(apop_data *in, const size_t row, const size_t col)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__data.html">apop_data</a>* <a class="el" href="apop__data_8c.html#a9fba0f07c262a433133f6f3362617da3">apop_text_alloc</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>col</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This allocates an array of strings and puts it in the <code>text</code> element of an <a class="el" href="gentle.html#apop_data">apop_data</a> set.</p>
<p>If the <code>text</code> element already exists, then this is effectively a <code>realloc</code> function, reshaping to the size you specify.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>An <a class="el" href="gentle.html#apop_data">apop_data</a> set. It's OK to send in <code>NULL</code>, in which case an <a class="el" href="structapop__data.html">apop_data</a> set with <code>NULL</code> <code>matrix</code> and <code>vector</code> elements is returned. </td></tr>
    <tr><td class="paramname">row</td><td>the number of rows of text. </td></tr>
    <tr><td class="paramname">col</td><td>the number of columns of text. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A pointer to the relevant <a class="el" href="gentle.html#apop_data">apop_data</a> set. If the input was not <code>NULL</code>, then this is a repeat of the input pointer. </dd></dl>
<dl class="exception"><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">out-&gt;error=='a'</td><td>Allocation error. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a65386d7b37c2eaf37d1eb4e3ae7a7554"></a><!-- doxytag: member="apop.h::apop_text_free" ref="a65386d7b37c2eaf37d1eb4e3ae7a7554" args="(char ***freeme, int rows, int cols)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="apop__data_8c.html#a65386d7b37c2eaf37d1eb4e3ae7a7554">apop_text_free</a> </td>
          <td>(</td>
          <td class="paramtype">char ***&#160;</td>
          <td class="paramname"><em>freeme</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>cols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Free a matrix of chars* (i.e., a char***). This is the form of the text element of the <a class="el" href="gentle.html#apop_data">apop_data</a> set, so you can use this for: </p>
<div class="fragment"><pre class="fragment"> <a class="code" href="apop_8h.html#a65386d7b37c2eaf37d1eb4e3ae7a7554">apop_text_free</a>(yourdata-&gt;text, yourdata-&gt;textsize[0], yourdata-&gt;textsize[1]);
</pre></div><p> This is what <code>apop_data_free</code> uses internally. </p>

</div>
</div>
<a class="anchor" id="a6270ad55c566140e0d7962cb4d5daacc"></a><!-- doxytag: member="apop.h::apop_text_paste" ref="a6270ad55c566140e0d7962cb4d5daacc" args="(apop_data const *strings, char *between, char *before, char *after, char *between_cols, int(*prune)(apop_data *, int, int, void *), void *prune_parameter)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* <a class="el" href="apop__asst_8c.html#a28097fab95794bb0146de61f8461b843">apop_text_paste</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__data.html">apop_data</a> const *&#160;</td>
          <td class="paramname"><em>strings</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>between</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>before</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>after</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>between_cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apop_fn_riip&#160;</td>
          <td class="paramname"><em>prune</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>prune_parameter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Join together a list or array of strings, with optional separators between the strings.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">strings</td><td>An <a class="el" href="gentle.html#apop_data">apop_data</a> set with a grid of text to be combined into a single string </td></tr>
    <tr><td class="paramname">between</td><td>The text to put in between the rows of the table, such as ", ". (Default is a single space: " ") </td></tr>
    <tr><td class="paramname">before</td><td>The text to put at the head of the string. For the query example, this would be <code>.before="select "</code>. (Default: NULL) </td></tr>
    <tr><td class="paramname">after</td><td>The text to put at the tail of the string. For the query example, <code>.after=" from data_table"</code>. (Default: NULL) </td></tr>
    <tr><td class="paramname">between_cols</td><td>The text to insert between columns of text. See below for an example (Default is set to equal <code>.between</code>) </td></tr>
    <tr><td class="paramname">prune</td><td>If you don't want to use the entire text set, you can provide a function to indicate which elements should be pruned out. Some examples:</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><pre class="fragment"><span class="comment">//Just use column 3</span>
<span class="keywordtype">int</span> is_not_col_3(<a class="code" href="structapop__data.html">apop_data</a> *indata, <span class="keywordtype">int</span> row, <span class="keywordtype">int</span> col, <span class="keywordtype">void</span> *ignore){
    <span class="keywordflow">return</span> col!=3;
}

<span class="comment">//Jump over blanks as if they don&#39;t exist.</span>
<span class="keywordtype">int</span> is_blank(<a class="code" href="structapop__data.html">apop_data</a> *indata, <span class="keywordtype">int</span> row, <span class="keywordtype">int</span> col, <span class="keywordtype">void</span> *ignore){
    <span class="keywordflow">return</span> strlen(indata-&gt;text[row][col])==0;
}
</pre></div><dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">prune_parameter</td><td>A void pointer to pass to your <code>prune</code> function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A single string with the elements of the <code>strings</code> table joined as per your specification. Allocated by the function, to be freed by you if desired.</dd></dl>
<ul>
<li>If the table of strings is <code>NULL</code> or has no text, I will print only the <code>.before</code> and <code>.after</code> parts with nothing in between. </li>
<li>if <code> apop_opts.verbose &gt;=3</code>, then print the pasted text to stderr. </li>
<li>This function uses the <a class="el" href="designated.html">Designated initializers</a> syntax for inputs.</li>
</ul>
<p>The sample snippet generates the SQL for a query using a list of column names (where the query begins with <code>select </code>, ends with <code>from datatab</code>, and has commas in between each element), re-processes the same list to produce the head of an HTML table, then produces the body of the table with the query result (pasting the <code>tr</code>s and <code> td</code>s into the right places).</p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &lt;<a class="code" href="apop_8h.html">apop.h</a>&gt;</span>

<span class="keywordtype">int</span> main(){
    <a class="code" href="group__queries.html#ga236452b3305ea7b791c781d91a819e3b">apop_query</a>(<span class="stringliteral">&quot;create table datatab(name, age, sex);&quot;</span>
                <span class="stringliteral">&quot;insert into datatab values (&#39;Alex&#39;, 23, &#39;m&#39;);&quot;</span>
                <span class="stringliteral">&quot;insert into datatab values (&#39;Alex&#39;, 32, &#39;f&#39;);&quot;</span>
                <span class="stringliteral">&quot;insert into datatab values (&#39;Michael&#39;, 41, &#39;f&#39;);&quot;</span>
                <span class="stringliteral">&quot;insert into datatab values (&#39;Michael&#39;, 14, &#39;m&#39;);&quot;</span>);

    <a class="code" href="structapop__data.html">apop_data</a> *cols = <a class="code" href="apop_8h.html#a9fba0f07c262a433133f6f3362617da3">apop_text_alloc</a>(NULL, 3, 1);
    <a class="code" href="apop_8h.html#ac9c6f645acce82319fb85eb9d75112ba">apop_text_add</a>(cols, 0, 0, <span class="stringliteral">&quot;name&quot;</span>);
    <a class="code" href="apop_8h.html#ac9c6f645acce82319fb85eb9d75112ba">apop_text_add</a>(cols, 1, 0, <span class="stringliteral">&quot;age&quot;</span>);
    <a class="code" href="apop_8h.html#ac9c6f645acce82319fb85eb9d75112ba">apop_text_add</a>(cols, 2, 0, <span class="stringliteral">&quot;sex&quot;</span>);
    <span class="keywordtype">char</span> *query= <a class="code" href="apop_8h.html#a6270ad55c566140e0d7962cb4d5daacc">apop_text_paste</a>(cols, .before=<span class="stringliteral">&quot;select &quot;</span>, .between=<span class="stringliteral">&quot;, &quot;</span>);
    <a class="code" href="structapop__data.html">apop_data</a> *d = <a class="code" href="group__queries.html#ga2fbd580cd71f481ae04ee03b5cf64ff5">apop_query_to_text</a>(<span class="stringliteral">&quot;%s from datatab&quot;</span>, query);
    <span class="keywordtype">char</span> *html_head = <a class="code" href="apop_8h.html#a6270ad55c566140e0d7962cb4d5daacc">apop_text_paste</a>(cols, .before=<span class="stringliteral">&quot;&lt;table&gt;&lt;tr&gt;&lt;td&gt;&quot;</span>,
                                .between=<span class="stringliteral">&quot;&lt;/td&gt;&lt;td&gt;&quot;</span>, .after=<span class="stringliteral">&quot;&lt;/tr&gt;\n&lt;tr&gt;&lt;td&gt;&quot;</span>);
    <span class="keywordtype">char</span> *html_table = <a class="code" href="apop_8h.html#a6270ad55c566140e0d7962cb4d5daacc">apop_text_paste</a>(d, .before=html_head, .after=<span class="stringliteral">&quot;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;\n&quot;</span>,
                                .between=<span class="stringliteral">&quot;&lt;/tr&gt;\n&lt;tr&gt;&lt;td&gt;&quot;</span>, .between_cols=<span class="stringliteral">&quot;&lt;/td&gt;&lt;td&gt;&quot;</span>);
    FILE *outfile = fopen(<span class="stringliteral">&quot;yourdata.html&quot;</span>, <span class="stringliteral">&quot;w&quot;</span>);                                                                                                                              fprintf(outfile, <span class="stringliteral">&quot;%s&quot;</span>, html_table);
    fclose(outfile);
}
</pre></div> 
</div>
</div>
<a class="anchor" id="a77c937ea4764d3da2ed9968273fa4544"></a><!-- doxytag: member="apop.h::apop_text_unique_elements" ref="a77c937ea4764d3da2ed9968273fa4544" args="(const apop_data *d, size_t col)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__data.html">apop_data</a>* <a class="el" href="apop__regression_8c.html#a77c937ea4764d3da2ed9968273fa4544">apop_text_unique_elements</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>col</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Give me a column of text, and I'll give you a sorted list of the unique elements. This is basically running "select distinct * from datacolumn", but without the aid of the database.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>An <a class="el" href="gentle.html#apop_data">apop_data</a> set with a text component </td></tr>
    <tr><td class="paramname">col</td><td>The text column you want me to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>An <a class="el" href="gentle.html#apop_data">apop_data</a> set with a single sorted column of text, where each unique text input appears once. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="apop__regression_8c.html#a6d68bacc086420a382366f9118cf5bc7">apop_vector_unique_elements</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ac7c0ddb63673ddd40ba69f7dc8bff800"></a><!-- doxytag: member="apop.h::apop_update" ref="ac7c0ddb63673ddd40ba69f7dc8bff800" args="(apop_data *data, apop_model *prior, apop_model *likelihood, gsl_rng *rng)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__model.html">apop_model</a>* <a class="el" href="apop__update_8c.html#ac7c0ddb63673ddd40ba69f7dc8bff800">apop_update</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapop__data.html">apop_data</a> *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structapop__model.html">apop_model</a> *&#160;</td>
          <td class="paramname"><em>prior</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structapop__model.html">apop_model</a> *&#160;</td>
          <td class="paramname"><em>likelihood</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsl_rng *&#160;</td>
          <td class="paramname"><em>rng</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Take in a prior and likelihood distribution, and output a posterior distribution.</p>
<p>This function first checks a table of conjugate distributions for the pair you sent in. If the names match the table, then the function returns a closed-form model with updated parameters. If the parameters aren't in the table of conjugate priors/likelihoods, then it uses Markov Chain Monte Carlo to sample from the posterior distribution, and then outputs a histogram model for further analysis. Notably, the histogram can be used as the input to this function, so you can chain Bayesian updating procedures.</p>
<ul>
<li>If the prior distribution has a <code>p</code> or <code>log_likelihood</code> element, then I use <a class="el" href="apop__update_8c.html#a1a6180e8caa773e287c1fce1bd78c061">apop_model_metropolis</a> to generate the posterior.</li>
</ul>
<ul>
<li>If the prior does not have a <code>p</code> or <code>log_likelihood</code> but does have a <code>draw</code> element, then I make draws from the prior and weight them by the <code>p</code> given by the likelihood distribution. This is not a rejection sampling method, so the burnin is ignored.</li>
</ul>
<p>Here are the conjugate distributions currently defined:</p>
<table class="doxtable">
<tr>
<td>Prior </td><td>Likelihood </td><td>Notes   </td></tr>
<tr>
<td><a class="el" href="group__models.html#gac11decb2971532ada7d2cd4982848b90">Beta</a> </td><td><a class="el" href="group__models.html#ga20017e88fda3695f093279c8191f48e3">Binomial</a> </td><td></td></tr>
<tr>
<td><a class="el" href="group__models.html#gac11decb2971532ada7d2cd4982848b90">Beta</a> </td><td><a class="el" href="group__models.html#gac5437f95ff92d27f389a7b3e27812330">Bernoulli</a> </td><td></td></tr>
<tr>
<td><a class="el" href="group__models.html#ga76b45a5681d30906572263eeef35aeff">Exponential</a> </td><td><a class="el" href="group__models.html#gad11b67493ee1e2038696268a38609367">Gamma</a> </td><td>Gamma likelihood represents the distribution of <img class="formulaInl" alt="$\lambda^{-1}$" src="form_95.png"/>, not plain <img class="formulaInl" alt="$\lambda$" src="form_96.png"/>   </td></tr>
<tr>
<td><a class="el" href="group__models.html#ga297c2dc8dbdf4ae93fc7e10860400466">Normal</a> </td><td><a class="el" href="group__models.html#ga297c2dc8dbdf4ae93fc7e10860400466">Normal</a> </td><td>Assumes prior with fixed <img class="formulaInl" alt="$\sigma$" src="form_71.png"/>; updates distribution for <img class="formulaInl" alt="$\mu$" src="form_74.png"/>  </td></tr>
<tr>
<td><a class="el" href="group__models.html#gad11b67493ee1e2038696268a38609367">Gamma</a> </td><td><a class="el" href="group__models.html#ga9c67838a4761452cc2c9113557f2a070">Poisson</a> </td><td>Uses sum and size of the data  </td></tr>
</table>
<ul>
<li>The conjugate table is stored using a vtable; see <a class="el" href="modeldetails.html#vtables">Registering new methods in vtables</a> for details. The typedef new functions must conform to and the hash used for lookups are:</li>
</ul>
<div class="fragment"><pre class="fragment"><span class="keyword">typedef</span> <a class="code" href="structapop__model.html">apop_model</a> *(*apop_update_type)(<a class="code" href="structapop__data.html">apop_data</a> *, <a class="code" href="apop_8h.html#afe86ae10fc82d219906211e4f88e4cf9">apop_model</a> , <a class="code" href="apop_8h.html#afe86ae10fc82d219906211e4f88e4cf9">apop_model</a>);
<span class="preprocessor">#define apop_update_hash(m1, m2) ((size_t)(m1).draw + (size_t)((m2).log_likelihood ? (m2).log_likelihood : (m2).p)*33)</span>
</pre></div><dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The input data, that will be used by the likelihood function (default = <code>NULL</code>.) </td></tr>
    <tr><td class="paramname">prior</td><td>The prior <a class="el" href="structapop__model.html">apop_model</a>. If the system needs to estimate the posterior via MCMC, this needs to have a <code>log_likelihood</code> or <code>p</code> method. (No default, must not be <code>NULL</code>.) </td></tr>
    <tr><td class="paramname">likelihood</td><td>The likelihood <a class="el" href="structapop__model.html">apop_model</a>. If the system needs to estimate the posterior via MCMC, this needs to have a <code>log_likelihood</code> or <code>p</code> method (ll preferred). (No default, must not be <code>NULL</code>.) </td></tr>
    <tr><td class="paramname">rng</td><td>A <code>gsl_rng</code>, already initialized (e.g., via <a class="el" href="group__convenience__fns.html#gada044cf02135422a9f9292b6054c86dd">apop_rng_alloc</a>). (default: an RNG from <a class="el" href="apop_8h.html#a1e829ce2396bf05ab10460bcc37aeeab">apop_rng_get_thread</a>) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>an <a class="el" href="structapop__model.html">apop_model</a> struct representing the posterior, with updated parameters.</dd></dl>
<p>Here is a test function that compares the output via conjugate table and via Metropolis-Hastings sampling: </p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &lt;<a class="code" href="apop_8h.html">apop.h</a>&gt;</span>
<span class="keywordtype">int</span> main(){
    gsl_rng *r = <a class="code" href="group__convenience__fns.html#gada044cf02135422a9f9292b6054c86dd">apop_rng_alloc</a>(2468);
    <span class="keywordtype">double</span> binom_start = 0.6;
    <span class="keywordtype">double</span> beta_start_a = 0.3;
    <span class="keywordtype">double</span> beta_start_b = 0.5;
    <span class="keywordtype">int</span> i, draws = 1500;
    <span class="keywordtype">double</span> n = 4000;
    <span class="comment">//First, the easy estimation using the conjugate distribution table.</span>
    apop_model *bin = <a class="code" href="group__models.html#ga36cae46a2950eb6cfb65794cdd5dac7e">apop_model_set_parameters</a>(<a class="code" href="group__models.html#ga20017e88fda3695f093279c8191f48e3">apop_binomial</a>, n, binom_start);
    apop_model *beta = <a class="code" href="group__models.html#ga36cae46a2950eb6cfb65794cdd5dac7e">apop_model_set_parameters</a>(<a class="code" href="group__models.html#gac11decb2971532ada7d2cd4982848b90">apop_beta</a>, beta_start_a, beta_start_b);
    apop_model *updated = <a class="code" href="apop_8h.html#ac7c0ddb63673ddd40ba69f7dc8bff800">apop_update</a>(.prior= beta, .likelihood=bin,.rng=r);

    <span class="comment">//Now estimate via MCMC. </span>
    <span class="comment">//Requires a one-parameter binomial, with n fixed,</span>
    <span class="comment">//and a data set of n data points with the right p.</span>
    apop_model *bcopy = <a class="code" href="group__models.html#ga36cae46a2950eb6cfb65794cdd5dac7e">apop_model_set_parameters</a>(<a class="code" href="group__models.html#ga20017e88fda3695f093279c8191f48e3">apop_binomial</a>, n, GSL_NAN);
    apop_data *bin_draws = <a class="code" href="apop_8h.html#acb6b2c53478f9db902ba0340ba499819">apop_data_falloc</a>((1,2), n*(1-binom_start), n*binom_start);
    bin = <a class="code" href="apop_8h.html#ab4f6ca7e042ac7c09c3c01d29702a739">apop_model_fix_params</a>(bcopy);
    <a class="code" href="group__settings.html#ga8fb1877a3cc29edd685a68dd6b4a35dc">Apop_settings_add_group</a>(beta, apop_mcmc, .burnin=.1, .periods=1e4);
    apop_model *out_h = <a class="code" href="apop_8h.html#ac7c0ddb63673ddd40ba69f7dc8bff800">apop_update</a>(bin_draws, beta, bin, NULL);

    <span class="comment">//We now have a histogram of values for p. What&#39;s the closest beta</span>
    <span class="comment">//distribution?</span>
    apop_data *d = <a class="code" href="apop_8h.html#ac39d6a56933b6f084328ec5ecd5090d8">apop_data_alloc</a>(draws, 1);
    <span class="keywordflow">for</span>(i=0; i &lt; draws; i ++)
        <a class="code" href="group__models.html#ga87f15cd1923ed7b5b46e52a77ca1dfef">apop_draw</a>(<a class="code" href="group__data__set__get.html#ga59d1c0299c7eb87224bc6c60555784fe">apop_data_ptr</a>(d, i, 0), r, out_h);
    apop_model *out_beta = <a class="code" href="group__models.html#ga2c0598e5aca68949939a189bd4ce24ca">apop_estimate</a>(d, <a class="code" href="group__models.html#gac11decb2971532ada7d2cd4982848b90">apop_beta</a>);
    <span class="comment">//Finally, we can compare the conjugate and Gibbs results:</span>
    <a class="code" href="apop_8h.html#a194ad92b1bc632ba1d13d9958c7b5b4d">apop_vector_normalize</a>(updated-&gt;<a class="code" href="structapop__model.html#ae016a9e13725e84a1188bc81c8f09e45">parameters</a>-&gt;vector);
    <a class="code" href="apop_8h.html#a194ad92b1bc632ba1d13d9958c7b5b4d">apop_vector_normalize</a>(out_beta-&gt;<a class="code" href="structapop__model.html#ae016a9e13725e84a1188bc81c8f09e45">parameters</a>-&gt;vector);
    <span class="keywordtype">double</span> error = <a class="code" href="group__convenience__fns.html#ga44a77f5e6867c627fd313f3f6e252ff8">apop_vector_distance</a>(updated-&gt;<a class="code" href="structapop__model.html#ae016a9e13725e84a1188bc81c8f09e45">parameters</a>-&gt;vector, out_beta-&gt;<a class="code" href="structapop__model.html#ae016a9e13725e84a1188bc81c8f09e45">parameters</a>-&gt;vector, .metric=<span class="charliteral">&#39;m&#39;</span>);
    <span class="keywordtype">double</span> updated_size = <a class="code" href="group__convenience__fns.html#gaf6182181dd424bc4de98b4bfbd349b4e">apop_vector_sum</a>(updated-&gt;<a class="code" href="structapop__model.html#ae016a9e13725e84a1188bc81c8f09e45">parameters</a>-&gt;vector);
    Apop_assert(error/updated_size &lt; 0.01, <span class="stringliteral">&quot;The error is %g, which is too big.&quot;</span>, error/updated_size);
}
</pre></div><ul>
<li>This function uses the <a class="el" href="designated.html">Designated initializers</a> syntax for inputs. </li>
</ul>

</div>
</div>
<a class="anchor" id="a7c0881e9b640f6c6448014f44f5ac1f5"></a><!-- doxytag: member="apop.h::apop_vector_cov" ref="a7c0881e9b640f6c6448014f44f5ac1f5" args="(gsl_vector const *v1, gsl_vector const *v2, gsl_vector const *weights)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="apop__stats_8c.html#aeb71737b8996eb15f7698246676a78dd">apop_vector_cov</a> </td>
          <td>(</td>
          <td class="paramtype">const gsl_vector *&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const gsl_vector *&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const gsl_vector *&#160;</td>
          <td class="paramname"><em>weights</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Find the sample covariance of a pair of vectors, with an optional weighting. This only makes sense if the weightings are identical, so the function takes only one weighting vector for both.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">v1,v2</td><td>The data vectors </td></tr>
    <tr><td class="paramname">weights</td><td>The weight vector. Default: equal weights for all elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The sample covariance <ul>
<li>This function uses the <a class="el" href="designated.html">Designated initializers</a> syntax for inputs. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ab20e5ad95df0f24a1ea06294695031a8"></a><!-- doxytag: member="apop.h::apop_vector_mean" ref="ab20e5ad95df0f24a1ea06294695031a8" args="(gsl_vector const *v, gsl_vector const *weights)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="apop__stats_8c.html#ab20e5ad95df0f24a1ea06294695031a8">apop_vector_mean</a> </td>
          <td>(</td>
          <td class="paramtype">gsl_vector const *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsl_vector const *&#160;</td>
          <td class="paramname"><em>weights</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Find the mean, weighted or unweighted.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The data vector </td></tr>
    <tr><td class="paramname">weights</td><td>The weight vector. Default: assume equal weights. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The weighted mean <ul>
<li>This function uses the <a class="el" href="designated.html">Designated initializers</a> syntax for inputs. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="acfa62ab9157d4d92338a29093c7d1b30"></a><!-- doxytag: member="apop.h::apop_vector_moving_average" ref="acfa62ab9157d4d92338a29093c7d1b30" args="(gsl_vector *, size_t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int gsl_vector* <a class="el" href="apop__smoothing_8c.html#a9f236ac6d9bff6835c185b9f098d46d3">apop_vector_moving_average</a> </td>
          <td>(</td>
          <td class="paramtype">gsl_vector *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bandwidth</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a new vector that is the moving average of the input vector. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The input vector, unsmoothed </td></tr>
    <tr><td class="paramname">bandwidth</td><td>The number of elements to be smoothed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a194ad92b1bc632ba1d13d9958c7b5b4d"></a><!-- doxytag: member="apop.h::apop_vector_normalize" ref="a194ad92b1bc632ba1d13d9958c7b5b4d" args="(gsl_vector *in, gsl_vector **out, const char normalization_type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="apop__stats_8c.html#a194ad92b1bc632ba1d13d9958c7b5b4d">apop_vector_normalize</a> </td>
          <td>(</td>
          <td class="paramtype">gsl_vector *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsl_vector **&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>normalization_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function will normalize a vector, either such that it has mean zero and variance one, or ranges between zero and one, or sums to one.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>A gsl_vector which you have already allocated and filled. <code>NULL</code> input gives <code>NULL</code> output. (No default)</td></tr>
    <tr><td class="paramname">out</td><td>If normalizing in place, <code>NULL</code>. If not, the address of a <code>gsl_vector</code>. Do not allocate. (default = <code>NULL</code>.)</td></tr>
    <tr><td class="paramname">normalization_type</td><td>'p': normalized vector will sum to one. E.g., start with a set of observations in bins, end with the percentage of observations in each bin. (the default)<br/>
 'r': normalized vector will range between zero and one. Replace each X with (X-min) / (max - min).<br/>
 's': normalized vector will have mean zero and variance one. Replace each X with <img class="formulaInl" alt="$(X-\mu) / \sigma$" src="form_70.png"/>, where <img class="formulaInl" alt="$\sigma$" src="form_71.png"/> is the sample standard deviation.<br/>
 'm': normalize to mean zero: Replace each X with <img class="formulaInl" alt="$(X-\mu)$" src="form_72.png"/><br/>
</td></tr>
  </table>
  </dd>
</dl>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &lt;<a class="code" href="apop_8h.html">apop.h</a>&gt;</span>

<span class="keywordtype">int</span> main(<span class="keywordtype">void</span>){
gsl_vector  *in, *out;

in = gsl_vector_calloc(3);
gsl_vector_set(in, 1, 1);
gsl_vector_set(in, 2, 2);

printf(<span class="stringliteral">&quot;The original vector:\n&quot;</span>);
<a class="code" href="group__apop__print.html#ga8eafc3727869f5ec195809ad6686ba7b">apop_vector_show</a>(in);

<a class="code" href="apop_8h.html#a194ad92b1bc632ba1d13d9958c7b5b4d">apop_vector_normalize</a>(in, &amp;out, <span class="charliteral">&#39;s&#39;</span>);
printf(<span class="stringliteral">&quot;Standardized with mean zero and variance one:\n&quot;</span>);
<a class="code" href="group__apop__print.html#ga8eafc3727869f5ec195809ad6686ba7b">apop_vector_show</a>(out);

<a class="code" href="apop_8h.html#a194ad92b1bc632ba1d13d9958c7b5b4d">apop_vector_normalize</a>(in, &amp;out, <span class="charliteral">&#39;r&#39;</span>);
printf(<span class="stringliteral">&quot;Normalized range with max one and min zero:\n&quot;</span>);
<a class="code" href="group__apop__print.html#ga8eafc3727869f5ec195809ad6686ba7b">apop_vector_show</a>(out);

<a class="code" href="apop_8h.html#a194ad92b1bc632ba1d13d9958c7b5b4d">apop_vector_normalize</a>(in, NULL, <span class="charliteral">&#39;p&#39;</span>);
printf(<span class="stringliteral">&quot;Normalized into percentages:\n&quot;</span>);
<a class="code" href="group__apop__print.html#ga8eafc3727869f5ec195809ad6686ba7b">apop_vector_show</a>(in);
}
</pre></div><ul>
<li>This function uses the <a class="el" href="designated.html">Designated initializers</a> syntax for inputs. </li>
</ul>

</div>
</div>
<a class="anchor" id="afb838084f967543fa8a03e460180d53b"></a><!-- doxytag: member="apop.h::apop_vector_percentiles" ref="afb838084f967543fa8a03e460180d53b" args="(gsl_vector *data, char rounding)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double* <a class="el" href="apop__asst_8c.html#afb838084f967543fa8a03e460180d53b">apop_vector_percentiles</a> </td>
          <td>(</td>
          <td class="paramtype">gsl_vector *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>rounding</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns an array of size 101, where <code>returned_vector</code>[95] gives the value of the 95th percentile, for example. <code>Returned_vector</code>[100] is always the maximum value, and <code>returned_vector</code>[0] is always the min (regardless of rounding rule).</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>a <code>gsl_vector</code> of data. (No default, must not be <code>NULL</code>.) </td></tr>
    <tr><td class="paramname">rounding</td><td>This will either be <code>'u'</code>, <code>'d'</code>, or <code>'a'</code>. Unless your data is exactly a multiple of 101, some percentiles will be ambiguous. If <code>'u'</code>, then round up (use the next highest value); if <code>'d'</code> (or anything else), round down to the next lowest value; if <code>'a'</code>, take the mean of the two nearest points. If <code>'u'</code> or <code>'a'</code>, then you can say "5% or more  of the sample is below \c returned_vector[5]"; if <code>'d'</code> or <code>'a'</code>, then you can say "5% or more of the sample is above returned_vector[5]". (Default = <code>'d'</code>.)</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>You may eventually want to <code>free()</code> the array returned by this function. </li>
<li>This function uses the <a class="el" href="designated.html">Designated initializers</a> syntax for inputs. </li>
</ul>

</div>
</div>
<a class="anchor" id="af4658a3ecc0acfd17f610bc162fa5556"></a><!-- doxytag: member="apop.h::apop_vector_realloc" ref="af4658a3ecc0acfd17f610bc162fa5556" args="(gsl_vector *v, size_t newheight)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gsl_vector* <a class="el" href="apop__data_8c.html#af4658a3ecc0acfd17f610bc162fa5556">apop_vector_realloc</a> </td>
          <td>(</td>
          <td class="paramtype">gsl_vector *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>newheight</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function will resize a <code>gsl_vector</code> to a new length.</p>
<p>Data in the vector will be retained. If the new height is smaller than the old, then data at the end of the vector will be cropped away (in a non--memory-leaking manner). If the new height is larger than the old, then new cells will be filled with garbage; it is your responsibility to zero out or otherwise fill them before use.</p>
<p><b>Warning I</b>: Using this function is basically bad form---especially when used in a <code>for</code> loop that adds an element each time. A large number of <code>realloc</code>s can take a noticeable amount of time. You are thus encouraged to make an effort to determine the size of your data beforehand.</p>
<p><b>Warning II</b>: The <code>gsl_vector</code> is a versatile struct that can represent subvectors, matrix columns and other cuts from parent data. I can't deal with those, and check for such situations beforehand. [Besides, resizing a portion of a parent matrix makes no sense.]</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The already-allocated vector to resize. If you give me <code>NULL</code>, this is equivalent to <code>gsl_vector_alloc</code> </td></tr>
    <tr><td class="paramname">newheight</td><td>The height you'd like the vector to be. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>v, now resized </dd></dl>

</div>
</div>
<a class="anchor" id="a4a69e915d2b6c40f9c69ec1842e2d689"></a><!-- doxytag: member="apop.h::apop_vector_to_data" ref="a4a69e915d2b6c40f9c69ec1842e2d689" args="(gsl_vector *v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__data.html">apop_data</a>* <a class="el" href="apop__data_8c.html#a4a69e915d2b6c40f9c69ec1842e2d689">apop_vector_to_data</a> </td>
          <td>(</td>
          <td class="paramtype">gsl_vector *&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Wrap an <a class="el" href="gentle.html#apop_data">apop_data</a> structure around an existing <code>gsl_vector</code>. The vector is not copied, but is pointed to by the new <a class="el" href="gentle.html#apop_data">apop_data</a> struct.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The data vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>an allocated, ready-to-use <a class="el" href="gentle.html#apop_data">apop_data</a> structure. <ul>
<li>If you give me a <code>NULL</code> vector, I return a blank <a class="el" href="gentle.html#apop_data">apop_data</a> set, equivalent to <code><a class="el" href="apop_8h.html#ac39d6a56933b6f084328ec5ecd5090d8">apop_data_alloc()</a></code>, and print a warning if <code>apop_opts.verbosity &gt;=1</code> </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a6d68bacc086420a382366f9118cf5bc7"></a><!-- doxytag: member="apop.h::apop_vector_unique_elements" ref="a6d68bacc086420a382366f9118cf5bc7" args="(const gsl_vector *v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gsl_vector* <a class="el" href="apop__regression_8c.html#a6d68bacc086420a382366f9118cf5bc7">apop_vector_unique_elements</a> </td>
          <td>(</td>
          <td class="paramtype">const gsl_vector *&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Give me a vector of numbers, and I'll give you a sorted list of the unique elements. This is basically running "select distinct datacol from data order by datacol", but without the aid of the database.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>a vector of items </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a sorted vector of the distinct elements that appear in the input. <ul>
<li>NaNs appear at the end of the sort order. </li>
</ul>
</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="apop__regression_8c.html#a77c937ea4764d3da2ed9968273fa4544">apop_text_unique_elements</a> </dd></dl>

</div>
</div>
<a class="anchor" id="adcc397ab90933d79b3062206301a0aa0"></a><!-- doxytag: member="apop.h::apop_vector_var" ref="adcc397ab90933d79b3062206301a0aa0" args="(gsl_vector const *v, gsl_vector const *weights)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="apop__stats_8c.html#adcc397ab90933d79b3062206301a0aa0">apop_vector_var</a> </td>
          <td>(</td>
          <td class="paramtype">gsl_vector const *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsl_vector const *&#160;</td>
          <td class="paramname"><em>weights</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Find the sample variance of a vector, weighted or unweighted.</p>
<ul>
<li>This uses (n-1) in the denominator of the sum; i.e., it corrects for the bias introduced by using <img class="formulaInl" alt="$\bar x$" src="form_73.png"/> instead of <img class="formulaInl" alt="$\mu$" src="form_74.png"/>.</li>
</ul>
<ul>
<li>At the moment, there is no var_pop function. Just multiply this by (n-1)/n if you need that.</li>
</ul>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The data vector </td></tr>
    <tr><td class="paramname">weights</td><td>The weight vector. If NULL, assume equal weights. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The weighted sample variance.</dd></dl>
<ul>
<li>Apophenia tries to be smart about reading the weights. If weights sum to one, then the system uses <code>w-&gt;size</code> as the number of elements, and returns the usual sum over <img class="formulaInl" alt="$n-1$" src="form_56.png"/>. If weights &gt; 1, then the system uses the total weights as <img class="formulaInl" alt="$n$" src="form_10.png"/>. Thus, you can use the weights as standard weightings or to represent elements that appear repeatedly.</li>
</ul>
<ul>
<li>This function uses the <a class="el" href="designated.html">Designated initializers</a> syntax for inputs. </li>
</ul>

</div>
</div>
<hr/><h2>Variable Documentation</h2>
<a class="anchor" id="a7975faa07196cf463ec261ff0ddc3ccc"></a><!-- doxytag: member="apop.h::apop_opts" ref="a7975faa07196cf463ec261ff0ddc3ccc" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapop__opts__type.html">apop_opts_type</a> <a class="el" href="apop__db_8c.html#a7975faa07196cf463ec261ff0ddc3ccc">apop_opts</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Here are where the options are initially set. See the <a class="el" href="structapop__opts__type.html">apop_opts_type</a> documentation for details. </p>

</div>
</div>
</div><!-- contents -->
<p><p>
<div class="tiny">Autogenerated by doxygen on Wed Mar 19 2014.</div></body></html>
